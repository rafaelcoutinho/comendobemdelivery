/*
	Copyright (c) 2004-2009, The Dojo Foundation All Rights Reserved.
	Available via Academic Free License >= 2.1 OR the modified BSD license.
	see: http://dojotoolkit.org/license for details
*/

/*
	This is a compiled version of Dojo, built for deployment and not for
	development. To get an editable version, please visit:

		http://dojotoolkit.org

	for documentation and information on getting the source.
*/

if(!dojo._hasResource["dijit._base.manager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.manager"] = true;
dojo.provide("dijit._base.manager");

dojo.declare("dijit.WidgetSet", null, {
	// summary:
	//		A set of widgets indexed by id. A default instance of this class is
	//		available as `dijit.registry`
	//
	// example:
	//		Create a small list of widgets:
	//		|	var ws = new dijit.WidgetSet();
	//		|	ws.add(dijit.byId("one"));
	//		| 	ws.add(dijit.byId("two"));
	//		|	// destroy both:
	//		|	ws.forEach(function(w){ w.destroy(); });
	//
	// example:
	//		Using dijit.registry:
	//		|	dijit.registry.forEach(function(w){ /* do something */ });

	constructor: function(){
		this._hash = {};
		this.length = 0;
	},

	add: function(/*dijit._Widget*/ widget){
		// summary:
		//		Add a widget to this list. If a duplicate ID is detected, a error is thrown.
		//
		// widget: dijit._Widget
		//		Any dijit._Widget subclass.
		if(this._hash[widget.id]){
			throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
		}
		this._hash[widget.id] = widget;
		this.length++;
	},

	remove: function(/*String*/ id){
		// summary:
		//		Remove a widget from this WidgetSet. Does not destroy the widget; simply
		//		removes the reference.
		if(this._hash[id]){
			delete this._hash[id];
			this.length--;
		}
	},

	forEach: function(/*Function*/ func, /* Object? */thisObj){
		// summary:
		//		Call specified function for each widget in this set.
		//
		// func:
		//		A callback function to run for each item. Is passed the widget, the index
		//		in the iteration, and the full hash, similar to `dojo.forEach`.
		//
		// thisObj:
		//		An optional scope parameter
		//
		// example:
		//		Using the default `dijit.registry` instance:
		//		|	dijit.registry.forEach(function(widget){
		//		|		console.log(widget.declaredClass);
		//		|	});
		//
		// returns:
		//		Returns self, in order to allow for further chaining.

		thisObj = thisObj || dojo.global;
		var i = 0, id;
		for(id in this._hash){
			func.call(thisObj, this._hash[id], i++, this._hash);
		}
		return this;	// dijit.WidgetSet
	},

	filter: function(/*Function*/ filter, /* Object? */thisObj){
		// summary:
		//		Filter down this WidgetSet to a smaller new WidgetSet
		//		Works the same as `dojo.filter` and `dojo.NodeList.filter`
		//
		// filter:
		//		Callback function to test truthiness. Is passed the widget
		//		reference and the pseudo-index in the object.
		//
		// thisObj: Object?
		//		Option scope to use for the filter function.
		//
		// example:
		//		Arbitrary: select the odd widgets in this list
		//		|	dijit.registry.filter(function(w, i){
		//		|		return i % 2 == 0;
		//		|	}).forEach(function(w){ /* odd ones */ });

		thisObj = thisObj || dojo.global;
		var res = new dijit.WidgetSet(), i = 0, id;
		for(id in this._hash){
			var w = this._hash[id];
			if(filter.call(thisObj, w, i++, this._hash)){
				res.add(w);
			}
		}
		return res; // dijit.WidgetSet
	},

	byId: function(/*String*/ id){
		// summary:
		//		Find a widget in this list by it's id.
		// example:
		//		Test if an id is in a particular WidgetSet
		//		| var ws = new dijit.WidgetSet();
		//		| ws.add(dijit.byId("bar"));
		//		| var t = ws.byId("bar") // returns a widget
		//		| var x = ws.byId("foo"); // returns undefined

		return this._hash[id];	// dijit._Widget
	},

	byClass: function(/*String*/ cls){
		// summary:
		//		Reduce this widgetset to a new WidgetSet of a particular `declaredClass`
		//
		// cls: String
		//		The Class to scan for. Full dot-notated string.
		//
		// example:
		//		Find all `dijit.TitlePane`s in a page:
		//		|	dijit.registry.byClass("dijit.TitlePane").forEach(function(tp){ tp.close(); });

		var res = new dijit.WidgetSet(), id, widget;
		for(id in this._hash){
			widget = this._hash[id];
			if(widget.declaredClass == cls){
				res.add(widget);
			}
		 }
		 return res; // dijit.WidgetSet
},

	toArray: function(){
		// summary:
		//		Convert this WidgetSet into a true Array
		//
		// example:
		//		Work with the widget .domNodes in a real Array
		//		|	dojo.map(dijit.registry.toArray(), function(w){ return w.domNode; });

		var ar = [];
		for(var id in this._hash){
			ar.push(this._hash[id]);
		}
		return ar;	// dijit._Widget[]
},

	map: function(/* Function */func, /* Object? */thisObj){
		// summary:
		//		Create a new Array from this WidgetSet, following the same rules as `dojo.map`
		// example:
		//		|	var nodes = dijit.registry.map(function(w){ return w.domNode; });
		//
		// returns:
		//		A new array of the returned values.
		return dojo.map(this.toArray(), func, thisObj); // Array
	},

	every: function(func, thisObj){
		// summary:
		// 		A synthetic clone of `dojo.every` acting explictly on this WidgetSet
		//
		// func: Function
		//		A callback function run for every widget in this list. Exits loop
		//		when the first false return is encountered.
		//
		// thisObj: Object?
		//		Optional scope parameter to use for the callback

		thisObj = thisObj || dojo.global;
		var x = 0, i;
		for(i in this._hash){
			if(!func.call(thisObj, this._hash[i], x++, this._hash)){
				return false; // Boolean
			}
		}
		return true; // Boolean
	},

	some: function(func, thisObj){
		// summary:
		// 		A synthetic clone of `dojo.some` acting explictly on this WidgetSet
		//
		// func: Function
		//		A callback function run for every widget in this list. Exits loop
		//		when the first true return is encountered.
		//
		// thisObj: Object?
		//		Optional scope parameter to use for the callback

		thisObj = thisObj || dojo.global;
		var x = 0, i;
		for(i in this._hash){
			if(func.call(thisObj, this._hash[i], x++, this._hash)){
				return true; // Boolean
			}
		}
		return false; // Boolean
	}

});

/*=====
dijit.registry = {
	// summary:
	//		A list of widgets on a page.
	// description:
	//		Is an instance of `dijit.WidgetSet`
};
=====*/
dijit.registry= new dijit.WidgetSet();

dijit._widgetTypeCtr = {};

dijit.getUniqueId = function(/*String*/widgetType){
	// summary:
	//		Generates a unique id for a given widgetType

	var id;
	do{
		id = widgetType + "_" +
			(widgetType in dijit._widgetTypeCtr ?
				++dijit._widgetTypeCtr[widgetType] : dijit._widgetTypeCtr[widgetType] = 0);
	}while(dijit.byId(id));
	return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
};

dijit.findWidgets = function(/*DomNode*/ root){
	// summary:
	//		Search subtree under root returning widgets found.
	//		Doesn't search for nested widgets (ie, widgets inside other widgets).

	var outAry = [];

	function getChildrenHelper(root){
		for(var node = root.firstChild; node; node = node.nextSibling){
			if(node.nodeType == 1){
				var widgetId = node.getAttribute("widgetId");
				if(widgetId){
					var widget = dijit.byId(widgetId);
					outAry.push(widget);
				}else{
					getChildrenHelper(node);
				}
			}
		}
	}

	getChildrenHelper(root);
	return outAry;
};

dijit._destroyAll = function(){
	// summary:
	//		Code to destroy all widgets and do other cleanup on page unload

	// Clean up focus manager lingering references to widgets and nodes
	dijit._curFocus = null;
	dijit._prevFocus = null;
	dijit._activeStack = [];

	// Destroy all the widgets, top down
	dojo.forEach(dijit.findWidgets(dojo.body()), function(widget){
		// Avoid double destroy of widgets like Menu that are attached to <body>
		// even though they are logically children of other widgets.
		if(!widget._destroyed){
			if(widget.destroyRecursive){
				widget.destroyRecursive();
			}else if(widget.destroy){
				widget.destroy();
			}
		}
	});
};

if(dojo.isIE){
	// Only run _destroyAll() for IE because we think it's only necessary in that case,
	// and because it causes problems on FF.  See bug #3531 for details.
	dojo.addOnWindowUnload(function(){
		dijit._destroyAll();
	});
}

dijit.byId = function(/*String|Widget*/id){
	// summary:
	//		Returns a widget by it's id, or if passed a widget, no-op (like dojo.byId())
	return typeof id == "string" ? dijit.registry._hash[id] : id; // dijit._Widget
};

dijit.byNode = function(/* DOMNode */ node){
	// summary:
	//		Returns the widget corresponding to the given DOMNode
	return dijit.registry.byId(node.getAttribute("widgetId")); // dijit._Widget
};

dijit.getEnclosingWidget = function(/* DOMNode */ node){
	// summary:
	//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
	//		the node is not contained within the DOM tree of any widget
	while(node){
		var id = node.getAttribute && node.getAttribute("widgetId");
		if(id){
			return dijit.byId(id);
		}
		node = node.parentNode;
	}
	return null;
};

dijit._isElementShown = function(/*Element*/elem){
	var style = dojo.style(elem);
	return (style.visibility != "hidden")
		&& (style.visibility != "collapsed")
		&& (style.display != "none")
		&& (dojo.attr(elem, "type") != "hidden");
}

dijit.isTabNavigable = function(/*Element*/elem){
	// summary:
	//		Tests if an element is tab-navigable

	// TODO: convert (and rename method) to return effectivite tabIndex; will save time in _getTabNavigable()
	if(dojo.attr(elem, "disabled")){
		return false;
	}else if(dojo.hasAttr(elem, "tabIndex")){
		// Explicit tab index setting
		return dojo.attr(elem, "tabIndex") >= 0; // boolean
	}else{
		// No explicit tabIndex setting, need to investigate node type
		switch(elem.nodeName.toLowerCase()){
			case "a":
				// An <a> w/out a tabindex is only navigable if it has an href
				return dojo.hasAttr(elem, "href");
			case "area":
			case "button":
			case "input":
			case "object":
			case "select":
			case "textarea":
				// These are navigable by default
				return true;
			case "iframe":
				// If it's an editor <iframe> then it's tab navigable.
				if(dojo.isMoz){
					return elem.contentDocument.designMode == "on";
				}else if(dojo.isWebKit){
					var doc = elem.contentDocument,
						body = doc && doc.body;
					return body && body.contentEditable == 'true';
				}else{
					// contentWindow.document isn't accessible within IE7/8
					// if the iframe.src points to a foreign url and this
					// page contains an element, that could get focus
					try{
						doc = elem.contentWindow.document;
						body = doc && doc.body;
						return body && body.firstChild && body.firstChild.contentEditable == 'true';
					}catch(e){
						return false;
					}
				}
			default:
				return elem.contentEditable == 'true';
		}
	}
};

dijit._getTabNavigable = function(/*DOMNode*/root){
	// summary:
	//		Finds descendants of the specified root node.
	//
	// description:
	//		Finds the following descendants of the specified root node:
	//		* the first tab-navigable element in document order
	//		  without a tabIndex or with tabIndex="0"
	//		* the last tab-navigable element in document order
	//		  without a tabIndex or with tabIndex="0"
	//		* the first element in document order with the lowest
	//		  positive tabIndex value
	//		* the last element in document order with the highest
	//		  positive tabIndex value
	var first, last, lowest, lowestTabindex, highest, highestTabindex;
	var walkTree = function(/*DOMNode*/parent){
		dojo.query("> *", parent).forEach(function(child){
			var isShown = dijit._isElementShown(child);
			if(isShown && dijit.isTabNavigable(child)){
				var tabindex = dojo.attr(child, "tabIndex");
				if(!dojo.hasAttr(child, "tabIndex") || tabindex == 0){
					if(!first){ first = child; }
					last = child;
				}else if(tabindex > 0){
					if(!lowest || tabindex < lowestTabindex){
						lowestTabindex = tabindex;
						lowest = child;
					}
					if(!highest || tabindex >= highestTabindex){
						highestTabindex = tabindex;
						highest = child;
					}
				}
			}
			if(isShown && child.nodeName.toUpperCase() != 'SELECT'){ walkTree(child) }
		});
	};
	if(dijit._isElementShown(root)){ walkTree(root) }
	return { first: first, last: last, lowest: lowest, highest: highest };
}
dijit.getFirstInTabbingOrder = function(/*String|DOMNode*/root){
	// summary:
	//		Finds the descendant of the specified root node
	//		that is first in the tabbing order
	var elems = dijit._getTabNavigable(dojo.byId(root));
	return elems.lowest ? elems.lowest : elems.first; // DomNode
};

dijit.getLastInTabbingOrder = function(/*String|DOMNode*/root){
	// summary:
	//		Finds the descendant of the specified root node
	//		that is last in the tabbing order
	var elems = dijit._getTabNavigable(dojo.byId(root));
	return elems.last ? elems.last : elems.highest; // DomNode
};

/*=====
dojo.mixin(dijit, {
	// defaultDuration: Integer
	//		The default animation speed (in ms) to use for all Dijit
	//		transitional animations, unless otherwise specified
	//		on a per-instance basis. Defaults to 200, overrided by
	//		`djConfig.defaultDuration`
	defaultDuration: 300
});
=====*/

dijit.defaultDuration = dojo.config["defaultDuration"] || 200;

}

if(!dojo._hasResource["dijit._base.focus"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.focus"] = true;
dojo.provide("dijit._base.focus");

	// for dijit.isTabNavigable()

// summary:
//		These functions are used to query or set the focus and selection.
//
//		Also, they trace when widgets become activated/deactivated,
//		so that the widget can fire _onFocus/_onBlur events.
//		"Active" here means something similar to "focused", but
//		"focus" isn't quite the right word because we keep track of
//		a whole stack of "active" widgets.  Example: ComboButton --> Menu -->
//		MenuItem.  The onBlur event for ComboButton doesn't fire due to focusing
//		on the Menu or a MenuItem, since they are considered part of the
//		ComboButton widget.  It only happens when focus is shifted
//		somewhere completely different.

dojo.mixin(dijit, {
	// _curFocus: DomNode
	//		Currently focused item on screen
	_curFocus: null,

	// _prevFocus: DomNode
	//		Previously focused item on screen
	_prevFocus: null,

	isCollapsed: function(){
		// summary:
		//		Returns true if there is no text selected
		return dijit.getBookmark().isCollapsed;
	},

	getBookmark: function(){
		// summary:
		//		Retrieves a bookmark that can be used with moveToBookmark to return to the same range
		var bm, rg, tg, sel = dojo.doc.selection, cf = dijit._curFocus;

		if(dojo.global.getSelection){
			//W3C Range API for selections.
			sel = dojo.global.getSelection();
			if(sel){
				if(sel.isCollapsed){
					tg = cf? cf.tagName : "";
					if(tg){
						//Create a fake rangelike item to restore selections.
						tg = tg.toLowerCase();
						if(tg == "textarea" ||
								(tg == "input" && (!cf.type || cf.type.toLowerCase() == "text"))){
							sel = {
								start: cf.selectionStart,
								end: cf.selectionEnd,
								node: cf,
								pRange: true
							};
							return {isCollapsed: (sel.end <= sel.start), mark: sel}; //Object.
						}
					}
					bm = {isCollapsed:true};
				}else{
					rg = sel.getRangeAt(0);
					bm = {isCollapsed: false, mark: rg.cloneRange()};
				}
			}
		}else if(sel){
			// If the current focus was a input of some sort and no selection, don't bother saving
			// a native bookmark.  This is because it causes issues with dialog/page selection restore.
			// So, we need to create psuedo bookmarks to work with.
			tg = cf ? cf.tagName : "";
			tg = tg.toLowerCase();
			if(cf && tg && (tg == "button" || tg == "textarea" || tg == "input")){
				if(sel.type && sel.type.toLowerCase() == "none"){
					return {
						isCollapsed: true,
						mark: null
					}
				}else{
					rg = sel.createRange();
					return {
						isCollapsed: rg.text && rg.text.length?false:true,
						mark: {
							range: rg,
							pRange: true
						}
					};
				}
			}
			bm = {};

			//'IE' way for selections.
			try{
				// createRange() throws exception when dojo in iframe
				//and nothing selected, see #9632
				rg = sel.createRange();
				bm.isCollapsed = !(sel.type == 'Text' ? rg.htmlText.length : rg.length);
			}catch(e){
				bm.isCollapsed = true;
				return bm;
			}
			if(sel.type.toUpperCase() == 'CONTROL'){
				if(rg.length){
					bm.mark=[];
					var i=0,len=rg.length;
					while(i<len){
						bm.mark.push(rg.item(i++));
					}
				}else{
					bm.isCollapsed = true;
					bm.mark = null;
				}
			}else{
				bm.mark = rg.getBookmark();
			}
		}else{
			console.warn("No idea how to store the current selection for this browser!");
		}
		return bm; // Object
	},

	moveToBookmark: function(/*Object*/bookmark){
		// summary:
		//		Moves current selection to a bookmark
		// bookmark:
		//		This should be a returned object from dijit.getBookmark()

		var _doc = dojo.doc,
			mark = bookmark.mark;
		if(mark){
			if(dojo.global.getSelection){
				//W3C Rangi API (FF, WebKit, Opera, etc)
				var sel = dojo.global.getSelection();
				if(sel && sel.removeAllRanges){
					if(mark.pRange){
						var r = mark;
						var n = r.node;
						n.selectionStart = r.start;
						n.selectionEnd = r.end;
					}else{
						sel.removeAllRanges();
						sel.addRange(mark);
					}
				}else{
					console.warn("No idea how to restore selection for this browser!");
				}
			}else if(_doc.selection && mark){
				//'IE' way.
				var rg;
				if(mark.pRange){
					rg = mark.range;
				}else if(dojo.isArray(mark)){
					rg = _doc.body.createControlRange();
					//rg.addElement does not have call/apply method, so can not call it directly
					//rg is not available in "range.addElement(item)", so can't use that either
					dojo.forEach(mark, function(n){
						rg.addElement(n);
					});
				}else{
					rg = _doc.body.createTextRange();
					rg.moveToBookmark(mark);
				}
				rg.select();
			}
		}
	},

	getFocus: function(/*Widget?*/ menu, /*Window?*/ openedForWindow){
		// summary:
		//		Called as getFocus(), this returns an Object showing the current focus
		//		and selected text.
		//
		//		Called as getFocus(widget), where widget is a (widget representing) a button
		//		that was just pressed, it returns where focus was before that button
		//		was pressed.   (Pressing the button may have either shifted focus to the button,
		//		or removed focus altogether.)   In this case the selected text is not returned,
		//		since it can't be accurately determined.
		//
		// menu: dijit._Widget or {domNode: DomNode} structure
		//		The button that was just pressed.  If focus has disappeared or moved
		//		to this button, returns the previous focus.  In this case the bookmark
		//		information is already lost, and null is returned.
		//
		// openedForWindow:
		//		iframe in which menu was opened
		//
		// returns:
		//		A handle to restore focus/selection, to be passed to `dijit.focus`
		var node = !dijit._curFocus || (menu && dojo.isDescendant(dijit._curFocus, menu.domNode)) ? dijit._prevFocus : dijit._curFocus;
		return {
			node: node,
			bookmark: (node == dijit._curFocus) && dojo.withGlobal(openedForWindow || dojo.global, dijit.getBookmark),
			openedForWindow: openedForWindow
		}; // Object
	},

	focus: function(/*Object || DomNode */ handle){
		// summary:
		//		Sets the focused node and the selection according to argument.
		//		To set focus to an iframe's content, pass in the iframe itself.
		// handle:
		//		object returned by get(), or a DomNode

		if(!handle){ return; }

		var node = "node" in handle ? handle.node : handle,		// because handle is either DomNode or a composite object
			bookmark = handle.bookmark,
			openedForWindow = handle.openedForWindow,
			collapsed = bookmark ? bookmark.isCollapsed : false;

		// Set the focus
		// Note that for iframe's we need to use the <iframe> to follow the parentNode chain,
		// but we need to set focus to iframe.contentWindow
		if(node){
			var focusNode = (node.tagName.toLowerCase() == "iframe") ? node.contentWindow : node;
			if(focusNode && focusNode.focus){
				try{
					// Gecko throws sometimes if setting focus is impossible,
					// node not displayed or something like that
					focusNode.focus();
				}catch(e){/*quiet*/}
			}
			dijit._onFocusNode(node);
		}

		// set the selection
		// do not need to restore if current selection is not empty
		// (use keyboard to select a menu item) or if previous selection was collapsed
		// as it may cause focus shift (Esp in IE).
		if(bookmark && dojo.withGlobal(openedForWindow || dojo.global, dijit.isCollapsed) && !collapsed){
			if(openedForWindow){
				openedForWindow.focus();
			}
			try{
				dojo.withGlobal(openedForWindow || dojo.global, dijit.moveToBookmark, null, [bookmark]);
			}catch(e2){
				/*squelch IE internal error, see http://trac.dojotoolkit.org/ticket/1984 */
			}
		}
	},

	// _activeStack: dijit._Widget[]
	//		List of currently active widgets (focused widget and it's ancestors)
	_activeStack: [],

	registerIframe: function(/*DomNode*/ iframe){
		// summary:
		//		Registers listeners on the specified iframe so that any click
		//		or focus event on that iframe (or anything in it) is reported
		//		as a focus/click event on the <iframe> itself.
		// description:
		//		Currently only used by editor.
		// returns:
		//		Handle to pass to unregisterIframe()
		return dijit.registerWin(iframe.contentWindow, iframe);
	},

	unregisterIframe: function(/*Object*/ handle){
		// summary:
		//		Unregisters listeners on the specified iframe created by registerIframe.
		//		After calling be sure to delete or null out the handle itself.
		// handle:
		//		Handle returned by registerIframe()

		dijit.unregisterWin(handle);
	},

	registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
		// summary:
		//		Registers listeners on the specified window (either the main
		//		window or an iframe's window) to detect when the user has clicked somewhere
		//		or focused somewhere.
		// description:
		//		Users should call registerIframe() instead of this method.
		// targetWindow:
		//		If specified this is the window associated with the iframe,
		//		i.e. iframe.contentWindow.
		// effectiveNode:
		//		If specified, report any focus events inside targetWindow as
		//		an event on effectiveNode, rather than on evt.target.
		// returns:
		//		Handle to pass to unregisterWin()

		// TODO: make this function private in 2.0; Editor/users should call registerIframe(),

		var mousedownListener = function(evt){
			dijit._justMouseDowned = true;
			setTimeout(function(){ dijit._justMouseDowned = false; }, 0);
			dijit._onTouchNode(effectiveNode || evt.target || evt.srcElement, "mouse");
		};
		//dojo.connect(targetWindow, "onscroll", ???);

		// Listen for blur and focus events on targetWindow's document.
		// IIRC, I'm using attachEvent() rather than dojo.connect() because focus/blur events don't bubble
		// through dojo.connect(), and also maybe to catch the focus events early, before onfocus handlers
		// fire.
		// Connect to <html> (rather than document) on IE to avoid memory leaks, but document on other browsers because
		// (at least for FF) the focus event doesn't fire on <html> or <body>.
		var doc = dojo.isIE ? targetWindow.document.documentElement : targetWindow.document;
		if(doc){
			if(dojo.isIE){
				doc.attachEvent('onmousedown', mousedownListener);
				var activateListener = function(evt){
					// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
					// Should consider those more like a mouse-click than a focus....
					if(evt.srcElement.tagName.toLowerCase() != "#document" &&
						dijit.isTabNavigable(evt.srcElement)){
						dijit._onFocusNode(effectiveNode || evt.srcElement);
					}else{
						dijit._onTouchNode(effectiveNode || evt.srcElement);
					}
				};
				doc.attachEvent('onactivate', activateListener);
				var deactivateListener =  function(evt){
					dijit._onBlurNode(effectiveNode || evt.srcElement);
				};
				doc.attachEvent('ondeactivate', deactivateListener);

				return function(){
					doc.detachEvent('onmousedown', mousedownListener);
					doc.detachEvent('onactivate', activateListener);
					doc.detachEvent('ondeactivate', deactivateListener);
					doc = null;	// prevent memory leak (apparent circular reference via closure)
				};
			}else{
				doc.addEventListener('mousedown', mousedownListener, true);
				var focusListener = function(evt){
					dijit._onFocusNode(effectiveNode || evt.target);
				};
				doc.addEventListener('focus', focusListener, true);
				var blurListener = function(evt){
					dijit._onBlurNode(effectiveNode || evt.target);
				};
				doc.addEventListener('blur', blurListener, true);

				return function(){
					doc.removeEventListener('mousedown', mousedownListener, true);
					doc.removeEventListener('focus', focusListener, true);
					doc.removeEventListener('blur', blurListener, true);
					doc = null;	// prevent memory leak (apparent circular reference via closure)
				};
			}
		}
	},

	unregisterWin: function(/*Handle*/ handle){
		// summary:
		//		Unregisters listeners on the specified window (either the main
		//		window or an iframe's window) according to handle returned from registerWin().
		//		After calling be sure to delete or null out the handle itself.

		// Currently our handle is actually a function
		handle && handle();
	},

	_onBlurNode: function(/*DomNode*/ node){
		// summary:
		// 		Called when focus leaves a node.
		//		Usually ignored, _unless_ it *isn't* follwed by touching another node,
		//		which indicates that we tabbed off the last field on the page,
		//		in which case every widget is marked inactive
		dijit._prevFocus = dijit._curFocus;
		dijit._curFocus = null;

		if(dijit._justMouseDowned){
			// the mouse down caused a new widget to be marked as active; this blur event
			// is coming late, so ignore it.
			return;
		}

		// if the blur event isn't followed by a focus event then mark all widgets as inactive.
		if(dijit._clearActiveWidgetsTimer){
			clearTimeout(dijit._clearActiveWidgetsTimer);
		}
		dijit._clearActiveWidgetsTimer = setTimeout(function(){
			delete dijit._clearActiveWidgetsTimer;
			dijit._setStack([]);
			dijit._prevFocus = null;
		}, 100);
	},

	_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
		// summary:
		//		Callback when node is focused or mouse-downed
		// node:
		//		The node that was touched.
		// by:
		//		"mouse" if the focus/touch was caused by a mouse down event

		// ignore the recent blurNode event
		if(dijit._clearActiveWidgetsTimer){
			clearTimeout(dijit._clearActiveWidgetsTimer);
			delete dijit._clearActiveWidgetsTimer;
		}

		// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
		var newStack=[];
		try{
			while(node){
				var popupParent = dojo.attr(node, "dijitPopupParent");
				if(popupParent){
					node=dijit.byId(popupParent).domNode;
				}else if(node.tagName && node.tagName.toLowerCase() == "body"){
					// is this the root of the document or just the root of an iframe?
					if(node === dojo.body()){
						// node is the root of the main document
						break;
					}
					// otherwise, find the iframe this node refers to (can't access it via parentNode,
					// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
					node=dijit.getDocumentWindow(node.ownerDocument).frameElement;
				}else{
					var id = node.getAttribute && node.getAttribute("widgetId");
					if(id){
						newStack.unshift(id);
					}
					node=node.parentNode;
				}
			}
		}catch(e){ /* squelch */ }

		dijit._setStack(newStack, by);
	},

	_onFocusNode: function(/*DomNode*/ node){
		// summary:
		//		Callback when node is focused

		if(!node){
			return;
		}

		if(node.nodeType == 9){
			// Ignore focus events on the document itself.  This is here so that
			// (for example) clicking the up/down arrows of a spinner
			// (which don't get focus) won't cause that widget to blur. (FF issue)
			return;
		}

		dijit._onTouchNode(node);

		if(node == dijit._curFocus){ return; }
		if(dijit._curFocus){
			dijit._prevFocus = dijit._curFocus;
		}
		dijit._curFocus = node;
		dojo.publish("focusNode", [node]);
	},

	_setStack: function(/*String[]*/ newStack, /*String*/ by){
		// summary:
		//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
		// newStack:
		//		array of widget id's, starting from the top (outermost) widget
		// by:
		//		"mouse" if the focus/touch was caused by a mouse down event

		var oldStack = dijit._activeStack;
		dijit._activeStack = newStack;

		// compare old stack to new stack to see how many elements they have in common
		for(var nCommon=0; nCommon<Math.min(oldStack.length, newStack.length); nCommon++){
			if(oldStack[nCommon] != newStack[nCommon]){
				break;
			}
		}

		var widget;
		// for all elements that have gone out of focus, send blur event
		for(var i=oldStack.length-1; i>=nCommon; i--){
			widget = dijit.byId(oldStack[i]);
			if(widget){
				widget._focused = false;
				widget._hasBeenBlurred = true;
				if(widget._onBlur){
					widget._onBlur(by);
				}
				if(widget._setStateClass){
					widget._setStateClass();
				}
				dojo.publish("widgetBlur", [widget, by]);
			}
		}

		// for all element that have come into focus, send focus event
		for(i=nCommon; i<newStack.length; i++){
			widget = dijit.byId(newStack[i]);
			if(widget){
				widget._focused = true;
				if(widget._onFocus){
					widget._onFocus(by);
				}
				if(widget._setStateClass){
					widget._setStateClass();
				}
				dojo.publish("widgetFocus", [widget, by]);
			}
		}
	}
});

// register top window and all the iframes it contains
dojo.addOnLoad(function(){
	var handle = dijit.registerWin(window);
	if(dojo.isIE){
		dojo.addOnWindowUnload(function(){
			dijit.unregisterWin(handle);
			handle = null;
		})
	}
});

}

if(!dojo._hasResource["dojo.AdapterRegistry"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.AdapterRegistry"] = true;
dojo.provide("dojo.AdapterRegistry");

dojo.AdapterRegistry = function(/*Boolean?*/ returnWrappers){
	//	summary:
	//		A registry to make contextual calling/searching easier.
	//	description:
	//		Objects of this class keep list of arrays in the form [name, check,
	//		wrap, directReturn] that are used to determine what the contextual
	//		result of a set of checked arguments is. All check/wrap functions
	//		in this registry should be of the same arity.
	//	example:
	//	|	// create a new registry
	//	|	var reg = new dojo.AdapterRegistry();
	//	|	reg.register("handleString",
	//	|		dojo.isString,
	//	|		function(str){
	//	|			// do something with the string here
	//	|		}
	//	|	);
	//	|	reg.register("handleArr",
	//	|		dojo.isArray,
	//	|		function(arr){
	//	|			// do something with the array here
	//	|		}
	//	|	);
	//	|
	//	|	// now we can pass reg.match() *either* an array or a string and
	//	|	// the value we pass will get handled by the right function
	//	|	reg.match("someValue"); // will call the first function
	//	|	reg.match(["someValue"]); // will call the second

	this.pairs = [];
	this.returnWrappers = returnWrappers || false; // Boolean
}

dojo.extend(dojo.AdapterRegistry, {
	register: function(/*String*/ name, /*Function*/ check, /*Function*/ wrap, /*Boolean?*/ directReturn, /*Boolean?*/ override){
		//	summary: 
		//		register a check function to determine if the wrap function or
		//		object gets selected
		//	name:
		//		a way to identify this matcher.
		//	check:
		//		a function that arguments are passed to from the adapter's
		//		match() function.  The check function should return true if the
		//		given arguments are appropriate for the wrap function.
		//	directReturn:
		//		If directReturn is true, the value passed in for wrap will be
		//		returned instead of being called. Alternately, the
		//		AdapterRegistry can be set globally to "return not call" using
		//		the returnWrappers property. Either way, this behavior allows
		//		the registry to act as a "search" function instead of a
		//		function interception library.
		//	override:
		//		If override is given and true, the check function will be given
		//		highest priority. Otherwise, it will be the lowest priority
		//		adapter.
		this.pairs[((override) ? "unshift" : "push")]([name, check, wrap, directReturn]);
	},

	match: function(/* ... */){
		// summary:
		//		Find an adapter for the given arguments. If no suitable adapter
		//		is found, throws an exception. match() accepts any number of
		//		arguments, all of which are passed to all matching functions
		//		from the registered pairs.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[1].apply(this, arguments)){
				if((pair[3])||(this.returnWrappers)){
					return pair[2];
				}else{
					return pair[2].apply(this, arguments);
				}
			}
		}
		throw new Error("No match found");
	},

	unregister: function(name){
		// summary: Remove a named adapter from the registry

		// FIXME: this is kind of a dumb way to handle this. On a large
		// registry this will be slow-ish and we can use the name as a lookup
		// should we choose to trade memory for speed.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[0] == name){
				this.pairs.splice(i, 1);
				return true;
			}
		}
		return false;
	}
});

}

if(!dojo._hasResource["dijit._base.place"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.place"] = true;
dojo.provide("dijit._base.place");



// ported from dojo.html.util

dijit.getViewport = function(){
	// summary:
	//		Returns the dimensions and scroll position of the viewable area of a browser window

	var scrollRoot = (dojo.doc.compatMode == 'BackCompat')? dojo.body() : dojo.doc.documentElement;

	// get scroll position
	var scroll = dojo._docScroll(); // scrollRoot.scrollTop/Left should work
	return { w: scrollRoot.clientWidth, h: scrollRoot.clientHeight, l: scroll.x, t: scroll.y };
};

/*=====
dijit.__Position = function(){
	// x: Integer
	//		horizontal coordinate in pixels, relative to document body
	// y: Integer
	//		vertical coordinate in pixels, relative to document body

	thix.x = x;
	this.y = y;
}
=====*/


dijit.placeOnScreen = function(
	/* DomNode */			node,
	/* dijit.__Position */	pos,
	/* String[] */			corners,
	/* dijit.__Position? */	padding){
	// summary:
	//		Positions one of the node's corners at specified position
	//		such that node is fully visible in viewport.
	// description:
	//		NOTE: node is assumed to be absolutely or relatively positioned.
	//	pos:
	//		Object like {x: 10, y: 20}
	//	corners:
	//		Array of Strings representing order to try corners in, like ["TR", "BL"].
	//		Possible values are:
	//			* "BL" - bottom left
	//			* "BR" - bottom right
	//			* "TL" - top left
	//			* "TR" - top right
	//	padding:
	//		set padding to put some buffer around the element you want to position.
	// example:
	//		Try to place node's top right corner at (10,20).
	//		If that makes node go (partially) off screen, then try placing
	//		bottom left corner at (10,20).
	//	|	placeOnScreen(node, {x: 10, y: 20}, ["TR", "BL"])

	var choices = dojo.map(corners, function(corner){
		var c = { corner: corner, pos: {x:pos.x,y:pos.y} };
		if(padding){
			c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
			c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
		}
		return c;
	});

	return dijit._place(node, choices);
}

dijit._place = function(/*DomNode*/ node, /* Array */ choices, /* Function */ layoutNode){
	// summary:
	//		Given a list of spots to put node, put it at the first spot where it fits,
	//		of if it doesn't fit anywhere then the place with the least overflow
	// choices: Array
	//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
	//		Above example says to put the top-left corner of the node at (10,20)
	// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
	//		for things like tooltip, they are displayed differently (and have different dimensions)
	//		based on their orientation relative to the parent.   This adjusts the popup based on orientation.

	// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
	// viewport over document
	var view = dijit.getViewport();

	// This won't work if the node is inside a <div style="position: relative">,
	// so reattach it to dojo.doc.body.   (Otherwise, the positioning will be wrong
	// and also it might get cutoff)
	if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
		dojo.body().appendChild(node);
	}

	var best = null;
	dojo.some(choices, function(choice){
		var corner = choice.corner;
		var pos = choice.pos;

		// configure node to be displayed in given position relative to button
		// (need to do this in order to get an accurate size for the node, because
		// a tooltips size changes based on position, due to triangle)
		if(layoutNode){
			layoutNode(node, choice.aroundCorner, corner);
		}

		// get node's size
		var style = node.style;
		var oldDisplay = style.display;
		var oldVis = style.visibility;
		style.visibility = "hidden";
		style.display = "";
		var mb = dojo.marginBox(node);
		style.display = oldDisplay;
		style.visibility = oldVis;

		// coordinates and size of node with specified corner placed at pos,
		// and clipped by viewport
		var startX = Math.max(view.l, corner.charAt(1) == 'L' ? pos.x : (pos.x - mb.w)),
			startY = Math.max(view.t, corner.charAt(0) == 'T' ? pos.y : (pos.y - mb.h)),
			endX = Math.min(view.l + view.w, corner.charAt(1) == 'L' ? (startX + mb.w) : pos.x),
			endY = Math.min(view.t + view.h, corner.charAt(0) == 'T' ? (startY + mb.h) : pos.y),
			width = endX - startX,
			height = endY - startY,
			overflow = (mb.w - width) + (mb.h - height);

		if(best == null || overflow < best.overflow){
			best = {
				corner: corner,
				aroundCorner: choice.aroundCorner,
				x: startX,
				y: startY,
				w: width,
				h: height,
				overflow: overflow
			};
		}
		return !overflow;
	});

	node.style.left = best.x + "px";
	node.style.top = best.y + "px";
	if(best.overflow && layoutNode){
		layoutNode(node, best.aroundCorner, best.corner);
	}
	return best;
}

dijit.placeOnScreenAroundNode = function(
	/* DomNode */		node,
	/* DomNode */		aroundNode,
	/* Object */		aroundCorners,
	/* Function? */		layoutNode){

	// summary:
	//		Position node adjacent or kitty-corner to aroundNode
	//		such that it's fully visible in viewport.
	//
	// description:
	//		Place node such that corner of node touches a corner of
	//		aroundNode, and that node is fully visible.
	//
	// aroundCorners:
	//		Ordered list of pairs of corners to try matching up.
	//		Each pair of corners is represented as a key/value in the hash,
	//		where the key corresponds to the aroundNode's corner, and
	//		the value corresponds to the node's corner:
	//
	//	|	{ aroundNodeCorner1: nodeCorner1, aroundNodeCorner2: nodeCorner2, ...}
	//
	//		The following strings are used to represent the four corners:
	//			* "BL" - bottom left
	//			* "BR" - bottom right
	//			* "TL" - top left
	//			* "TR" - top right
	//
	// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
	//		For things like tooltip, they are displayed differently (and have different dimensions)
	//		based on their orientation relative to the parent.   This adjusts the popup based on orientation.
	//
	// example:
	//	|	dijit.placeOnScreenAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
	//		This will try to position node such that node's top-left corner is at the same position
	//		as the bottom left corner of the aroundNode (ie, put node below
	//		aroundNode, with left edges aligned).  If that fails it will try to put
	// 		the bottom-right corner of node where the top right corner of aroundNode is
	//		(ie, put node above aroundNode, with right edges aligned)
	//

	// get coordinates of aroundNode
	aroundNode = dojo.byId(aroundNode);
	var oldDisplay = aroundNode.style.display;
	aroundNode.style.display="";
	// #3172: use the slightly tighter border box instead of marginBox
	var aroundNodePos = dojo.position(aroundNode, true);
	aroundNode.style.display=oldDisplay;

	// place the node around the calculated rectangle
	return dijit._placeOnScreenAroundRect(node,
		aroundNodePos.x, aroundNodePos.y, aroundNodePos.w, aroundNodePos.h,	// rectangle
		aroundCorners, layoutNode);
};

/*=====
dijit.__Rectangle = function(){
	// x: Integer
	//		horizontal offset in pixels, relative to document body
	// y: Integer
	//		vertical offset in pixels, relative to document body
	// width: Integer
	//		width in pixels
	// height: Integer
	//		height in pixels

	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
}
=====*/


dijit.placeOnScreenAroundRectangle = function(
	/* DomNode */			node,
	/* dijit.__Rectangle */	aroundRect,
	/* Object */			aroundCorners,
	/* Function */			layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except that the "around"
	//		parameter is an arbitrary rectangle on the screen (x, y, width, height)
	//		instead of a dom node.

	return dijit._placeOnScreenAroundRect(node,
		aroundRect.x, aroundRect.y, aroundRect.width, aroundRect.height,	// rectangle
		aroundCorners, layoutNode);
};

dijit._placeOnScreenAroundRect = function(
	/* DomNode */		node,
	/* Number */		x,
	/* Number */		y,
	/* Number */		width,
	/* Number */		height,
	/* Object */		aroundCorners,
	/* Function */		layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except it accepts coordinates
	//		of a rectangle to place node adjacent to.

	// TODO: combine with placeOnScreenAroundRectangle()

	// Generate list of possible positions for node
	var choices = [];
	for(var nodeCorner in aroundCorners){
		choices.push( {
			aroundCorner: nodeCorner,
			corner: aroundCorners[nodeCorner],
			pos: {
				x: x + (nodeCorner.charAt(1) == 'L' ? 0 : width),
				y: y + (nodeCorner.charAt(0) == 'T' ? 0 : height)
			}
		});
	}

	return dijit._place(node, choices, layoutNode);
};

dijit.placementRegistry= new dojo.AdapterRegistry();
dijit.placementRegistry.register("node",
	function(n, x){
		return typeof x == "object" &&
			typeof x.offsetWidth != "undefined" && typeof x.offsetHeight != "undefined";
	},
	dijit.placeOnScreenAroundNode);
dijit.placementRegistry.register("rect",
	function(n, x){
		return typeof x == "object" &&
			"x" in x && "y" in x && "width" in x && "height" in x;
	},
	dijit.placeOnScreenAroundRectangle);

dijit.placeOnScreenAroundElement = function(
	/* DomNode */		node,
	/* Object */		aroundElement,
	/* Object */		aroundCorners,
	/* Function */		layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except it accepts an arbitrary object
	//		for the "around" argument and finds a proper processor to place a node.

	return dijit.placementRegistry.match.apply(dijit.placementRegistry, arguments);
};

dijit.getPopupAlignment = function(/*Array*/ position, /*Boolean*/ leftToRight){
	// summary:
	//		Transforms the passed array of preferred positions into a format suitable for passing as the aroundCorners argument to dijit.placeOnScreenAroundElement.
	//
	// position: String[]
	//		This variable controls the position of the drop down.
	//		It's an array of strings with the following values:
	//
	//			* before: places drop down to the left of the target node/widget, or to the right in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* after: places drop down to the right of the target node/widget, or to the left in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* above: drop down goes above target node
	//			* below: drop down goes below target node
	//
	//		The list is positions is tried, in order, until a position is found where the drop down fits
	//		within the viewport.
	//
	// leftToRight: Boolean
	//		Whether the popup will be displaying in leftToRight mode.
	//
	var align = {};
	dojo.forEach(position, function(pos){
		switch(pos){
			case "after":
				align[leftToRight ? "BR" : "BL"] = leftToRight ? "BL" : "BR";
				break;
			case "before":
				align[leftToRight ? "BL" : "BR"] = leftToRight ? "BR" : "BL";
				break;
			case "below":
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[leftToRight ? "BL" : "BR"] = leftToRight ? "TL" : "TR";
				align[leftToRight ? "BR" : "BL"] = leftToRight ? "TR" : "TL";
				break;
			case "above":
			default:
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[leftToRight ? "TL" : "TR"] = leftToRight ? "BL" : "BR";
				align[leftToRight ? "TR" : "TL"] = leftToRight ? "BR" : "BL";
				break;
		}
	});
	return align;
};
dijit.getPopupAroundAlignment = function(/*Array*/ position, /*Boolean*/ leftToRight){
	// summary:
	//		Transforms the passed array of preferred positions into a format suitable for passing as the aroundCorners argument to dijit.placeOnScreenAroundElement.
	//
	// position: String[]
	//		This variable controls the position of the drop down.
	//		It's an array of strings with the following values:
	//
	//			* before: places drop down to the left of the target node/widget, or to the right in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* after: places drop down to the right of the target node/widget, or to the left in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* above: drop down goes above target node
	//			* below: drop down goes below target node
	//
	//		The list is positions is tried, in order, until a position is found where the drop down fits
	//		within the viewport.
	//
	// leftToRight: Boolean
	//		Whether the popup will be displaying in leftToRight mode.
	//
	var align = {};
	dojo.forEach(position, function(pos){
		switch(pos){
			case "after":
				align[leftToRight ? "BR" : "BL"] = leftToRight ? "BL" : "BR";
				break;
			case "before":
				align[leftToRight ? "BL" : "BR"] = leftToRight ? "BR" : "BL";
				break;
			case "below":
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[leftToRight ? "BL" : "BR"] = leftToRight ? "TL" : "TR";
				align[leftToRight ? "BR" : "BL"] = leftToRight ? "TR" : "TL";
				break;
			case "above":
			default:
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[leftToRight ? "TL" : "TR"] = leftToRight ? "BL" : "BR";
				align[leftToRight ? "TR" : "TL"] = leftToRight ? "BR" : "BL";
				break;
		}
	});
	return align;
};

}

if(!dojo._hasResource["dijit._base.window"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.window"] = true;
dojo.provide("dijit._base.window");

// TODO: remove this in 2.0, it's not used anymore, or at least not internally

dijit.getDocumentWindow = function(doc){
	// summary:
	// 		Get window object associated with document doc

	// In some IE versions (at least 6.0), document.parentWindow does not return a
	// reference to the real window object (maybe a copy), so we must fix it as well
	// We use IE specific execScript to attach the real window reference to
	// document._parentWindow for later use
	if(dojo.isIE && window !== document.parentWindow && !doc._parentWindow){
		/*
		In IE 6, only the variable "window" can be used to connect events (others
		may be only copies).
		*/
		doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
		//to prevent memory leak, unset it after use
		//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
		var win = doc._parentWindow;
		doc._parentWindow = null;
		return win;	//	Window
	}

	return doc._parentWindow || doc.parentWindow || doc.defaultView;	//	Window
}

}

if(!dojo._hasResource["dijit._base.popup"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.popup"] = true;
dojo.provide("dijit._base.popup");





dijit.popup = new function(){
	// summary:
	//		This class is used to show/hide widgets as popups.

	var stack = [],
		beginZIndex=1000,
		idGen = 1;

	this.moveOffScreen = function(/*DomNode*/ node){
		// summary:
		//		Moves node offscreen without hiding it (so that all layout widgets included 
		//		in this node can still layout properly)
		//
		// description:
		//		Attaches node to dojo.doc.body, and
		//		positions it off screen, but not display:none, so that
		//		the widget doesn't appear in the page flow and/or cause a blank
		//		area at the bottom of the viewport (making scrollbar longer), but
		//		initialization of contained widgets works correctly

		var s = node.style;
		s.visibility = "hidden";	// so TAB key doesn't navigate to hidden popup
		s.position = "absolute";
		s.top = "-9999px";
		if(s.display == "none"){
			s.display="";
		}
		dojo.body().appendChild(node);
	};

/*=====
dijit.popup.__OpenArgs = function(){
	// popup: Widget
	//		widget to display
	// parent: Widget
	//		the button etc. that is displaying this popup
	// around: DomNode
	//		DOM node (typically a button); place popup relative to this node.  (Specify this *or* "x" and "y" parameters.)
	// x: Integer
	//		Absolute horizontal position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
	// y: Integer
	//		Absolute vertical position (in pixels) to place node at.  (Specity this *or* "around" parameter.)
	// orient: Object || String
	//		When the around parameter is specified, orient should be an
	//		ordered list of tuples of the form (around-node-corner, popup-node-corner).
	//		dijit.popup.open() tries to position the popup according to each tuple in the list, in order,
	//		until the popup appears fully within the viewport.
	//
	//		The default value is {BL:'TL', TL:'BL'}, which represents a list of two tuples:
	//			1. (BL, TL)
	//			2. (TL, BL)
	//		where BL means "bottom left" and "TL" means "top left".
	//		So by default, it first tries putting the popup below the around node, left-aligning them,
	//		and then tries to put it above the around node, still left-aligning them.   Note that the
	//		default is horizontally reversed when in RTL mode.
	//
	//		When an (x,y) position is specified rather than an around node, orient is either
	//		"R" or "L".  R (for right) means that it tries to put the popup to the right of the mouse,
	//		specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
	//		fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
	//		and the top-right corner.
	// onCancel: Function
	//		callback when user has canceled the popup by
	//			1. hitting ESC or
	//			2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
	//			   i.e. whenever popupWidget.onCancel() is called, args.onCancel is called
	// onClose: Function
	//		callback whenever this popup is closed
	// onExecute: Function
	//		callback when user "executed" on the popup/sub-popup by selecting a menu choice, etc. (top menu only)
	// padding: dijit.__Position
	//		adding a buffer around the opening position. This is only useful when around is not set.
	this.popup = popup;
	this.parent = parent;
	this.around = around;
	this.x = x;
	this.y = y;
	this.orient = orient;
	this.onCancel = onCancel;
	this.onClose = onClose;
	this.onExecute = onExecute;
	this.padding = padding;
}
=====*/

	// Compute the closest ancestor popup that's *not* a child of another popup.
	// Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
	var getTopPopup = function(){
		for(var pi=stack.length-1; pi > 0 && stack[pi].parent === stack[pi-1].widget; pi--){
			/* do nothing, just trying to get right value for pi */
		}
		return stack[pi];
	};

	var wrappers=[];
	this.open = function(/*dijit.popup.__OpenArgs*/ args){
		// summary:
		//		Popup the widget at the specified position
		//
		// example:
		//		opening at the mouse position
		//		|		dijit.popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
		//
		// example:
		//		opening the widget as a dropdown
		//		|		dijit.popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
		//
		//		Note that whatever widget called dijit.popup.open() should also listen to its own _onBlur callback
		//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.

		var widget = args.popup,
			orient = args.orient || (
				dojo._isBodyLtr() ?
				{'BL':'TL', 'BR':'TR', 'TL':'BL', 'TR':'BR'} :
				{'BR':'TR', 'BL':'TL', 'TR':'BR', 'TL':'BL'}
			),
			around = args.around,
			id = (args.around && args.around.id) ? (args.around.id+"_dropdown") : ("popup_"+idGen++);

		// make wrapper div to hold widget and possibly hold iframe behind it.
		// we can't attach the iframe as a child of the widget.domNode because
		// widget.domNode might be a <table>, <ul>, etc.

		var wrapperobj = wrappers.pop(), wrapper, iframe;
		if(!wrapperobj){
			wrapper = dojo.create("div",{
				"class":"dijitPopup"
			}, dojo.body());
			dijit.setWaiRole(wrapper, "presentation");
		}else{
			// recycled a old wrapper, so that we don't need to reattach the iframe
			// which is slow even if the iframe is empty, see #10167
			wrapper = wrapperobj[0];
			iframe = wrapperobj[1];
		}

		dojo.attr(wrapper,{
			id: id,
			style:{
				zIndex: beginZIndex + stack.length,
				visibility:"hidden",
				// prevent transient scrollbar causing misalign (#5776), and initial flash in upper left (#10111)
				top: "-9999px"
			},
			dijitPopupParent: args.parent ? args.parent.id : ""
		});

		var s = widget.domNode.style;
		s.display = "";
		s.visibility = "";
		s.position = "";
		s.top = "0px";
		wrapper.appendChild(widget.domNode);

		if(!iframe){
			iframe = new dijit.BackgroundIframe(wrapper);
		}else{
			iframe.resize(wrapper)
		}

		// position the wrapper node
		var best = around ?
			dijit.placeOnScreenAroundElement(wrapper, around, orient, widget.orient ? dojo.hitch(widget, "orient") : null) :
			dijit.placeOnScreen(wrapper, args, orient == 'R' ? ['TR','BR','TL','BL'] : ['TL','BL','TR','BR'], args.padding);

		wrapper.style.visibility = "visible";
		// TODO: use effects to fade in wrapper

		var handlers = [];

		// provide default escape and tab key handling
		// (this will work for any widget, not just menu)
		handlers.push(dojo.connect(wrapper, "onkeypress", this, function(evt){
			if(evt.charOrCode == dojo.keys.ESCAPE && args.onCancel){
				dojo.stopEvent(evt);
				args.onCancel();
			}else if(evt.charOrCode === dojo.keys.TAB){
				dojo.stopEvent(evt);
				var topPopup = getTopPopup();
				if(topPopup && topPopup.onCancel){
					topPopup.onCancel();
				}
			}
		}));

		// watch for cancel/execute events on the popup and notify the caller
		// (for a menu, "execute" means clicking an item)
		if(widget.onCancel){
			handlers.push(dojo.connect(widget, "onCancel", args.onCancel));
		}

		handlers.push(dojo.connect(widget, widget.onExecute ? "onExecute" : "onChange", function(){
			var topPopup = getTopPopup();
			if(topPopup && topPopup.onExecute){
				topPopup.onExecute();
			}
		}));

		stack.push({
			wrapper: wrapper,
			iframe: iframe,
			widget: widget,
			parent: args.parent,
			onExecute: args.onExecute,
			onCancel: args.onCancel,
 			onClose: args.onClose,
			handlers: handlers
		});

		if(widget.onOpen){
			// TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
			widget.onOpen(best);
		}

		return best;
	};

	this.close = function(/*dijit._Widget*/ popup){
		// summary:
		//		Close specified popup and any popups that it parented
		
		// Basically work backwards from the top of the stack closing popups
		// until we hit the specified popup, but IIRC there was some issue where closing
		// a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
		// closing C might close B indirectly and then the while() condition will run where stack==[A]...
		// so the while condition is constructed defensively.
		while(dojo.some(stack, function(elem){return elem.widget == popup;})){
			var top = stack.pop(),
				wrapper = top.wrapper,
				iframe = top.iframe,
				widget = top.widget,
				onClose = top.onClose;

			if(widget.onClose){
				// TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here)
				widget.onClose();
			}
			dojo.forEach(top.handlers, dojo.disconnect);

			// Move the widget offscreen, unless it has already been destroyed in above onClose() etc.
			if(widget && widget.domNode){
				this.moveOffScreen(widget.domNode);
			}
                        
			// recycle the wrapper plus iframe, so we prevent reattaching iframe everytime an popup opens
			// don't use moveOffScreen which would also reattach the wrapper to body, which causes reloading of iframe
			wrapper.style.top = "-9999px";
			wrapper.style.visibility = "hidden";
			wrappers.push([wrapper,iframe]);

			if(onClose){
				onClose();
			}
		}
	};
}();

dijit._frames = new function(){
	// summary:
	//		cache of iframes
	var queue = [];

	this.pop = function(){
		var iframe;
		if(queue.length){
			iframe = queue.pop();
			iframe.style.display="";
		}else{
			if(dojo.isIE){
				var burl = dojo.config["dojoBlankHtmlUrl"] || (dojo.moduleUrl("dojo", "resources/blank.html")+"") || "javascript:\"\"";
				var html="<iframe src='" + burl + "'"
					+ " style='position: absolute; left: 0px; top: 0px;"
					+ "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
				iframe = dojo.doc.createElement(html);
			}else{
			 	iframe = dojo.create("iframe");
				iframe.src = 'javascript:""';
				iframe.className = "dijitBackgroundIframe";
				dojo.style(iframe, "opacity", 0.1);
			}
			iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didnt work.
		}
		return iframe;
	};

	this.push = function(iframe){
		iframe.style.display="none";
		queue.push(iframe);
	}
}();


dijit.BackgroundIframe = function(/* DomNode */node){
	// summary:
	//		For IE/FF z-index schenanigans. id attribute is required.
	//
	// description:
	//		new dijit.BackgroundIframe(node)
	//			Makes a background iframe as a child of node, that fills
	//			area (and position) of node

	if(!node.id){ throw new Error("no id"); }
	if(dojo.isIE || dojo.isMoz){
		var iframe = dijit._frames.pop();
		node.appendChild(iframe);
		if(dojo.isIE<7){
			this.resize(node);
			this._conn = dojo.connect(node, 'onresize', this, function(){
				this.resize(node);
			});
		}else{
			dojo.style(iframe, {
				width: '100%',
				height: '100%'
			});
		}
		this.iframe = iframe;
	}
};

dojo.extend(dijit.BackgroundIframe, {
	resize: function(node){
		// summary:
		// 		resize the iframe so its the same size as node
		// description:
		//		this function is a no-op in all browsers except
		//		IE6, which does not support 100% width/height 
		//		of absolute positioned iframes
		if(this.iframe && dojo.isIE<7){
			dojo.style(this.iframe, {
				width: node.offsetWidth + 'px',
				height: node.offsetHeight + 'px'
			});
		}
	},
	destroy: function(){
		// summary:
		//		destroy the iframe
		if(this._conn){
			dojo.disconnect(this._conn);
			this._conn = null;
		}
		if(this.iframe){
			dijit._frames.push(this.iframe);
			delete this.iframe;
		}
	}
});

}

if(!dojo._hasResource["dijit._base.scroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.scroll"] = true;
dojo.provide("dijit._base.scroll");

dijit.scrollIntoView = function(/*DomNode*/ node, /*Object?*/ pos){
	// summary:
	//		Scroll the passed node into view, if it is not already.
	
	// don't rely on that node.scrollIntoView works just because the function is there

	try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
	node = dojo.byId(node);
	var doc = node.ownerDocument || dojo.doc,
		body = doc.body || dojo.body(),
		html = doc.documentElement || body.parentNode,
		isIE = dojo.isIE, isWK = dojo.isWebKit;
	// if an untested browser, then use the native method
	if((!(dojo.isMoz || isIE || isWK) || node == body || node == html) && (typeof node.scrollIntoView != "undefined")){
		node.scrollIntoView(false); // short-circuit to native if possible
		return;
	}
	var backCompat = doc.compatMode == 'BackCompat',
		clientAreaRoot = backCompat? body : html,
		scrollRoot = isWK ? body : clientAreaRoot,
		rootWidth = clientAreaRoot.clientWidth,
		rootHeight = clientAreaRoot.clientHeight,
		rtl = !dojo._isBodyLtr(),
		nodePos = pos || dojo.position(node),
		el = node.parentNode,
		isFixed = function(el){
			return ((isIE <= 6 || (isIE && backCompat))? false : (dojo.style(el, 'position').toLowerCase() == "fixed"));
		};
	if(isFixed(node)){ return; } // nothing to do
	while(el){
		if(el == body){ el = scrollRoot; }
		var elPos = dojo.position(el),
			fixedPos = isFixed(el);
		with(elPos){
			if(el == scrollRoot){
				w = rootWidth, h = rootHeight;
				if(scrollRoot == html && isIE && rtl){ x += scrollRoot.offsetWidth-w; } // IE workaround where scrollbar causes negative x
				if(x < 0 || !isIE){ x = 0; } // IE can have values > 0
				if(y < 0 || !isIE){ y = 0; }
			}else{
				var pb = dojo._getPadBorderExtents(el);
				w -= pb.w; h -= pb.h; x += pb.l; y += pb.t;
			}
			with(el){
				if(el != scrollRoot){ // body, html sizes already have the scrollbar removed
					var clientSize = clientWidth,
						scrollBarSize = w - clientSize;
					if(clientSize > 0 && scrollBarSize > 0){
						w = clientSize;
						if(isIE && rtl){ x += scrollBarSize; }
					}
					clientSize = clientHeight;
					scrollBarSize = h - clientSize;
					if(clientSize > 0 && scrollBarSize > 0){
						h = clientSize;
					}
				}
				if(fixedPos){ // bounded by viewport, not parents
					if(y < 0){
						h += y, y = 0;
					}
					if(x < 0){
						w += x, x = 0;
					}
					if(y + h > rootHeight){
						h = rootHeight - y;
					}
					if(x + w > rootWidth){
						w = rootWidth - x;
					}
				}
				// calculate overflow in all 4 directions
				var l = nodePos.x - x, // beyond left: < 0
					t = nodePos.y - Math.max(y, 0), // beyond top: < 0
					r = l + nodePos.w - w, // beyond right: > 0
					bot = t + nodePos.h - h; // beyond bottom: > 0
				if(r * l > 0){
					var s = Math[l < 0? "max" : "min"](l, r);
					nodePos.x += scrollLeft;
					scrollLeft += (isIE >= 8 && !backCompat && rtl)? -s : s;
					nodePos.x -= scrollLeft;
				}
				if(bot * t > 0){
					nodePos.y += scrollTop;
					scrollTop += Math[t < 0? "max" : "min"](t, bot);
					nodePos.y -= scrollTop;
				}
			}
		}
		el = (el != scrollRoot) && !fixedPos && el.parentNode;
	}
	}catch(error){
		console.error('scrollIntoView: ' + error);
		node.scrollIntoView(false);
	}
};

}

if(!dojo._hasResource["dijit._base.sniff"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.sniff"] = true;
// summary:
//		Applies pre-set CSS classes to the top-level HTML node, based on:
// 			- browser (ex: dj_ie)
//			- browser version (ex: dj_ie6)
//			- box model (ex: dj_contentBox)
//			- text direction (ex: dijitRtl)
//
//		In addition, browser, browser version, and box model are
//		combined with an RTL flag when browser text is RTL.  ex: dj_ie-rtl.
//
//		Simply doing a require on this module will
//		establish this CSS.  Modified version of Morris' CSS hack.

dojo.provide("dijit._base.sniff");

(function(){

	var d = dojo,
		html = d.doc.documentElement,
		ie = d.isIE,
		opera = d.isOpera,
		maj = Math.floor,
		ff = d.isFF,
		boxModel = d.boxModel.replace(/-/,''),

		classes = {
			dj_ie: ie,
			dj_ie6: maj(ie) == 6,
			dj_ie7: maj(ie) == 7,
			dj_ie8: maj(ie) == 8,
			dj_iequirks: ie && d.isQuirks,

			// NOTE: Opera not supported by dijit
			dj_opera: opera,

			dj_khtml: d.isKhtml,

			dj_webkit: d.isWebKit,
			dj_safari: d.isSafari,
			dj_chrome: d.isChrome,

			dj_gecko: d.isMozilla,
			dj_ff3: maj(ff) == 3
		}; // no dojo unsupported browsers

	classes["dj_" + boxModel] = true;

	// apply browser, browser version, and box model class names
	for(var p in classes){
		if(classes[p]){
			if(html.className){
				html.className += " " + p;
			}else{
				html.className = p;
			}
		}
	}

	// If RTL mode then add dijitRtl flag plus repeat existing classes
	// with -rtl extension
	// (unshift is to make this code run after <body> node is loaded but before parser runs)
	dojo._loaders.unshift(function(){
		if(!dojo._isBodyLtr()){
			html.className += " dijitRtl";
			for(var p in classes){
				if(classes[p]){
					html.className += " " + p + "-rtl";
				}
			}
		}
	});

})();

}

if(!dojo._hasResource["dijit._base.typematic"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.typematic"] = true;
dojo.provide("dijit._base.typematic");

dijit.typematic = {
	// summary:
	//		These functions are used to repetitively call a user specified callback
	//		method when a specific key or mouse click over a specific DOM node is
	//		held down for a specific amount of time.
	//		Only 1 such event is allowed to occur on the browser page at 1 time.

	_fireEventAndReload: function(){
		this._timer = null;
		this._callback(++this._count, this._node, this._evt);
		
		// Schedule next event, reducing the timer a little bit each iteration, bottoming-out at 10 to avoid
		// browser overload (particularly avoiding starving DOH robot so it never gets to send a mouseup)
		this._currentTimeout = Math.max(
			this._currentTimeout < 0 ? this._initialDelay :
				(this._subsequentDelay > 1 ? this._subsequentDelay : Math.round(this._currentTimeout * this._subsequentDelay)),
			10);
		this._timer = setTimeout(dojo.hitch(this, "_fireEventAndReload"), this._currentTimeout);
	},

	trigger: function(/*Event*/ evt, /* Object */ _this, /*DOMNode*/ node, /* Function */ callback, /* Object */ obj, /* Number */ subsequentDelay, /* Number */ initialDelay){
		// summary:
		//		Start a timed, repeating callback sequence.
		//		If already started, the function call is ignored.
		//		This method is not normally called by the user but can be
		//		when the normal listener code is insufficient.
		// evt:
		//		key or mouse event object to pass to the user callback
		// _this:
		//		pointer to the user's widget space.
		// node:
		//		the DOM node object to pass the the callback function
		// callback:
		//		function to call until the sequence is stopped called with 3 parameters:
		// count:
		//		integer representing number of repeated calls (0..n) with -1 indicating the iteration has stopped
		// node:
		//		the DOM node object passed in
		// evt:
		//		key or mouse event object
		// obj:
		//		user space object used to uniquely identify each typematic sequence
		// subsequentDelay:
		//		if > 1, the number of milliseconds until the 3->n events occur
		//		or else the fractional time multiplier for the next event's delay, default=0.9
		// initialDelay:
		//		the number of milliseconds until the 2nd event occurs, default=500ms
		if(obj != this._obj){
			this.stop();
			this._initialDelay = initialDelay || 500;
			this._subsequentDelay = subsequentDelay || 0.90;
			this._obj = obj;
			this._evt = evt;
			this._node = node;
			this._currentTimeout = -1;
			this._count = -1;
			this._callback = dojo.hitch(_this, callback);
			this._fireEventAndReload();
		}
	},

	stop: function(){
		// summary:
		//		Stop an ongoing timed, repeating callback sequence.
		if(this._timer){
			clearTimeout(this._timer);
			this._timer = null;
		}
		if(this._obj){
			this._callback(-1, this._node, this._evt);
			this._obj = null;
		}
	},

	addKeyListener: function(/*DOMNode*/ node, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay){
		// summary:
		//		Start listening for a specific typematic key.
		//		See also the trigger method for other parameters.
		// keyObject:
		//		an object defining the key to listen for.
		// charOrCode:
		//		the printable character (string) or keyCode (number) to listen for.
		// keyCode:
		//		(deprecated - use charOrCode) the keyCode (number) to listen for (implies charCode = 0).
		// charCode:
		//		(deprecated - use charOrCode) the charCode (number) to listen for.
		// ctrlKey:
		//		desired ctrl key state to initiate the calback sequence:
		//			- pressed (true)
		//			- released (false)
		//			- either (unspecified)
		// altKey:
		//		same as ctrlKey but for the alt key
		// shiftKey:
		//		same as ctrlKey but for the shift key
		// returns:
		//		an array of dojo.connect handles
		if(keyObject.keyCode){
			keyObject.charOrCode = keyObject.keyCode;
			dojo.deprecated("keyCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.", "", "2.0");
		}else if(keyObject.charCode){
			keyObject.charOrCode = String.fromCharCode(keyObject.charCode);
			dojo.deprecated("charCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.", "", "2.0");
		}
		return [
			dojo.connect(node, "onkeypress", this, function(evt){
				if(evt.charOrCode == keyObject.charOrCode &&
				(keyObject.ctrlKey === undefined || keyObject.ctrlKey == evt.ctrlKey) &&
				(keyObject.altKey === undefined || keyObject.altKey == evt.altKey) &&
				(keyObject.metaKey === undefined || keyObject.metaKey == (evt.metaKey || false)) && // IE doesn't even set metaKey
				(keyObject.shiftKey === undefined || keyObject.shiftKey == evt.shiftKey)){
					dojo.stopEvent(evt);
					dijit.typematic.trigger(keyObject, _this, node, callback, keyObject, subsequentDelay, initialDelay);
				}else if(dijit.typematic._obj == keyObject){
					dijit.typematic.stop();
				}
			}),
			dojo.connect(node, "onkeyup", this, function(evt){
				if(dijit.typematic._obj == keyObject){
					dijit.typematic.stop();
				}
			})
		];
	},

	addMouseListener: function(/*DOMNode*/ node, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay){
		// summary:
		//		Start listening for a typematic mouse click.
		//		See the trigger method for other parameters.
		// returns:
		//		an array of dojo.connect handles
		var dc = dojo.connect;
		return [
			dc(node, "mousedown", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay);
			}),
			dc(node, "mouseup", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.stop();
			}),
			dc(node, "mouseout", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.stop();
			}),
			dc(node, "mousemove", this, function(evt){
				dojo.stopEvent(evt);
			}),
			dc(node, "dblclick", this, function(evt){
				dojo.stopEvent(evt);
				if(dojo.isIE){
					dijit.typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay);
					setTimeout(dojo.hitch(this, dijit.typematic.stop), 50);
				}
			})
		];
	},

	addListener: function(/*Node*/ mouseNode, /*Node*/ keyNode, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay){
		// summary:
		//		Start listening for a specific typematic key and mouseclick.
		//		This is a thin wrapper to addKeyListener and addMouseListener.
		//		See the addMouseListener and addKeyListener methods for other parameters.
		// mouseNode:
		//		the DOM node object to listen on for mouse events.
		// keyNode:
		//		the DOM node object to listen on for key events.
		// returns:
		//		an array of dojo.connect handles
		return this.addKeyListener(keyNode, keyObject, _this, callback, subsequentDelay, initialDelay).concat(
			this.addMouseListener(mouseNode, _this, callback, subsequentDelay, initialDelay));
	}
};

}

if(!dojo._hasResource["dijit._base.wai"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.wai"] = true;
dojo.provide("dijit._base.wai");

dijit.wai = {
	onload: function(){
		// summary:
		//		Detects if we are in high-contrast mode or not

		// This must be a named function and not an anonymous
		// function, so that the widget parsing code can make sure it
		// registers its onload function after this function.
		// DO NOT USE "this" within this function.

		// create div for testing if high contrast mode is on or images are turned off
		var div = dojo.create("div",{
			id: "a11yTestNode",
			style:{
				cssText:'border: 1px solid;'
					+ 'border-color:red green;'
					+ 'position: absolute;'
					+ 'height: 5px;'
					+ 'top: -999px;'
					+ 'background-image: url("' + (dojo.config.blankGif || dojo.moduleUrl("dojo", "resources/blank.gif")) + '");'
			}
		}, dojo.body());

		// test it
		var cs = dojo.getComputedStyle(div);
		if(cs){
			var bkImg = cs.backgroundImage;
			var needsA11y = (cs.borderTopColor == cs.borderRightColor) || (bkImg != null && (bkImg == "none" || bkImg == "url(invalid-url:)" ));
			dojo[needsA11y ? "addClass" : "removeClass"](dojo.body(), "dijit_a11y");
			if(dojo.isIE){
				div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
			}else{
				dojo.body().removeChild(div);
			}
		}
	}
};

// Test if computer is in high contrast mode.
// Make sure the a11y test runs first, before widgets are instantiated.
if(dojo.isIE || dojo.isMoz){	// NOTE: checking in Safari messes things up
	dojo._loaders.unshift(dijit.wai.onload);
}

dojo.mixin(dijit, {
	_XhtmlRoles: /banner|contentinfo|definition|main|navigation|search|note|secondary|seealso/,

	hasWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Determines if an element has a particular non-XHTML role.
		// returns:
		//		True if elem has the specific non-XHTML role attribute and false if not.
		// 		For backwards compatibility if role parameter not provided,
		// 		returns true if has non XHTML role
		var waiRole = this.getWaiRole(elem);
		return role ? (waiRole.indexOf(role) > -1) : (waiRole.length > 0);
	},

	getWaiRole: function(/*Element*/ elem){
		// summary:
		//		Gets the non-XHTML role for an element (which should be a wai role).
		// returns:
		//		The non-XHTML role of elem or an empty string if elem
		//		does not have a role.
		 return dojo.trim((dojo.attr(elem, "role") || "").replace(this._XhtmlRoles,"").replace("wairole:",""));
	},

	setWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Sets the role on an element.
		// description:
		//		Replace existing role attribute with new role.
		//		If elem already has an XHTML role, append this role to XHTML role
		//		and remove other ARIA roles.

		var curRole = dojo.attr(elem, "role") || "";
		if(!this._XhtmlRoles.test(curRole)){
			dojo.attr(elem, "role", role);
		}else{
			if((" "+ curRole +" ").indexOf(" " + role + " ") < 0){
				var clearXhtml = dojo.trim(curRole.replace(this._XhtmlRoles, ""));
				var cleanRole = dojo.trim(curRole.replace(clearXhtml, ""));
				dojo.attr(elem, "role", cleanRole + (cleanRole ? ' ' : '') + role);
			}
		}
	},

	removeWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Removes the specified non-XHTML role from an element.
		// 		Removes role attribute if no specific role provided (for backwards compat.)

		var roleValue = dojo.attr(elem, "role");
		if(!roleValue){ return; }
		if(role){
			var t = dojo.trim((" " + roleValue + " ").replace(" " + role + " ", " "));
			dojo.attr(elem, "role", t);
		}else{
			elem.removeAttribute("role");
		}
	},

	hasWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Determines if an element has a given state.
		// description:
		//		Checks for an attribute called "aria-"+state.
		// returns:
		//		true if elem has a value for the given state and
		//		false if it does not.

		return elem.hasAttribute ? elem.hasAttribute("aria-"+state) : !!elem.getAttribute("aria-"+state);
	},

	getWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Gets the value of a state on an element.
		// description:
		//		Checks for an attribute called "aria-"+state.
		// returns:
		//		The value of the requested state on elem
		//		or an empty string if elem has no value for state.

		return elem.getAttribute("aria-"+state) || "";
	},

	setWaiState: function(/*Element*/ elem, /*String*/ state, /*String*/ value){
		// summary:
		//		Sets a state on an element.
		// description:
		//		Sets an attribute called "aria-"+state.

		elem.setAttribute("aria-"+state, value);
	},

	removeWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Removes a state from an element.
		// description:
		//		Sets an attribute called "aria-"+state.

		elem.removeAttribute("aria-"+state);
	}
});

}

if(!dojo._hasResource["dijit._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base"] = true;
dojo.provide("dijit._base");











}

if(!dojo._hasResource["dijit._Widget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Widget"] = true;
dojo.provide("dijit._Widget");

dojo.require( "dijit._base" );


// This code is to assist deferring dojo.connect() calls in widgets (connecting to events on the widgets'
// DOM nodes) until someone actually needs to monitor that event.
dojo.connect(dojo, "_connect",
	function(/*dijit._Widget*/ widget, /*String*/ event){
		if(widget && dojo.isFunction(widget._onConnect)){
			widget._onConnect(event);
		}
	});

dijit._connectOnUseEventHandler = function(/*Event*/ event){};

// Keep track of where the last keydown event was, to help avoid generating
// spurious ondijitclick events when:
// 1. focus is on a <button> or <a>
// 2. user presses then releases the ENTER key
// 3. onclick handler fires and shifts focus to another node, with an ondijitclick handler
// 4. onkeyup event fires, causing the ondijitclick handler to fire
dijit._lastKeyDownNode = null;
if(dojo.isIE){
	(function(){
		var keydownCallback = function(evt){
			dijit._lastKeyDownNode = evt.srcElement;
		};
		dojo.doc.attachEvent('onkeydown', keydownCallback);
		dojo.addOnWindowUnload(function(){
			dojo.doc.detachEvent('onkeydown', keydownCallback);
		});
	})();
}else{
	dojo.doc.addEventListener('keydown', function(evt){
		dijit._lastKeyDownNode = evt.target;
	}, true);
}

(function(){

var _attrReg = {},	// cached results from getSetterAttributes
	getSetterAttributes = function(widget){
		// summary:
		//		Returns list of attributes with custom setters for specified widget
		var dc = widget.declaredClass;
		if(!_attrReg[dc]){
			var r = [],
				attrs,
				proto = widget.constructor.prototype;
			for(var fxName in proto){
				if(dojo.isFunction(proto[fxName]) && (attrs = fxName.match(/^_set([a-zA-Z]*)Attr$/)) && attrs[1]){
					r.push(attrs[1].charAt(0).toLowerCase() + attrs[1].substr(1));
				}
			}
			_attrReg[dc] = r;
		}
		return _attrReg[dc] || [];	// String[]
	};

dojo.declare("dijit._Widget", null, {
	// summary:
	//		Base class for all Dijit widgets.

	// id: [const] String
	//		A unique, opaque ID string that can be assigned by users or by the
	//		system. If the developer passes an ID which is known not to be
	//		unique, the specified ID is ignored and the system-generated ID is
	//		used instead.
	id: "",

	// lang: [const] String
	//		Rarely used.  Overrides the default Dojo locale used to render this widget,
	//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
	//		Value must be among the list of locales specified during by the Dojo bootstrap,
	//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
	lang: "",

	// dir: [const] String
	//		Unsupported by Dijit, but here for completeness.  Dijit only supports setting text direction on the
	//		entire document.
	//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
	//		attribute. Either left-to-right "ltr" or right-to-left "rtl".
	dir: "",

	// class: String
	//		HTML class attribute
	"class": "",

	// style: String||Object
	//		HTML style attributes as cssText string or name/value hash
	style: "",

	// title: String
	//		HTML title attribute.
	//
	//		For form widgets this specifies a tooltip to display when hovering over
	//		the widget (just like the native HTML title attribute).
	//
	//		For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
	//		etc., it's used to specify the tab label, accordion pane title, etc.
	title: "",

	// tooltip: String
	//		When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
	//		this specifies the tooltip to appear when the mouse is hovered over that text.
	tooltip: "",

	// srcNodeRef: [readonly] DomNode
	//		pointer to original DOM node
	srcNodeRef: null,

	// domNode: [readonly] DomNode
	//		This is our visible representation of the widget! Other DOM
	//		Nodes may by assigned to other properties, usually through the
	//		template system's dojoAttachPoint syntax, but the domNode
	//		property is the canonical "top level" node in widget UI.
	domNode: null,

	// containerNode: [readonly] DomNode
	//		Designates where children of the source DOM node will be placed.
	//		"Children" in this case refers to both DOM nodes and widgets.
	//		For example, for myWidget:
	//
	//		|	<div dojoType=myWidget>
	//		|		<b> here's a plain DOM node
	//		|		<span dojoType=subWidget>and a widget</span>
	//		|		<i> and another plain DOM node </i>
	//		|	</div>
	//
	//		containerNode would point to:
	//
	//		|		<b> here's a plain DOM node
	//		|		<span dojoType=subWidget>and a widget</span>
	//		|		<i> and another plain DOM node </i>
	//
	//		In templated widgets, "containerNode" is set via a
	//		dojoAttachPoint assignment.
	//
	//		containerNode must be defined for any widget that accepts innerHTML
	//		(like ContentPane or BorderContainer or even Button), and conversely
	//		is null for widgets that don't, like TextBox.
	containerNode: null,

/*=====
	// _started: Boolean
	//		startup() has completed.
	_started: false,
=====*/

	// attributeMap: [protected] Object
	//		attributeMap sets up a "binding" between attributes (aka properties)
	//		of the widget and the widget's DOM.
	//		Changes to widget attributes listed in attributeMap will be
	//		reflected into the DOM.
	//
	//		For example, calling attr('title', 'hello')
	//		on a TitlePane will automatically cause the TitlePane's DOM to update
	//		with the new title.
	//
	//		attributeMap is a hash where the key is an attribute of the widget,
	//		and the value reflects a binding to a:
	//
	//		- DOM node attribute
	// |		focus: {node: "focusNode", type: "attribute"}
	// 		Maps this.focus to this.focusNode.focus
	//
	//		- DOM node innerHTML
	//	|		title: { node: "titleNode", type: "innerHTML" }
	//		Maps this.title to this.titleNode.innerHTML
	//
	//		- DOM node innerText
	//	|		title: { node: "titleNode", type: "innerText" }
	//		Maps this.title to this.titleNode.innerText
	//
	//		- DOM node CSS class
	// |		myClass: { node: "domNode", type: "class" }
	//		Maps this.myClass to this.domNode.className
	//
	//		If the value is an array, then each element in the array matches one of the
	//		formats of the above list.
	//
	//		There are also some shorthands for backwards compatibility:
	//		- string --> { node: string, type: "attribute" }, for example:
	//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
	//		- "" --> { node: "domNode", type: "attribute" }
	attributeMap: {id:"", dir:"", lang:"", "class":"", style:"", title:""},

	// _deferredConnects: [protected] Object
	//		attributeMap addendum for event handlers that should be connected only on first use
	_deferredConnects: {
		onClick: "",
		onDblClick: "",
		onKeyDown: "",
		onKeyPress: "",
		onKeyUp: "",
		onMouseMove: "",
		onMouseDown: "",
		onMouseOut: "",
		onMouseOver: "",
		onMouseLeave: "",
		onMouseEnter: "",
		onMouseUp: ""
	},

	onClick: dijit._connectOnUseEventHandler,
	/*=====
	onClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onDblClick: dijit._connectOnUseEventHandler,
	/*=====
	onDblClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse double click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onKeyDown: dijit._connectOnUseEventHandler,
	/*=====
	onKeyDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being pressed down.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyPress: dijit._connectOnUseEventHandler,
	/*=====
	onKeyPress: function(event){
		// summary:
		//		Connect to this function to receive notifications of printable keys being typed.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyUp: dijit._connectOnUseEventHandler,
	/*=====
	onKeyUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being released.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onMouseDown: dijit._connectOnUseEventHandler,
	/*=====
	onMouseDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is pressed down.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseMove: dijit._connectOnUseEventHandler,
	/*=====
	onMouseMove: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOut: dijit._connectOnUseEventHandler,
	/*=====
	onMouseOut: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOver: dijit._connectOnUseEventHandler,
	/*=====
	onMouseOver: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseLeave: dijit._connectOnUseEventHandler,
	/*=====
	onMouseLeave: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseEnter: dijit._connectOnUseEventHandler,
	/*=====
	onMouseEnter: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseUp: dijit._connectOnUseEventHandler,
	/*=====
	onMouseUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is released.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/

	// Constants used in templates

	// _blankGif: [protected] String
	//		Path to a blank 1x1 image.
	//		Used by <img> nodes in templates that really get their image via CSS background-image.
	_blankGif: (dojo.config.blankGif || dojo.moduleUrl("dojo", "resources/blank.gif")).toString(),

	//////////// INITIALIZATION METHODS ///////////////////////////////////////

	postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
		// summary:
		//		Kicks off widget instantiation.  See create() for details.
		// tags:
		//		private
		this.create(params, srcNodeRef);
	},

	create: function(/*Object?*/params, /*DomNode|String?*/srcNodeRef){
		// summary:
		//		Kick off the life-cycle of a widget
		// params:
		//		Hash of initialization parameters for widget, including
		//		scalar values (like title, duration etc.) and functions,
		//		typically callbacks like onClick.
		// srcNodeRef:
		//		If a srcNodeRef (DOM node) is specified:
		//			- use srcNodeRef.innerHTML as my contents
		//			- if this is a behavioral widget then apply behavior
		//			  to that srcNodeRef
		//			- otherwise, replace srcNodeRef with my generated DOM
		//			  tree
		// description:
		//		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
		//		etc.), some of which of you'll want to override. See http://docs.dojocampus.org/dijit/_Widget
		//		for a discussion of the widget creation lifecycle.
		//
		//		Of course, adventurous developers could override create entirely, but this should
		//		only be done as a last resort.
		// tags:
		//		private

		// store pointer to original DOM tree
		this.srcNodeRef = dojo.byId(srcNodeRef);

		// For garbage collection.  An array of handles returned by Widget.connect()
		// Each handle returned from Widget.connect() is an array of handles from dojo.connect()
		this._connects = [];

		// For garbage collection.  An array of handles returned by Widget.subscribe()
		// The handle returned from Widget.subscribe() is the handle returned from dojo.subscribe()
		this._subscribes = [];

		// To avoid double-connects, remove entries from _deferredConnects
		// that have been setup manually by a subclass (ex, by dojoAttachEvent).
		// If a subclass has redefined a callback (ex: onClick) then assume it's being
		// connected to manually.
		this._deferredConnects = dojo.clone(this._deferredConnects);
		for(var attr in this.attributeMap){
			delete this._deferredConnects[attr]; // can't be in both attributeMap and _deferredConnects
		}
		for(attr in this._deferredConnects){
			if(this[attr] !== dijit._connectOnUseEventHandler){
				delete this._deferredConnects[attr];	// redefined, probably dojoAttachEvent exists
			}
		}

		//mixin our passed parameters
		if(this.srcNodeRef && (typeof this.srcNodeRef.id == "string")){ this.id = this.srcNodeRef.id; }
		if(params){
			this.params = params;
			dojo.mixin(this,params);
		}
		this.postMixInProperties();

		// generate an id for the widget if one wasn't specified
		// (be sure to do this before buildRendering() because that function might
		// expect the id to be there.)
		if(!this.id){
			this.id = dijit.getUniqueId(this.declaredClass.replace(/\./g,"_"));
		}
		dijit.registry.add(this);

		this.buildRendering();

		if(this.domNode){
			// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
			this._applyAttributes();

			var source = this.srcNodeRef;
			if(source && source.parentNode){
				source.parentNode.replaceChild(this.domNode, source);
			}

			// If the developer has specified a handler as a widget parameter
			// (ex: new Button({onClick: ...})
			// then naturally need to connect from DOM node to that handler immediately,
			for(attr in this.params){
				this._onConnect(attr);
			}
		}

		if(this.domNode){
			this.domNode.setAttribute("widgetId", this.id);
		}
		this.postCreate();

		// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
		if(this.srcNodeRef && !this.srcNodeRef.parentNode){
			delete this.srcNodeRef;
		}

		this._created = true;
	},

	_applyAttributes: function(){
		// summary:
		//		Step during widget creation to copy all widget attributes to the
		//		DOM as per attributeMap and _setXXXAttr functions.
		// description:
		//		Skips over blank/false attribute values, unless they were explicitly specified
		//		as parameters to the widget, since those are the default anyway,
		//		and setting tabIndex="" is different than not setting tabIndex at all.
		//
		//		It processes the attributes in the attribute map first, and then
		//		it goes through and processes the attributes for the _setXXXAttr
		//		functions that have been specified
		// tags:
		//		private
		var condAttrApply = function(attr, scope){
			if((scope.params && attr in scope.params) || scope[attr]){
				scope.attr(attr, scope[attr]);
			}
		};

		// Do the attributes in attributeMap
		for(var attr in this.attributeMap){
			condAttrApply(attr, this);
		}

		// And also any attributes with custom setters
		dojo.forEach(getSetterAttributes(this), function(a){
			if(!(a in this.attributeMap)){
				condAttrApply(a, this);
			}
		}, this);
	},

	postMixInProperties: function(){
		// summary:
		//		Called after the parameters to the widget have been read-in,
		//		but before the widget template is instantiated. Especially
		//		useful to set properties that are referenced in the widget
		//		template.
		// tags:
		//		protected
	},

	buildRendering: function(){
		// summary:
		//		Construct the UI for this widget, setting this.domNode
		// description:
		//		Most widgets will mixin `dijit._Templated`, which implements this
		//		method.
		// tags:
		//		protected
		this.domNode = this.srcNodeRef || dojo.create('div');
	},

	postCreate: function(){
		// summary:
		//		Processing after the DOM fragment is created
		// description:
		//		Called after the DOM fragment has been created, but not necessarily
		//		added to the document.  Do not include any operations which rely on
		//		node dimensions or placement.
		// tags:
		//		protected
	},

	startup: function(){
		// summary:
		//		Processing after the DOM fragment is added to the document
		// description:
		//		Called after a widget and its children have been created and added to the page,
		//		and all related widgets have finished their create() cycle, up through postCreate().
		//		This is useful for composite widgets that need to control or layout sub-widgets.
		//		Many layout widgets can use this as a wiring phase.
		this._started = true;
	},

	//////////// DESTROY FUNCTIONS ////////////////////////////////

	destroyRecursive: function(/*Boolean?*/ preserveDom){
		// summary:
		// 		Destroy this widget and its descendants
		// description:
		//		This is the generic "destructor" function that all widget users
		// 		should call to cleanly discard with a widget. Once a widget is
		// 		destroyed, it is removed from the manager object.
		// preserveDom:
		//		If true, this method will leave the original DOM structure
		//		alone of descendant Widgets. Note: This will NOT work with
		//		dijit._Templated widgets.

		this._beingDestroyed = true;
		this.destroyDescendants(preserveDom);
		this.destroy(preserveDom);
	},

	destroy: function(/*Boolean*/ preserveDom){
		// summary:
		// 		Destroy this widget, but not its descendants.
		//		This method will, however, destroy internal widgets such as those used within a template.
		// preserveDom: Boolean
		//		If true, this method will leave the original DOM structure alone.
		//		Note: This will not yet work with _Templated widgets

		this._beingDestroyed = true;
		this.uninitialize();
		var d = dojo,
			dfe = d.forEach,
			dun = d.unsubscribe;
		dfe(this._connects, function(array){
			dfe(array, d.disconnect);
		});
		dfe(this._subscribes, function(handle){
			dun(handle);
		});

		// destroy widgets created as part of template, etc.
		dfe(this._supportingWidgets || [], function(w){
			if(w.destroyRecursive){
				w.destroyRecursive();
			}else if(w.destroy){
				w.destroy();
			}
		});

		this.destroyRendering(preserveDom);
		dijit.registry.remove(this.id);
		this._destroyed = true;
	},

	destroyRendering: function(/*Boolean?*/ preserveDom){
		// summary:
		//		Destroys the DOM nodes associated with this widget
		// preserveDom:
		//		If true, this method will leave the original DOM structure alone
		//		during tear-down. Note: this will not work with _Templated
		//		widgets yet.
		// tags:
		//		protected

		if(this.bgIframe){
			this.bgIframe.destroy(preserveDom);
			delete this.bgIframe;
		}

		if(this.domNode){
			if(preserveDom){
				dojo.removeAttr(this.domNode, "widgetId");
			}else{
				dojo.destroy(this.domNode);
			}
			delete this.domNode;
		}

		if(this.srcNodeRef){
			if(!preserveDom){
				dojo.destroy(this.srcNodeRef);
			}
			delete this.srcNodeRef;
		}
	},

	destroyDescendants: function(/*Boolean?*/ preserveDom){
		// summary:
		//		Recursively destroy the children of this widget and their
		//		descendants.
		// preserveDom:
		//		If true, the preserveDom attribute is passed to all descendant
		//		widget's .destroy() method. Not for use with _Templated
		//		widgets.

		// get all direct descendants and destroy them recursively
		dojo.forEach(this.getChildren(), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive(preserveDom);
			}
		});
	},


	uninitialize: function(){
		// summary:
		//		Stub function. Override to implement custom widget tear-down
		//		behavior.
		// tags:
		//		protected
		return false;
	},

	////////////////// MISCELLANEOUS METHODS ///////////////////

	onFocus: function(){
		// summary:
		//		Called when the widget becomes "active" because
		//		it or a widget inside of it either has focus, or has recently
		//		been clicked.
		// tags:
		//		callback
	},

	onBlur: function(){
		// summary:
		//		Called when the widget stops being "active" because
		//		focus moved to something outside of it, or the user
		//		clicked somewhere outside of it, or the widget was
		//		hidden.
		// tags:
		//		callback
	},

	_onFocus: function(e){
		// summary:
		//		This is where widgets do processing for when they are active,
		//		such as changing CSS classes.  See onFocus() for more details.
		// tags:
		//		protected
		this.onFocus();
	},

	_onBlur: function(){
		// summary:
		//		This is where widgets do processing for when they stop being active,
		//		such as changing CSS classes.  See onBlur() for more details.
		// tags:
		//		protected
		this.onBlur();
	},

	_onConnect: function(/*String*/ event){
		// summary:
		//		Called when someone connects to one of my handlers.
		//		"Turn on" that handler if it isn't active yet.
		//
		//		This is also called for every single initialization parameter
		//		so need to do nothing for parameters like "id".
		// tags:
		//		private
		if(event in this._deferredConnects){
			var mapNode = this[this._deferredConnects[event] || 'domNode'];
			this.connect(mapNode, event.toLowerCase(), event);
			delete this._deferredConnects[event];
		}
	},

	_setClassAttr: function(/*String*/ value){
		// summary:
		//		Custom setter for the CSS "class" attribute
		// tags:
		//		protected
		var mapNode = this[this.attributeMap["class"] || 'domNode'];
		dojo.removeClass(mapNode, this["class"])
		this["class"] = value;
		dojo.addClass(mapNode, value);
	},

	_setStyleAttr: function(/*String||Object*/ value){
		// summary:
		//		Sets the style attribut of the widget according to value,
		//		which is either a hash like {height: "5px", width: "3px"}
		//		or a plain string
		// description:
		//		Determines which node to set the style on based on style setting
		//		in attributeMap.
		// tags:
		//		protected

		var mapNode = this[this.attributeMap.style || 'domNode'];

		// Note: technically we should revert any style setting made in a previous call
		// to his method, but that's difficult to keep track of.

		if(dojo.isObject(value)){
			dojo.style(mapNode, value);
		}else{
			if(mapNode.style.cssText){
				mapNode.style.cssText += "; " + value;
			}else{
				mapNode.style.cssText = value;
			}
		}

		this.style = value;
	},

	setAttribute: function(/*String*/ attr, /*anything*/ value){
		// summary:
		//		Deprecated.  Use attr() instead.
		// tags:
		//		deprecated
		dojo.deprecated(this.declaredClass+"::setAttribute() is deprecated. Use attr() instead.", "", "2.0");
		this.attr(attr, value);
	},

	_attrToDom: function(/*String*/ attr, /*String*/ value){
		// summary:
		//		Reflect a widget attribute (title, tabIndex, duration etc.) to
		//		the widget DOM, as specified in attributeMap.
		//
		// description:
		//		Also sets this["attr"] to the new value.
		//		Note some attributes like "type"
		//		cannot be processed this way as they are not mutable.
		//
		// tags:
		//		private

		var commands = this.attributeMap[attr];
		dojo.forEach(dojo.isArray(commands) ? commands : [commands], function(command){

			// Get target node and what we are doing to that node
			var mapNode = this[command.node || command || "domNode"];	// DOM node
			var type = command.type || "attribute";	// class, innerHTML, innerText, or attribute

			switch(type){
				case "attribute":
					if(dojo.isFunction(value)){ // functions execute in the context of the widget
						value = dojo.hitch(this, value);
					}

					// Get the name of the DOM node attribute; usually it's the same
					// as the name of the attribute in the widget (attr), but can be overridden.
					// Also maps handler names to lowercase, like onSubmit --> onsubmit
					var attrName = command.attribute ? command.attribute :
						(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);

					dojo.attr(mapNode, attrName, value);
					break;
				case "innerText":
					mapNode.innerHTML = "";
					mapNode.appendChild(dojo.doc.createTextNode(value));
					break;
				case "innerHTML":
					mapNode.innerHTML = value;
					break;
				case "class":
					dojo.removeClass(mapNode, this[attr]);
					dojo.addClass(mapNode, value);
					break;
			}
		}, this);
		this[attr] = value;
	},

	attr: function(/*String|Object*/name, /*Object?*/value){
		// summary:
		//		Set or get properties on a widget instance.
		//	name:
		//		The property to get or set. If an object is passed here and not
		//		a string, its keys are used as names of attributes to be set
		//		and the value of the object as values to set in the widget.
		//	value:
		//		Optional. If provided, attr() operates as a setter. If omitted,
		//		the current value of the named property is returned.
		// description:
		//		Get or set named properties on a widget. If no value is
		//		provided, the current value of the attribute is returned,
		//		potentially via a getter method. If a value is provided, then
		//		the method acts as a setter, assigning the value to the name,
		//		potentially calling any explicitly provided setters to handle
		//		the operation. For instance, if the widget has properties "foo"
		//		and "bar" and a method named "_setFooAttr", calling:
		//	|	myWidget.attr("foo", "Howdy!");
		//		would be equivalent to calling:
		//	|	widget._setFooAttr("Howdy!");
		//		while calling:
		//	|	myWidget.attr("bar", "Howdy!");
		//		would be the same as writing:
		//	|	widget.bar = "Howdy!";
		//		It also tries to copy the changes to the widget's DOM according
		//		to settings in attributeMap (see description of `dijit._Widget.attributeMap`
		//		for details)
		//		For example, calling:
		//	|	myTitlePane.attr("title", "Howdy!");
		//		will do
		//	|	myTitlePane.title = "Howdy!";
		//	|	myTitlePane.title.innerHTML = "Howdy!";
		//		It works for DOM node attributes too.  Calling
		//	|	widget.attr("disabled", true)
		//		will set the disabled attribute on the widget's focusNode,
		//		among other housekeeping for a change in disabled state.

		//	open questions:
		//		- how to handle build shortcut for attributes which want to map
		//		into DOM attributes?
		//		- what relationship should setAttribute()/attr() have to
		//		layout() calls?
		var args = arguments.length;
		if(args == 1 && !dojo.isString(name)){
			for(var x in name){ this.attr(x, name[x]); }
			return this;
		}
		var names = this._getAttrNames(name);
		if(args >= 2){ // setter
			if(this[names.s]){
				// use the explicit setter
				args = dojo._toArray(arguments, 1);
				return this[names.s].apply(this, args) || this;
			}else{
				// if param is specified as DOM node attribute, copy it
				if(name in this.attributeMap){
					this._attrToDom(name, value);
				}

				// FIXME: what about function assignments? Any way to connect() here?
				this[name] = value;
			}
			return this;
		}else{ // getter
			return this[names.g] ? this[names.g]() : this[name];
		}
	},

	_attrPairNames: {},		// shared between all widgets
	_getAttrNames: function(name){
		// summary:
		//		Helper function for Widget.attr().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		var uc = name.charAt(0).toUpperCase() + name.substr(1);
		return (apn[name] = {
			n: name+"Node",
			s: "_set"+uc+"Attr",
			g: "_get"+uc+"Attr"
		});
	},

	toString: function(){
		// summary:
		//		Returns a string that represents the widget
		// description:
		//		When a widget is cast to a string, this method will be used to generate the
		//		output. Currently, it does not implement any sort of reversible
		//		serialization.
		return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
	},

	getDescendants: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		This method should generally be avoided as it returns widgets declared in templates, which are
		//		supposed to be internal/hidden, but it's left here for back-compat reasons.

		return this.containerNode ? dojo.query('[widgetId]', this.containerNode).map(dijit.byNode) : []; // dijit._Widget[]
	},

	getChildren: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		Does not return nested widgets, nor widgets that are part of this widget's template.
		return this.containerNode ? dijit.findWidgets(this.containerNode) : []; // dijit._Widget[]
	},

	// nodesWithKeyClick: [private] String[]
	//		List of nodes that correctly handle click events via native browser support,
	//		and don't need dijit's help
	nodesWithKeyClick: ["input", "button"],

	connect: function(
			/*Object|null*/ obj,
			/*String|Function*/ event,
			/*String|Function*/ method){
		// summary:
		//		Connects specified obj/event to specified method of this object
		//		and registers for disconnect() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.connect, except with the
		//		implicit use of this widget as the target object.
		//		This version of connect also provides a special "ondijitclick"
		//		event which triggers on a click or space or enter keyup
		// returns:
		//		A handle that can be passed to `disconnect` in order to disconnect before
		//		the widget is destroyed.
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when foo.bar() is called, call the listener we're going to
		//	|	// provide in the scope of btn
		//	|	btn.connect(foo, "bar", function(){
		//	|		console.debug(this.toString());
		//	|	});
		// tags:
		//		protected

		var d = dojo,
			dc = d._connect,
			handles = [];
		if(event == "ondijitclick"){
			// add key based click activation for unsupported nodes.
			// do all processing onkey up to prevent spurious clicks
			// for details see comments at top of this file where _lastKeyDownNode is defined
			if(!this.nodesWithKeyClick[obj.tagName.toLowerCase()]){
				var m = d.hitch(this, method);
				handles.push(
					dc(obj, "onkeydown", this, function(e){
						//console.log(this.id + ": onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", dijit._lastKeyDownNode, ", equality is ", (e.target === dijit._lastKeyDownNode));
						if((e.keyCode == d.keys.ENTER || e.keyCode == d.keys.SPACE) &&
							!e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey){
							// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
							dijit._lastKeyDownNode = e.target;
							d.stopEvent(e);		// stop event to prevent scrolling on space key in IE
						}
			 		}),
					dc(obj, "onkeyup", this, function(e){
						//console.log(this.id + ": onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", dijit._lastKeyDownNode, ", equality is ", (e.target === dijit._lastKeyDownNode));
						if( (e.keyCode == d.keys.ENTER || e.keyCode == d.keys.SPACE) &&
							e.target === dijit._lastKeyDownNode &&
							!e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey){
								//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
								dijit._lastKeyDownNode = null;
								return m(e);
						}
					})
				);
			}
			event = "onclick";
		}
		handles.push(dc(obj, event, this, method));

		this._connects.push(handles);
		return handles;		// _Widget.Handle
	},

	disconnect: function(/* _Widget.Handle */ handles){
		// summary:
		//		Disconnects handle created by `connect`.
		//		Also removes handle from this widget's list of connects.
		// tags:
		//		protected
		for(var i=0; i<this._connects.length; i++){
			if(this._connects[i] == handles){
				dojo.forEach(handles, dojo.disconnect);
				this._connects.splice(i, 1);
				return;
			}
		}
	},

	subscribe: function(
			/*String*/ topic,
			/*String|Function*/ method){
		// summary:
		//		Subscribes to the specified topic and calls the specified method
		//		of this object and registers for unsubscribe() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.subscribe, except with the
		//		implicit use of this widget as the target object.
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when /my/topic is published, this button changes its label to
		//	|   // be the parameter of the topic.
		//	|	btn.subscribe("/my/topic", function(v){
		//	|		this.attr("label", v);
		//	|	});
		var d = dojo,
			handle = d.subscribe(topic, this, method);

		// return handles for Any widget that may need them
		this._subscribes.push(handle);
		return handle;
	},

	unsubscribe: function(/*Object*/ handle){
		// summary:
		//		Unsubscribes handle created by this.subscribe.
		//		Also removes handle from this widget's list of subscriptions
		for(var i=0; i<this._subscribes.length; i++){
			if(this._subscribes[i] == handle){
				dojo.unsubscribe(handle);
				this._subscribes.splice(i, 1);
				return;
			}
		}
	},

	isLeftToRight: function(){
		// summary:
		//		Checks the page for text direction
		// tags:
		//		protected
		return dojo._isBodyLtr(); //Boolean
	},

	isFocusable: function(){
		// summary:
		//		Return true if this widget can currently be focused
		//		and false if not
		return this.focus && (dojo.style(this.domNode, "display") != "none");
	},

	placeAt: function(/* String|DomNode|_Widget */reference, /* String?|Int? */position){
		// summary:
		//		Place this widget's domNode reference somewhere in the DOM based
		//		on standard dojo.place conventions, or passing a Widget reference that
		//		contains and addChild member.
		//
		// description:
		//		A convenience function provided in all _Widgets, providing a simple
		//		shorthand mechanism to put an existing (or newly created) Widget
		//		somewhere in the dom, and allow chaining.
		//
		// reference:
		//		The String id of a domNode, a domNode reference, or a reference to a Widget posessing
		//		an addChild method.
		//
		// position:
		//		If passed a string or domNode reference, the position argument
		//		accepts a string just as dojo.place does, one of: "first", "last",
		//		"before", or "after".
		//
		//		If passed a _Widget reference, and that widget reference has an ".addChild" method,
		//		it will be called passing this widget instance into that method, supplying the optional
		//		position index passed.
		//
		// returns:
		//		dijit._Widget
		//		Provides a useful return of the newly created dijit._Widget instance so you
		//		can "chain" this function by instantiating, placing, then saving the return value
		//		to a variable.
		//
		// example:
		// | 	// create a Button with no srcNodeRef, and place it in the body:
		// | 	var button = new dijit.form.Button({ label:"click" }).placeAt(dojo.body());
		// | 	// now, 'button' is still the widget reference to the newly created button
		// | 	dojo.connect(button, "onClick", function(e){ console.log('click'); });
		//
		// example:
		// |	// create a button out of a node with id="src" and append it to id="wrapper":
		// | 	var button = new dijit.form.Button({},"src").placeAt("wrapper");
		//
		// example:
		// |	// place a new button as the first element of some div
		// |	var button = new dijit.form.Button({ label:"click" }).placeAt("wrapper","first");
		//
		// example:
		// |	// create a contentpane and add it to a TabContainer
		// |	var tc = dijit.byId("myTabs");
		// |	new dijit.layout.ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)

		if(reference.declaredClass && reference.addChild){
			reference.addChild(this, position);
		}else{
			dojo.place(this.domNode, reference, position);
		}
		return this;
	},

	_onShow: function(){
		// summary:
		//		Internal method called when this widget is made visible.
		//		See `onShow` for details.
		this.onShow();
	},

	onShow: function(){
		// summary:
		//		Called when this widget becomes the selected pane in a
		//		`dijit.layout.TabContainer`, `dijit.layout.StackContainer`,
		//		`dijit.layout.AccordionContainer`, etc.
		//
		//		Also called to indicate display of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onHide: function(){
		// summary:
			//		Called when another widget becomes the selected pane in a
			//		`dijit.layout.TabContainer`, `dijit.layout.StackContainer`,
			//		`dijit.layout.AccordionContainer`, etc.
			//
			//		Also called to indicate hide of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
			// tags:
			//		callback
	}
});

})();

}

if(!dojo._hasResource["dojo.string"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.string"] = true;
dojo.provide("dojo.string");

/*=====
dojo.string = { 
	// summary: String utilities for Dojo
};
=====*/

dojo.string.rep = function(/*String*/str, /*Integer*/num){
	//	summary:
	//		Efficiently replicate a string `n` times.
	//	str:
	//		the string to replicate
	//	num:
	//		number of times to replicate the string
	
	if(num <= 0 || !str){ return ""; }
	
	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

dojo.string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	//	summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	//	text:
	//		the string to pad
	//	size:
	//		length to provide padding
	//	ch:
	//		character to pad, defaults to '0'
	//	end:
	//		adds padding at the end if true, otherwise pads at start
	//	example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	dojo.string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = dojo.string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

dojo.string.substitute = function(	/*String*/		template, 
									/*Object|Array*/map, 
									/*Function?*/	transform, 
									/*Object?*/		thisObject){
	//	summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	//	template: 
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive. 
	//	map:
	//		hash to search for substitutions
	//	transform: 
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	//	thisObject: 
	//		where to look for optional format function; default to the global
	//		namespace
	//	example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	dojo.string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	dojo.string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	//	example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	dojo.string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	//	example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	dojo.string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || dojo.global;
	transform = transform ? 
		dojo.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			var value = dojo.getObject(key, false, map);
			if(format){
				value = dojo.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			return transform(value, key).toString();
		}); // String
};

/*=====
dojo.string.trim = function(str){
	//	summary:
	//		Trims whitespace from both sides of the string
	//	str: String
	//		String to be trimmed
	//	returns: String
	//		Returns the trimmed string
	//	description:
	//		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	//		The short yet performant version of this function is dojo.trim(),
	//		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	return "";	// String
}
=====*/

dojo.string.trim = String.prototype.trim ?
	dojo.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

}

if(!dojo._hasResource["dojo.date.stamp"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date.stamp"] = true;
dojo.provide("dojo.date.stamp");

// Methods to convert dates to or from a wire (string) format using well-known conventions

dojo.date.stamp.fromISOString = function(/*String*/formattedString, /*Number?*/defaultTime){
	//	summary:
	//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
	//
	//	description:
	//		Accepts a string formatted according to a profile of ISO8601 as defined by
	//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	//		The following combinations are valid:
	//
	//			* dates only
	//			|	* yyyy
	//			|	* yyyy-MM
	//			|	* yyyy-MM-dd
	// 			* times only, with an optional time zone appended
	//			|	* THH:mm
	//			|	* THH:mm:ss
	//			|	* THH:mm:ss.SSS
	// 			* and "datetimes" which could be any combination of the above
	//
	//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	//		input may return null.  Arguments which are out of bounds will be handled
	// 		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	//		Only years between 100 and 9999 are supported.
	//
  	//	formattedString:
	//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
	//
	//	defaultTime:
	//		Used for defaults for fields omitted in the formattedString.
	//		Uses 1970-01-01T00:00:00.0Z by default.

	if(!dojo.date.stamp._isoRegExp){
		dojo.date.stamp._isoRegExp =
//TODO: could be more restrictive and check for 00-59, etc.
			/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
	}

	var match = dojo.date.stamp._isoRegExp.exec(formattedString),
		result = null;

	if(match){
		match.shift();
		if(match[1]){match[1]--;} // Javascript Date months are 0-based
		if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds

		if(defaultTime){
			// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
			defaultTime = new Date(defaultTime);
			dojo.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
				return defaultTime["get" + prop]();
			}).forEach(function(value, index){
				if(match[index] === undefined){
					match[index] = value;
				}
			});
		}
		result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults
		if(match[0] < 100){
			result.setFullYear(match[0] || 1970);
		}

		var offset = 0,
			zoneSign = match[7] && match[7].charAt(0);
		if(zoneSign != 'Z'){
			offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
			if(zoneSign != '-'){ offset *= -1; }
		}
		if(zoneSign){
			offset -= result.getTimezoneOffset();
		}
		if(offset){
			result.setTime(result.getTime() + offset * 60000);
		}
	}

	return result; // Date or null
}

/*=====
	dojo.date.stamp.__Options = function(){
		//	selector: String
		//		"date" or "time" for partial formatting of the Date object.
		//		Both date and time will be formatted by default.
		//	zulu: Boolean
		//		if true, UTC/GMT is used for a timezone
		//	milliseconds: Boolean
		//		if true, output milliseconds
		this.selector = selector;
		this.zulu = zulu;
		this.milliseconds = milliseconds;
	}
=====*/

dojo.date.stamp.toISOString = function(/*Date*/dateObject, /*dojo.date.stamp.__Options?*/options){
	//	summary:
	//		Format a Date object as a string according a subset of the ISO-8601 standard
	//
	//	description:
	//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	//		Does not check bounds.  Only years between 100 and 9999 are supported.
	//
	//	dateObject:
	//		A Date object

	var _ = function(n){ return (n < 10) ? "0" + n : n; };
	options = options || {};
	var formattedDate = [],
		getter = options.zulu ? "getUTC" : "get",
		date = "";
	if(options.selector != "time"){
		var year = dateObject[getter+"FullYear"]();
		date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
	}
	formattedDate.push(date);
	if(options.selector != "date"){
		var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
		var millis = dateObject[getter+"Milliseconds"]();
		if(options.milliseconds){
			time += "."+ (millis < 100 ? "0" : "") + _(millis);
		}
		if(options.zulu){
			time += "Z";
		}else if(options.selector != "time"){
			var timezoneOffset = dateObject.getTimezoneOffset();
			var absOffset = Math.abs(timezoneOffset);
			time += (timezoneOffset > 0 ? "-" : "+") + 
				_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
		}
		formattedDate.push(time);
	}
	return formattedDate.join('T'); // String
}

}

if(!dojo._hasResource["dojo.parser"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.parser"] = true;
dojo.provide("dojo.parser");


dojo.parser = new function(){
	// summary: The Dom/Widget parsing package

	var d = dojo;
	this._attrName = d._scopeName + "Type";
	this._query = "[" + this._attrName + "]";

	function val2type(/*Object*/ value){
		// summary:
		//		Returns name of type of given value.

		if(d.isString(value)){ return "string"; }
		if(typeof value == "number"){ return "number"; }
		if(typeof value == "boolean"){ return "boolean"; }
		if(d.isFunction(value)){ return "function"; }
		if(d.isArray(value)){ return "array"; } // typeof [] == "object"
		if(value instanceof Date) { return "date"; } // assume timestamp
		if(value instanceof d._Url){ return "url"; }
		return "object";
	}

	function str2obj(/*String*/ value, /*String*/ type){
		// summary:
		//		Convert given string value to given type
		switch(type){
			case "string":
				return value;
			case "number":
				return value.length ? Number(value) : NaN;
			case "boolean":
				// for checked/disabled value might be "" or "checked".  interpret as true.
				return typeof value == "boolean" ? value : !(value.toLowerCase()=="false");
			case "function":
				if(d.isFunction(value)){
					// IE gives us a function, even when we say something like onClick="foo"
					// (in which case it gives us an invalid function "function(){ foo }"). 
					//  Therefore, convert to string
					value=value.toString();
					value=d.trim(value.substring(value.indexOf('{')+1, value.length-1));
				}
				try{
					if(value.search(/[^\w\.]+/i) != -1){
						// The user has specified some text for a function like "return x+5"
						return new Function(value);
					}else{
						// The user has specified the name of a function like "myOnClick"
						return d.getObject(value, false);
					}
				}catch(e){ return new Function(); }
			case "array":
				return value ? value.split(/\s*,\s*/) : [];
			case "date":
				switch(value){
					case "": return new Date("");	// the NaN of dates
					case "now": return new Date();	// current date
					default: return d.date.stamp.fromISOString(value);
				}
			case "url":
				return d.baseUrl + value;
			default:
				return d.fromJson(value);
		}
	}

	var instanceClasses = {
		// map from fully qualified name (like "dijit.Button") to structure like
		// { cls: dijit.Button, params: {label: "string", disabled: "boolean"} }
	};

	// Widgets like BorderContainer add properties to _Widget via dojo.extend().
	// If BorderContainer is loaded after _Widget's parameter list has been cached,
	// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
	dojo.connect(dojo, "extend", function(){
		instanceClasses = {};
	});

	function getClassInfo(/*String*/ className){
		// className:
		//		fully qualified name (like "dijit.form.Button")
		// returns:
		//		structure like
		//			{ 
		//				cls: dijit.Button, 
		//				params: { label: "string", disabled: "boolean"}
		//			}

		if(!instanceClasses[className]){
			// get pointer to widget class
			var cls = d.getObject(className);
			if(!d.isFunction(cls)){
				throw new Error("Could not load class '" + className +
					"'. Did you spell the name correctly and use a full path, like 'dijit.form.Button'?");
			}
			var proto = cls.prototype;
	
			// get table of parameter names & types
			var params = {}, dummyClass = {};
			for(var name in proto){
				if(name.charAt(0)=="_"){ continue; } 	// skip internal properties
				if(name in dummyClass){ continue; }		// skip "constructor" and "toString"
				var defVal = proto[name];
				params[name]=val2type(defVal);
			}

			instanceClasses[className] = { cls: cls, params: params };
		}
		return instanceClasses[className];
	}

	this._functionFromScript = function(script){
		var preamble = "";
		var suffix = "";
		var argsStr = script.getAttribute("args");
		if(argsStr){
			d.forEach(argsStr.split(/\s*,\s*/), function(part, idx){
				preamble += "var "+part+" = arguments["+idx+"]; ";
			});
		}
		var withStr = script.getAttribute("with");
		if(withStr && withStr.length){
			d.forEach(withStr.split(/\s*,\s*/), function(part){
				preamble += "with("+part+"){";
				suffix += "}";
			});
		}
		return new Function(preamble+script.innerHTML+suffix);
	}

	this.instantiate = function(/* Array */nodes, /* Object? */mixin, /* Object? */args){
		// summary:
		//		Takes array of nodes, and turns them into class instances and
		//		potentially calls a layout method to allow them to connect with
		//		any children		
		// mixin: Object?
		//		An object that will be mixed in with each node in the array.
		//		Values in the mixin will override values in the node, if they
		//		exist.
		// args: Object?
		//		An object used to hold kwArgs for instantiation.
		//		Only supports 'noStart' currently.
		var thelist = [], dp = dojo.parser;
		mixin = mixin||{};
		args = args||{};
		
		d.forEach(nodes, function(node){
			if(!node){ return; }
			var type = dp._attrName in mixin?mixin[dp._attrName]:node.getAttribute(dp._attrName);
			if(!type || !type.length){ return; }
			var clsInfo = getClassInfo(type),
				clazz = clsInfo.cls,
				ps = clazz._noScript || clazz.prototype._noScript;

			// read parameters (ie, attributes).
			// clsInfo.params lists expected params like {"checked": "boolean", "n": "number"}
			var params = {},
				attributes = node.attributes;
			for(var name in clsInfo.params){
				var item = name in mixin?{value:mixin[name],specified:true}:attributes.getNamedItem(name);
				if(!item || (!item.specified && (!dojo.isIE || name.toLowerCase()!="value"))){ continue; }
				var value = item.value;
				// Deal with IE quirks for 'class' and 'style'
				switch(name){
				case "class":
					value = "className" in mixin?mixin.className:node.className;
					break;
				case "style":
					value = "style" in mixin?mixin.style:(node.style && node.style.cssText); // FIXME: Opera?
				}
				var _type = clsInfo.params[name];
				if(typeof value == "string"){
					params[name] = str2obj(value, _type);
				}else{
					params[name] = value;
				}
			}

			// Process <script type="dojo/*"> script tags
			// <script type="dojo/method" event="foo"> tags are added to params, and passed to
			// the widget on instantiation.
			// <script type="dojo/method"> tags (with no event) are executed after instantiation
			// <script type="dojo/connect" event="foo"> tags are dojo.connected after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like <input />
			if(!ps){
				var connects = [],	// functions to connect after instantiation
					calls = [];		// functions to call after instantiation

				d.query("> script[type^='dojo/']", node).orphan().forEach(function(script){
					var event = script.getAttribute("event"),
						type = script.getAttribute("type"),
						nf = d.parser._functionFromScript(script);
					if(event){
						if(type == "dojo/connect"){
							connects.push({event: event, func: nf});
						}else{
							params[event] = nf;
						}
					}else{
						calls.push(nf);
					}
				});
			}

			var markupFactory = clazz.markupFactory || clazz.prototype && clazz.prototype.markupFactory;
			// create the instance
			var instance = markupFactory ? markupFactory(params, node, clazz) : new clazz(params, node);
			thelist.push(instance);

			// map it to the JS namespace if that makes sense
			var jsname = node.getAttribute("jsId");
			if(jsname){
				d.setObject(jsname, instance);
			}

			// process connections and startup functions
			if(!ps){
				d.forEach(connects, function(connect){
					d.connect(instance, connect.event, null, connect.func);
				});
				d.forEach(calls, function(func){
					func.call(instance);
				});
			}
		});

		// Call startup on each top level instance if it makes sense (as for
		// widgets).  Parent widgets will recursively call startup on their
		// (non-top level) children
		if(!mixin._started){
			d.forEach(thelist, function(instance){
				if(	!args.noStart && instance  && 
					instance.startup &&
					!instance._started && 
					(!instance.getParent || !instance.getParent())
				){
					instance.startup();
				}
			});
		}
		return thelist;
	};

	this.parse = function(/*DomNode?*/ rootNode, /* Object? */ args){
		// summary:
		//		Scan the DOM for class instances, and instantiate them.
		//
		// description:
		//		Search specified node (or root node) recursively for class instances,
		//		and instantiate them Searches for
		//		dojoType="qualified.class.name"
		//
		// rootNode: DomNode?
		//		A default starting root node from which to start the parsing. Can be
		//		omitted, defaulting to the entire document. If omitted, the `args`
		//		object can be passed in this place. If the `args` object has a 
		//		`rootNode` member, that is used.
		//
		// args:
		//		a kwArgs object passed along to instantiate()
		//		
		//			* noStart: Boolean?
		//				when set will prevent the parser from calling .startup()
		//				when locating the nodes. 
		//			* rootNode: DomNode?
		//				identical to the function's `rootNode` argument, though
		//				allowed to be passed in via this `args object. 
		//
		// example:
		//		Parse all widgets on a page:
		//	|		dojo.parser.parse();
		//
		// example:
		//		Parse all classes within the node with id="foo"
		//	|		dojo.parser.parse(dojo.byId(foo));
		//
		// example:
		//		Parse all classes in a page, but do not call .startup() on any 
		//		child
		//	|		dojo.parser.parse({ noStart: true })
		//
		// example:
		//		Parse all classes in a node, but do not call .startup()
		//	|		dojo.parser.parse(someNode, { noStart:true });
		//	|		// or
		// 	|		dojo.parser.parse({ noStart:true, rootNode: someNode });

		// determine the root node based on the passed arguments.
		var root;
		if(!args && rootNode && rootNode.rootNode){
			args = rootNode;
			root = args.rootNode;
		}else{
			root = rootNode;
		}

		var	list = d.query(this._query, root);
			// go build the object instances
		return this.instantiate(list, null, args); // Array

	};
}();

//Register the parser callback. It should be the first callback
//after the a11y test.

(function(){
	var parseRunner = function(){ 
		if(dojo.config.parseOnLoad){
			dojo.parser.parse(); 
		}
	};

	// FIXME: need to clobber cross-dependency!!
	if(dojo.exists("dijit.wai.onload") && (dijit.wai.onload === dojo._loaders[0])){
		dojo._loaders.splice(1, 0, parseRunner);
	}else{
		dojo._loaders.unshift(parseRunner);
	}
})();

}

if(!dojo._hasResource["dojo.cache"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cache"] = true;
dojo.provide("dojo.cache");

/*=====
dojo.cache = { 
	// summary:
	// 		A way to cache string content that is fetchable via `dojo.moduleUrl`.
};
=====*/

(function(){
	var cache = {};
	dojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		// summary:
		// 		A getter and setter for storing the string content associated with the
		// 		module and url arguments.
		// description:
		// 		module and url are used to call `dojo.moduleUrl()` to generate a module URL.
		// 		If value is specified, the cache value for the moduleUrl will be set to
		// 		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
		// 		in its internal cache and return that cached value for the URL. To clear
		// 		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
		// 		the URL contents, only modules on the same domain of the page can use this capability.
		// 		The build system can inline the cache values though, to allow for xdomain hosting.
		// module: String||Object
		// 		If a String, the module name to use for the base part of the URL, similar to module argument
		// 		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
		// 		generates a valid path for the cache item. For example, a dojo._Url object.
		// url: String
		// 		The rest of the path to append to the path derived from the module argument. If
		// 		module is an object, then this second argument should be the "value" argument instead.
		// value: String||Object?
		// 		If a String, the value to use in the cache for the module/url combination.
		// 		If an Object, it can have two properties: value and sanitize. The value property
		// 		should be the value to use in the cache, and sanitize can be set to true or false,
		// 		to indicate if XML declarations should be removed from the value and if the HTML
		// 		inside a body tag in the value should be extracted as the real value. The value argument
		// 		or the value property on the value argument are usually only used by the build system
		// 		as it inlines cache content.
		//	example:
		//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
		// 		of call is used to avoid an issue with the build system erroneously trying to intern
		// 		this example. To get the build system to intern your dojo.cache calls, use the
		// 		"dojo.cache" style of call):
		// 		|	//If template.html contains "<h1>Hello</h1>" that will be
		// 		|	//the value for the text variable.
		//		|	var text = dojo["cache"]("my.module", "template.html");
		//	example:
		//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
		// 		 (the dojo["cache"] style of call is used to avoid an issue with the build system 
		// 		erroneously trying to intern this example. To get the build system to intern your
		// 		dojo.cache calls, use the "dojo.cache" style of call):
		// 		|	//If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		// 		|	//text variable will contain just "<h1>Hello</h1>".
		//		|	var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
		//	example:
		//		Same example as previous, but demostrates how an object can be passed in as
		//		the first argument, then the value argument can then be the second argument.
		// 		|	//If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		// 		|	//text variable will contain just "<h1>Hello</h1>".
		//		|	var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});

		//Module could be a string, or an object that has a toString() method
		//that will return a useful path. If it is an object, then the "url" argument
		//will actually be the value argument.
		if(typeof module == "string"){
			var pathObj = dojo.moduleUrl(module, url);
		}else{
			pathObj = module;
			value = url;
		}
		var key = pathObj.toString();

		var val = value;
		if(value !== undefined && !dojo.isString(value)){
			val = ("value" in value ? value.value : undefined);
		}

		var sanitize = value && value.sanitize ? true : false;

		if(val || val === null){
			//We have a value, either clear or set the cache value.
			if(val == null){
				delete cache[key];
			}else{
				val = cache[key] = sanitize ? dojo.cache._sanitize(val) : val;
			}
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in cache)){
				val = dojo._getText(key);
				cache[key] = sanitize ? dojo.cache._sanitize(val) : val;
			}
			val = cache[key];
		}
		return val; //String
	};

	dojo.cache._sanitize = function(/*String*/val){
		// summary: 
		//		Strips <?xml ...?> declarations so that external SVG and XML
		// 		documents can be added to a document without worry. Also, if the string
		//		is an HTML document, only the part inside the body tag is returned.
		// description:
		// 		Copied from dijit._Templated._sanitizeTemplateString.
		if(val){
			val = val.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
			var matches = val.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
			if(matches){
				val = matches[1];
			}
		}else{
			val = "";
		}
		return val; //String
	};
})();

}

if(!dojo._hasResource["dijit._Templated"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Templated"] = true;
dojo.provide("dijit._Templated");






dojo.declare("dijit._Templated",
	null,
	{
		// summary:
		//		Mixin for widgets that are instantiated from a template

		// templateString: [protected] String
		//		A string that represents the widget template. Pre-empts the
		//		templatePath. In builds that have their strings "interned", the
		//		templatePath is converted to an inline templateString, thereby
		//		preventing a synchronous network call.
		//
		//		Use in conjunction with dojo.cache() to load from a file.
		templateString: null,

		// templatePath: [protected deprecated] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
		//		Deprecated: use templateString with dojo.cache() instead.
		templatePath: null,

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  False by default.
		widgetsInTemplate: false,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template node poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

		// _earlyTemplatedStartup: Boolean
		//		A fallback to preserve the 1.0 - 1.3 behavior of children in
		//		templates having their startup called before the parent widget
		//		fires postCreate. Defaults to 'false', causing child widgets to
		//		have their .startup() called immediately before a parent widget
		//		.startup(), but always after the parent .postCreate(). Set to
		//		'true' to re-enable to previous, arguably broken, behavior.
		_earlyTemplatedStartup: false,

		// _attachPoints: [private] String[]
		//		List of widget attribute names associated with dojoAttachPoint=... in the
		//		template, ex: ["containerNode", "labelNode"]
/*=====
 		_attachPoints: [],
 =====*/

		constructor: function(){
			this._attachPoints = [];
		},

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return dojo.string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = dojo.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value :
					// Safer substitution, see heading "Attribute values" in
					// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
					value.toString().replace(/"/g,"&quot;"); //TODO: add &amp? use encodeXML method?
			}, this);
		},

		// method over-ride
		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			// Lookup cached version of template, and download to cache if it
			// isn't there already.  Returns either a DomNode or a string, depending on
			// whether or not the template contains ${foo} replacement parameters.
			var cached = dijit._Templated.getCachedTemplate(this.templatePath, this.templateString, this._skipNodeCache);

			var node;
			if(dojo.isString(cached)){
				node = dojo._toDom(this._stringRepl(cached));
				if(node.nodeType != 1){
					// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
					throw new Error("Invalid template: " + cached);
				}
			}else{
				// if it's a node, all we have to do is clone it
				node = cached.cloneNode(true);
			}

			this.domNode = node;

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(node);

			if(this.widgetsInTemplate){
				// Make sure dojoType is used for parsing widgets in template.
				// The dojo.parser.query could be changed from multiversion support.
				var parser = dojo.parser, qry, attr;
				if(parser._query != "[dojoType]"){
					qry = parser._query;
					attr = parser._attrName;
					parser._query = "[dojoType]";
					parser._attrName = "dojoType";
				}

				// Store widgets that we need to start at a later point in time
				var cw = (this._startupWidgets = dojo.parser.parse(node, {
					noStart: !this._earlyTemplatedStartup
				}));

				// Restore the query.
				if(qry){
					parser._query = qry;
					parser._attrName = attr;
				}

				this._supportingWidgets = dijit.findWidgets(node);

				this._attachTemplateNodes(cw, function(n,p){
					return n[p];
				});
			}

			this._fillContent(this.srcNodeRef);
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		},

		_attachTemplateNodes: function(rootNode, getAttrFunc){
			// summary:
			//		Iterate through the template and attach functions and nodes accordingly.
			// description:
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//			* dojoAttachPoint
			//			* dojoAttachEvent
			//			* waiRole
			//			* waiState
			// rootNode: DomNode|Array[Widgets]
			//		the node to search for properties. All children will be searched.
			// getAttrFunc: Function?
			//		a function which will be used to obtain property for a given
			//		DomNode/Widget
			// tags:
			//		private

			getAttrFunc = getAttrFunc || function(n,p){ return n.getAttribute(p); };

			var nodes = dojo.isArray(rootNode) ? rootNode : (rootNode.all || rootNode.getElementsByTagName("*"));
			var x = dojo.isArray(rootNode) ? 0 : -1;
			for(; x<nodes.length; x++){
				var baseNode = (x == -1) ? rootNode : nodes[x];
				if(this.widgetsInTemplate && getAttrFunc(baseNode, "dojoType")){
					continue;
				}
				// Process dojoAttachPoint
				var attachPoint = getAttrFunc(baseNode, "dojoAttachPoint");
				if(attachPoint){
					var point, points = attachPoint.split(/\s*,\s*/);
					while((point = points.shift())){
						if(dojo.isArray(this[point])){
							this[point].push(baseNode);
						}else{
							this[point]=baseNode;
						}
						this._attachPoints.push(point);
					}
				}

				// Process dojoAttachEvent
				var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent");
				if(attachEvent){
					// NOTE: we want to support attributes that have the form
					// "domEvent: nativeEvent; ..."
					var event, events = attachEvent.split(/\s*,\s*/);
					var trim = dojo.trim;
					while((event = events.shift())){
						if(event){
							var thisFunc = null;
							if(event.indexOf(":") != -1){
								// oh, if only JS had tuple assignment
								var funcNameArr = event.split(":");
								event = trim(funcNameArr[0]);
								thisFunc = trim(funcNameArr[1]);
							}else{
								event = trim(event);
							}
							if(!thisFunc){
								thisFunc = event;
							}
							this.connect(baseNode, event, thisFunc);
						}
					}
				}

				// waiRole, waiState
				var role = getAttrFunc(baseNode, "waiRole");
				if(role){
					dijit.setWaiRole(baseNode, role);
				}
				var values = getAttrFunc(baseNode, "waiState");
				if(values){
					dojo.forEach(values.split(/\s*,\s*/), function(stateValue){
						if(stateValue.indexOf('-') != -1){
							var pair = stateValue.split('-');
							dijit.setWaiState(baseNode, pair[0], pair[1]);
						}
					});
				}
			}
		},

		startup: function(){
			dojo.forEach(this._startupWidgets, function(w){
				if(w && !w._started && w.startup){
					w.startup();
				}
			});
			this.inherited(arguments);
		},

		destroyRendering: function(){
			// Delete all attach points to prevent IE6 memory leaks.
			dojo.forEach(this._attachPoints, function(point){
				delete this[point];
			}, this);
			this._attachPoints = [];

			this.inherited(arguments);
		}
	}
);

// key is either templatePath or templateString; object is either string or DOM tree
dijit._Templated._templateCache = {};

dijit._Templated.getCachedTemplate = function(templatePath, templateString, alwaysUseString){
	// summary:
	//		Static method to get a template based on the templatePath or
	//		templateString key
	// templatePath: String||dojo.uri.Uri
	//		The URL to get the template from.
	// templateString: String?
	//		a string to use in lieu of fetching the template from a URL. Takes precedence
	//		over templatePath
	// returns: Mixed
	//		Either string (if there are ${} variables that need to be replaced) or just
	//		a DOM tree (if the node can be cloned directly)

	// is it already cached?
	var tmplts = dijit._Templated._templateCache;
	var key = templateString || templatePath;
	var cached = tmplts[key];
	if(cached){
		try{
			// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the current document, then use the current cached value
			if(!cached.ownerDocument || cached.ownerDocument == dojo.doc){
				// string or node of the same document
				return cached;
			}
		}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
		dojo.destroy(cached);
	}

	// If necessary, load template string from template path
	if(!templateString){
		templateString = dojo.cache(templatePath, {sanitize: true});
	}
	templateString = dojo.string.trim(templateString);

	if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
		// there are variables in the template so all we can do is cache the string
		return (tmplts[key] = templateString); //String
	}else{
		// there are no variables in the template so we can cache the DOM tree
		var node = dojo._toDom(templateString);
		if(node.nodeType != 1){
			throw new Error("Invalid template: " + templateString);
		}
		return (tmplts[key] = node); //Node
	}
};

if(dojo.isIE){
	dojo.addOnWindowUnload(function(){
		var cache = dijit._Templated._templateCache;
		for(var key in cache){
			var value = cache[key];
			if(typeof value == "object"){ // value is either a string or a DOM node template
				dojo.destroy(value);
			}
			delete cache[key];
		}
	});
}

// These arguments can be specified for widgets which are used in templates.
// Since any widget can be specified as sub widgets in template, mix it
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget,{
	dojoAttachEvent: "",
	dojoAttachPoint: "",
	waiRole: "",
	waiState:""
});

}

if(!dojo._hasResource["dijit.form._FormMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._FormMixin"] = true;
dojo.provide("dijit.form._FormMixin");

dojo.declare("dijit.form._FormMixin", null,
	{
	// summary:
	//		Mixin for containers of form widgets (i.e. widgets that represent a single value
	//		and can be children of a <form> node or dijit.form.Form widget)
	// description:
	//		Can extract all the form widgets
	//		values and combine them into a single javascript object, or alternately
	//		take such an object and set the values for all the contained
	//		form widgets

/*=====
    // value: Object
	//		Name/value hash for each form element.
	//		If there are multiple elements w/the same name, value is an array,
	//		unless they are radio buttons in which case value is a scalar since only
	//		one can be checked at a time.
	//
	//		If the name is a dot separated list (like a.b.c.d), it's a nested structure.
	//		Only works on widget form elements.
	// example:
	//	| { name: "John Smith", interests: ["sports", "movies"] }
=====*/

	//	TODO:
	//	* Repeater
	//	* better handling for arrays.  Often form elements have names with [] like
	//	* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])
	//
	//

		reset: function(){
			dojo.forEach(this.getDescendants(), function(widget){
				if(widget.reset){
					widget.reset();
				}
			});
		},

		validate: function(){
			// summary:
			//		returns if the form is valid - same as isValid - but
			//			provides a few additional (ui-specific) features.
			//			1 - it will highlight any sub-widgets that are not
			//				valid
			//			2 - it will call focus() on the first invalid
			//				sub-widget
			var didFocus = false;
			return dojo.every(dojo.map(this.getDescendants(), function(widget){
				// Need to set this so that "required" widgets get their
				// state set.
				widget._hasBeenBlurred = true;
				var valid = widget.disabled || !widget.validate || widget.validate();
				if(!valid && !didFocus){
					// Set focus of the first non-valid widget
					dijit.scrollIntoView(widget.containerNode || widget.domNode);
					widget.focus();
					didFocus = true;
				}
	 			return valid;
	 		}), function(item){ return item; });
		},

		setValues: function(val){
			dojo.deprecated(this.declaredClass+"::setValues() is deprecated. Use attr('value', val) instead.", "", "2.0");
			return this.attr('value', val);
		},
		_setValueAttr: function(/*object*/obj){
			// summary:
			//		Fill in form values from according to an Object (in the format returned by attr('value'))

			// generate map from name --> [list of widgets with that name]
			var map = { };
			dojo.forEach(this.getDescendants(), function(widget){
				if(!widget.name){ return; }
				var entry = map[widget.name] || (map[widget.name] = [] );
				entry.push(widget);
			});

			for(var name in map){
				if(!map.hasOwnProperty(name)){
					continue;
				}
				var widgets = map[name],						// array of widgets w/this name
					values = dojo.getObject(name, false, obj);	// list of values for those widgets

				if(values === undefined){
					continue;
				}
				if(!dojo.isArray(values)){
					values = [ values ];
				}
				if(typeof widgets[0].checked == 'boolean'){
					// for checkbox/radio, values is a list of which widgets should be checked
					dojo.forEach(widgets, function(w, i){
						w.attr('value', dojo.indexOf(values, w.value) != -1);
					});
				}else if(widgets[0].multiple){
					// it takes an array (e.g. multi-select)
					widgets[0].attr('value', values);
				}else{
					// otherwise, values is a list of values to be assigned sequentially to each widget
					dojo.forEach(widgets, function(w, i){
						w.attr('value', values[i]);
					});
				}
			}

			/***
			 * 	TODO: code for plain input boxes (this shouldn't run for inputs that are part of widgets)

			dojo.forEach(this.containerNode.elements, function(element){
				if(element.name == ''){return};	// like "continue"
				var namePath = element.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var p=namePath[j - 1];
					// repeater support block
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if

						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
						myObj=myObj[nameA[0]][nameIndex];
						continue;
					} // repeater support ends

					if(typeof(myObj[p]) == "undefined"){
						myObj=undefined;
						break;
					};
					myObj=myObj[p];
				}

				if(typeof(myObj) == "undefined"){
					return;		// like "continue"
				}
				if(typeof(myObj[name]) == "undefined" && this.ignoreNullValues){
					return;		// like "continue"
				}

				// TODO: widget values (just call attr('value', ...) on the widget)

				// TODO: maybe should call dojo.getNodeProp() instead
				switch(element.type){
					case "checkbox":
						element.checked = (name in myObj) &&
							dojo.some(myObj[name], function(val){ return val == element.value; });
						break;
					case "radio":
						element.checked = (name in myObj) && myObj[name] == element.value;
						break;
					case "select-multiple":
						element.selectedIndex=-1;
						dojo.forEach(element.options, function(option){
							option.selected = dojo.some(myObj[name], function(val){ return option.value == val; });
						});
						break;
					case "select-one":
						element.selectedIndex="0";
						dojo.forEach(element.options, function(option){
							option.selected = option.value == myObj[name];
						});
						break;
					case "hidden":
					case "text":
					case "textarea":
					case "password":
						element.value = myObj[name] || "";
						break;
				}
	  		});
	  		*/
		},

		getValues: function(){
			dojo.deprecated(this.declaredClass+"::getValues() is deprecated. Use attr('value') instead.", "", "2.0");
			return this.attr('value');
		},
		_getValueAttr: function(){
			// summary:
			// 		Returns Object representing form values.
			// description:
			//		Returns name/value hash for each form element.
			//		If there are multiple elements w/the same name, value is an array,
			//		unless they are radio buttons in which case value is a scalar since only
			//		one can be checked at a time.
			//
			//		If the name is a dot separated list (like a.b.c.d), creates a nested structure.
			//		Only works on widget form elements.
			// example:
			//		| { name: "John Smith", interests: ["sports", "movies"] }

			// get widget values
			var obj = { };
			dojo.forEach(this.getDescendants(), function(widget){
				var name = widget.name;
				if(!name || widget.disabled){ return; }

				// Single value widget (checkbox, radio, or plain <input> type widget
				var value = widget.attr('value');

				// Store widget's value(s) as a scalar, except for checkboxes which are automatically arrays
				if(typeof widget.checked == 'boolean'){
					if(/Radio/.test(widget.declaredClass)){
						// radio button
						if(value !== false){
							dojo.setObject(name, value, obj);
						}else{
							// give radio widgets a default of null
							value = dojo.getObject(name, false, obj);
							if(value === undefined){
								dojo.setObject(name, null, obj);
							}
						}
					}else{
						// checkbox/toggle button
						var ary=dojo.getObject(name, false, obj);
						if(!ary){
							ary=[];
							dojo.setObject(name, ary, obj);
						}
						if(value !== false){
							ary.push(value);
						}
					}
				}else{
					var prev=dojo.getObject(name, false, obj);
					if(typeof prev != "undefined"){
						if(dojo.isArray(prev)){
							prev.push(value);
						}else{
							dojo.setObject(name, [prev, value], obj);
						}
					}else{
						// unique name
						dojo.setObject(name, value, obj);
					}
				}
			});

			/***
			 * code for plain input boxes (see also dojo.formToObject, can we use that instead of this code?
			 * but it doesn't understand [] notation, presumably)
			var obj = { };
			dojo.forEach(this.containerNode.elements, function(elm){
				if(!elm.name)	{
					return;		// like "continue"
				}
				var namePath = elm.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var nameIndex = null;
					var p=namePath[j - 1];
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if
						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
					} else if(typeof(myObj[nameA[0]]) == "undefined"){
						myObj[nameA[0]] = { }
					} // if

					if(nameA.length == 1){
						myObj=myObj[nameA[0]];
					} else{
						myObj=myObj[nameA[0]][nameIndex];
					} // if
				} // for

				if((elm.type != "select-multiple" && elm.type != "checkbox" && elm.type != "radio") || (elm.type == "radio" && elm.checked)){
					if(name == name.split("[")[0]){
						myObj[name]=elm.value;
					} else{
						// can not set value when there is no name
					}
				} else if(elm.type == "checkbox" && elm.checked){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					myObj[name].push(elm.value);
				} else if(elm.type == "select-multiple"){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					for(var jdx=0,len3=elm.options.length; jdx<len3; ++jdx){
						if(elm.options[jdx].selected){
							myObj[name].push(elm.options[jdx].value);
						}
					}
				} // if
				name=undefined;
			}); // forEach
			***/
			return obj;
		},

		// TODO: ComboBox might need time to process a recently input value.  This should be async?
	 	isValid: function(){
	 		// summary:
	 		//		Returns true if all of the widgets are valid

	 		// This also populate this._invalidWidgets[] array with list of invalid widgets...
	 		// TODO: put that into separate function?   It's confusing to have that as a side effect
	 		// of a method named isValid().

			this._invalidWidgets = dojo.filter(this.getDescendants(), function(widget){
				return !widget.disabled && widget.isValid && !widget.isValid();
	 		});
			return !this._invalidWidgets.length;
		},


		onValidStateChange: function(isValid){
			// summary:
			//		Stub function to connect to if you want to do something
			//		(like disable/enable a submit button) when the valid
			//		state changes on the form as a whole.
		},

		_widgetChange: function(widget){
			// summary:
			//		Connected to a widget's onChange function - update our
			//		valid state, if needed.
			var isValid = this._lastValidState;
			if(!widget || this._lastValidState === undefined){
				// We have passed a null widget, or we haven't been validated
				// yet - let's re-check all our children
				// This happens when we connect (or reconnect) our children
				isValid = this.isValid();
				if(this._lastValidState === undefined){
					// Set this so that we don't fire an onValidStateChange
					// the first time
					this._lastValidState = isValid;
				}
			}else if(widget.isValid){
				this._invalidWidgets = dojo.filter(this._invalidWidgets || [], function(w){
					return (w != widget);
				}, this);
				if(!widget.isValid() && !widget.attr("disabled")){
					this._invalidWidgets.push(widget);
				}
				isValid = (this._invalidWidgets.length === 0);
			}
			if(isValid !== this._lastValidState){
				this._lastValidState = isValid;
				this.onValidStateChange(isValid);
			}
		},

		connectChildren: function(){
			// summary:
			//		Connects to the onChange function of all children to
			//		track valid state changes.  You can call this function
			//		directly, ex. in the event that you programmatically
			//		add a widget to the form *after* the form has been
			//		initialized.
			dojo.forEach(this._changeConnections, dojo.hitch(this, "disconnect"));
			var _this = this;

			// we connect to validate - so that it better reflects the states
			// of the widgets - also, we only connect if it has a validate
			// function (to avoid too many unneeded connections)
			var conns = this._changeConnections = [];
			dojo.forEach(dojo.filter(this.getDescendants(),
				function(item){ return item.validate; }
			),
			function(widget){
				// We are interested in whenever the widget is validated - or
				// whenever the disabled attribute on that widget is changed
				conns.push(_this.connect(widget, "validate",
									dojo.hitch(_this, "_widgetChange", widget)));
				conns.push(_this.connect(widget, "_setDisabledAttr",
									dojo.hitch(_this, "_widgetChange", widget)));
			});

			// Call the widget change function to update the valid state, in
			// case something is different now.
			this._widgetChange(null);
		},

		startup: function(){
			this.inherited(arguments);
			// Initialize our valid state tracking.  Needs to be done in startup
			// because it's not guaranteed that our children are initialized
			// yet.
			this._changeConnections = [];
			this.connectChildren();
		}
	});

}

if(!dojo._hasResource["dijit.form.Form"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Form"] = true;
dojo.provide("dijit.form.Form");





dojo.declare(
	"dijit.form.Form",
	[dijit._Widget, dijit._Templated, dijit.form._FormMixin],
	{
		// summary:
		//		Widget corresponding to HTML form tag, for validation and serialization
		//
		// example:
		//	|	<form dojoType="dijit.form.Form" id="myForm">
		//	|		Name: <input type="text" name="name" />
		//	|	</form>
		//	|	myObj = {name: "John Doe"};
		//	|	dijit.byId('myForm').attr('value', myObj);
		//	|
		//	|	myObj=dijit.byId('myForm').attr('value');

		// HTML <FORM> attributes

		// name: String?
		//		Name of form for scripting.
		name: "",

		// action: String?
		//		Server-side form handler.
		action: "",

		// method: String?
		//		HTTP method used to submit the form, either "GET" or "POST".
		method: "",

		// encType: String?
		//		Encoding type for the form, ex: application/x-www-form-urlencoded.
		encType: "",

		// accept-charset: String?
		//		List of supported charsets.
		"accept-charset": "",

		// accept: String?
		//		List of MIME types for file upload.
		accept: "",

		// target: String?
		//		Target frame for the document to be opened in.
		target: "",

		templateString: "<form dojoAttachPoint='containerNode' dojoAttachEvent='onreset:_onReset,onsubmit:_onSubmit' ${nameAttrSetting}></form>",

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			action: "",
			method: "",
			encType: "",
			"accept-charset": "",
			accept: "",
			target: ""
		}),

		postMixInProperties: function(){
			// Setup name=foo string to be referenced from the template (but only if a name has been specified)
			// Unfortunately we can't use attributeMap to set the name due to IE limitations, see #8660
			this.nameAttrSetting = this.name ? ("name='" + this.name + "'") : "";
			this.inherited(arguments);
		},

		execute: function(/*Object*/ formContents){
			// summary:
			//		Deprecated: use submit()
			// tags:
			//		deprecated
		},

		onExecute: function(){
			// summary:
			//		Deprecated: use onSubmit()
			// tags:
			//		deprecated
		},

		_setEncTypeAttr: function(/*String*/ value){
			this.encType = value;
			dojo.attr(this.domNode, "encType", value);
			if(dojo.isIE){ this.domNode.encoding = value; }
		},

		postCreate: function(){
			// IE tries to hide encType
			// TODO: this code should be in parser, not here.
			if(dojo.isIE && this.srcNodeRef && this.srcNodeRef.attributes){
				var item = this.srcNodeRef.attributes.getNamedItem('encType');
				if(item && !item.specified && (typeof item.value == "string")){
					this.attr('encType', item.value);
				}
			}
			this.inherited(arguments);
		},

		onReset: function(/*Event?*/ e){
			// summary:
			//		Callback when user resets the form. This method is intended
			//		to be over-ridden. When the `reset` method is called
			//		programmatically, the return value from `onReset` is used
			//		to compute whether or not resetting should proceed
			// tags:
			//		callback
			return true; // Boolean
		},

		_onReset: function(e){
			// create fake event so we can know if preventDefault() is called
			var faux = {
				returnValue: true, // the IE way
				preventDefault: function(){ // not IE
							this.returnValue = false;
						},
				stopPropagation: function(){}, currentTarget: e.currentTarget, target: e.target
			};
			// if return value is not exactly false, and haven't called preventDefault(), then reset
			if(!(this.onReset(faux) === false) && faux.returnValue){
				this.reset();
			}
			dojo.stopEvent(e);
			return false;
		},

		_onSubmit: function(e){
			var fp = dijit.form.Form.prototype;
			// TODO: remove this if statement beginning with 2.0
			if(this.execute != fp.execute || this.onExecute != fp.onExecute){
				dojo.deprecated("dijit.form.Form:execute()/onExecute() are deprecated. Use onSubmit() instead.", "", "2.0");
				this.onExecute();
				this.execute(this.getValues());
			}
			if(this.onSubmit(e) === false){ // only exactly false stops submit
				dojo.stopEvent(e);
			}
		},

		onSubmit: function(/*Event?*/e){
			// summary:
			//		Callback when user submits the form.
			// description:
			//		This method is intended to be over-ridden, but by default it checks and
			//		returns the validity of form elements. When the `submit`
			//		method is called programmatically, the return value from
			//		`onSubmit` is used to compute whether or not submission
			//		should proceed
			// tags:
			//		extension

			return this.isValid(); // Boolean
		},

		submit: function(){
			// summary:
			//		programmatically submit form if and only if the `onSubmit` returns true
			if(!(this.onSubmit() === false)){
				this.containerNode.submit();
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.form._FormWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._FormWidget"] = true;
dojo.provide("dijit.form._FormWidget");




dojo.declare("dijit.form._FormWidget", [dijit._Widget, dijit._Templated],
	{
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <checkbox> or <button>,
	//		which can be children of a <form> node or a `dijit.form.Form` widget.
	//
	// description:
	//		Represents a single HTML element.
	//		All these widgets should have these attributes just like native HTML input elements.
	//		You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	//
	//		They also share some common methods.

	// baseClass: [protected] String
	//		Root CSS class of the widget (ex: dijitTextBox), used to add CSS classes of widget
	//		(ex: "dijitTextBox dijitTextBoxInvalid dijitTextBoxFocused dijitTextBoxInvalidFocused")
	//		See _setStateClass().
	baseClass: "",

	// name: String
	//		Name used when submitting form; same as "name" attribute or plain HTML elements
	name: "",

	// alt: String
	//		Corresponds to the native HTML <input> element's attribute.
	alt: "",

	// value: String
	//		Corresponds to the native HTML <input> element's attribute.
	value: "",

	// type: String
	//		Corresponds to the native HTML <input> element's attribute.
	type: "text",

	// tabIndex: Integer
	//		Order fields are traversed when user hits the tab key
	tabIndex: "0",

	// disabled: Boolean
	//		Should this widget respond to user input?
	//		In markup, this is specified as "disabled='disabled'", or just "disabled".
	disabled: false,

	// intermediateChanges: Boolean
	//		Fires onChange for each value change or only on demand
	intermediateChanges: false,

	// scrollOnFocus: Boolean
	//		On focus, should this widget scroll into view?
	scrollOnFocus: true,

	// These mixins assume that the focus node is an INPUT, as many but not all _FormWidgets are.
	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		value: "focusNode",
		id: "focusNode",
		tabIndex: "focusNode",
		alt: "focusNode",
		title: "focusNode"
	}),

	postMixInProperties: function(){
		// Setup name=foo string to be referenced from the template (but only if a name has been specified)
		// Unfortunately we can't use attributeMap to set the name due to IE limitations, see #8660
		this.nameAttrSetting = this.name ? ("name='" + this.name + "'") : "";
		this.inherited(arguments);
	},

	_setDisabledAttr: function(/*Boolean*/ value){
		this.disabled = value;
		dojo.attr(this.focusNode, 'disabled', value);
		if(this.valueNode){
			dojo.attr(this.valueNode, 'disabled', value);
		}
		dijit.setWaiState(this.focusNode, "disabled", value);

		if(value){
			// reset those, because after the domNode is disabled, we can no longer receive
			// mouse related events, see #4200
			this._hovering = false;
			this._active = false;
			// remove the tabIndex, especially for FF
			this.focusNode.setAttribute('tabIndex', "-1");
		}else{
			this.focusNode.setAttribute('tabIndex', this.tabIndex);
		}
		this._setStateClass();
	},

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated.   Use attr('disabled', ...) instead.
		dojo.deprecated("setDisabled("+disabled+") is deprecated. Use attr('disabled',"+disabled+") instead.", "", "2.0");
		this.attr('disabled', disabled);
	},

	_onFocus: function(e){
		if(this.scrollOnFocus){
			dijit.scrollIntoView(this.domNode);
		}
		this.inherited(arguments);
	},

	_onMouse : function(/*Event*/ event){
		// summary:
		//	Sets _hovering, _active, and stateModifier properties depending on mouse state,
		//	then calls setStateClass() to set appropriate CSS classes for this.domNode.
		//
		//	To get a different CSS class for hover, send onmouseover and onmouseout events to this method.
		//	To get a different CSS class while mouse button is depressed, send onmousedown to this method.

		var mouseNode = event.currentTarget;
		if(mouseNode && mouseNode.getAttribute){
			this.stateModifier = mouseNode.getAttribute("stateModifier") || "";
		}

		if(!this.disabled){
			switch(event.type){
				case "mouseenter":
				case "mouseover":
					this._hovering = true;
					this._active = this._mouseDown;
					break;

				case "mouseout":
				case "mouseleave":
					this._hovering = false;
					this._active = false;
					break;

				case "mousedown" :
					this._active = true;
					this._mouseDown = true;
					// set a global event to handle mouseup, so it fires properly
					//	even if the cursor leaves the button
					var mouseUpConnector = this.connect(dojo.body(), "onmouseup", function(){
						// if user clicks on the button, even if the mouse is released outside of it,
						// this button should get focus (which mimics native browser buttons)
						if(this._mouseDown && this.isFocusable()){
							this.focus();
						}
						this._active = false;
						this._mouseDown = false;
						this._setStateClass();
						this.disconnect(mouseUpConnector);
					});
					break;
			}
			this._setStateClass();
		}
	},

	isFocusable: function(){
		// summary:
		//		Tells if this widget is focusable or not.   Used internally by dijit.
		// tags:
		//		protected
		return !this.disabled && !this.readOnly && this.focusNode && (dojo.style(this.domNode, "display") != "none");
	},

	focus: function(){
		// summary:
		//		Put focus on this widget
		dijit.focus(this.focusNode);
	},

	_setStateClass: function(){
		// summary:
		//		Update the visual state of the widget by setting the css classes on this.domNode
		//		(or this.stateNode if defined) by combining this.baseClass with
		//		various suffixes that represent the current widget state(s).
		//
		// description:
		//		In the case where a widget has multiple
		//		states, it sets the class based on all possible
		//	 	combinations.  For example, an invalid form widget that is being hovered
		//		will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
		//
		//		For complex widgets with multiple regions, there can be various hover/active states,
		//		such as "Hover" or "CloseButtonHover" (for tab buttons).
		//		This is controlled by a stateModifier="CloseButton" attribute on the close button node.
		//
		//		The widget may have one or more of the following states, determined
		//		by this.state, this.checked, this.valid, and this.selected:
		//			- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
		//			- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
		//			- Selected - ex: currently selected tab will have this.selected==true
		//
		//		In addition, it may have one or more of the following states,
		//		based on this.disabled and flags set in _onMouse (this._active, this._hovering, this._focused):
		//			- Disabled	- if the widget is disabled
		//			- Active		- if the mouse (or space/enter key?) is being pressed down
		//			- Focused		- if the widget has focus
		//			- Hover		- if the mouse is over the widget

		// Compute new set of classes
		var newStateClasses = this.baseClass.split(" ");

		function multiply(modifier){
			newStateClasses = newStateClasses.concat(dojo.map(newStateClasses, function(c){ return c+modifier; }), "dijit"+modifier);
		}

		if(this.checked){
			multiply("Checked");
		}
		if(this.state){
			multiply(this.state);
		}
		if(this.selected){
			multiply("Selected");
		}

		if(this.disabled){
			multiply("Disabled");
		}else if(this.readOnly){
			multiply("ReadOnly");
		}else if(this._active){
			multiply(this.stateModifier+"Active");
		}else{
			if(this._focused){
				multiply("Focused");
			}
			if(this._hovering){
				multiply(this.stateModifier+"Hover");
			}
		}

		// Remove old state classes and add new ones.
		// For performance concerns we only write into domNode.className once.
		var tn = this.stateNode || this.domNode,
			classHash = {};	// set of all classes (state and otherwise) for node

		dojo.forEach(tn.className.split(" "), function(c){ classHash[c] = true; });

		if("_stateClasses" in this){
			dojo.forEach(this._stateClasses, function(c){ delete classHash[c]; });
		}

		dojo.forEach(newStateClasses, function(c){ classHash[c] = true; });

		var newClasses = [];
		for(var c in classHash){
			newClasses.push(c);
		}
		tn.className = newClasses.join(" ");

		this._stateClasses = newStateClasses;
	},

	compare: function(/*anything*/val1, /*anything*/val2){
		// summary:
		//		Compare 2 values (as returned by attr('value') for this widget).
		// tags:
		//		protected
		if(typeof val1 == "number" && typeof val2 == "number"){
			return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
		}else if(val1 > val2){
			return 1;
		}else if(val1 < val2){
			return -1;
		}else{
			return 0;
		}
	},

	onChange: function(newValue){
		// summary:
		//		Callback when this widget's value is changed.
		// tags:
		//		callback
	},

	// _onChangeActive: [private] Boolean
	//		Indicates that changes to the value should call onChange() callback.
	//		This is false during widget initialization, to avoid calling onChange()
	//		when the initial value is set.
	_onChangeActive: false,

	_handleOnChange: function(/*anything*/ newValue, /* Boolean? */ priorityChange){
		// summary:
		//		Called when the value of the widget is set.  Calls onChange() if appropriate
		// newValue:
		//		the new value
		// priorityChange:
		//		For a slider, for example, dragging the slider is priorityChange==false,
		//		but on mouse up, it's priorityChange==true.  If intermediateChanges==true,
		//		onChange is only called form priorityChange=true events.
		// tags:
		//		private
		this._lastValue = newValue;
		if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
			// this block executes not for a change, but during initialization,
			// and is used to store away the original value (or for ToggleButton, the original checked state)
			this._resetValue = this._lastValueReported = newValue;
		}
		if((this.intermediateChanges || priorityChange || priorityChange === undefined) &&
			((typeof newValue != typeof this._lastValueReported) ||
				this.compare(newValue, this._lastValueReported) != 0)){
			this._lastValueReported = newValue;
			if(this._onChangeActive){
				if(this._onChangeHandle){
					clearTimeout(this._onChangeHandle);
				}
				// setTimout allows hidden value processing to run and
				// also the onChange handler can safely adjust focus, etc
				this._onChangeHandle = setTimeout(dojo.hitch(this,
					function(){
						this._onChangeHandle = null;
						this.onChange(newValue);
					}), 0); // try to collapse multiple onChange's fired faster than can be processed
			}
		}
	},

	create: function(){
		// Overrides _Widget.create()
		this.inherited(arguments);
		this._onChangeActive = true;
		this._setStateClass();
	},

	destroy: function(){
		if(this._onChangeHandle){ // destroy called before last onChange has fired
			clearTimeout(this._onChangeHandle);
			this.onChange(this._lastValueReported);
		}
		this.inherited(arguments);
	},

	setValue: function(/*String*/ value){
		// summary:
		//		Deprecated.   Use attr('value', ...) instead.
		dojo.deprecated("dijit.form._FormWidget:setValue("+value+") is deprecated.  Use attr('value',"+value+") instead.", "", "2.0");
		this.attr('value', value);
	},

	getValue: function(){
		// summary:
		//		Deprecated.   Use attr('value') instead.
		dojo.deprecated(this.declaredClass+"::getValue() is deprecated. Use attr('value') instead.", "", "2.0");
		return this.attr('value');
	}
});

dojo.declare("dijit.form._FormValueWidget", dijit.form._FormWidget,
{
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <input> or <select> that have user changeable values.
	// description:
	//		Each _FormValueWidget represents a single input value, and has a (possibly hidden) <input> element,
	//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	//		works as expected.

	// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared
	// directly in the template as read by the parser in order to function. IE is known to specifically
	// require the 'name' attribute at element creation time.   See #8484, #8660.
	// TODO: unclear what that {value: ""} is for; FormWidget.attributeMap copies value to focusNode,
	// so maybe {value: ""} is so the value *doesn't* get copied to focusNode?
	// Seems like we really want value removed from attributeMap altogether
	// (although there's no easy way to do that now)

	// readOnly: Boolean
	//		Should this widget respond to user input?
	//		In markup, this is specified as "readOnly".
	//		Similar to disabled except readOnly form values are submitted.
	readOnly: false,

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		value: "",
		readOnly: "focusNode"
	}),

	_setReadOnlyAttr: function(/*Boolean*/ value){
		this.readOnly = value;
		dojo.attr(this.focusNode, 'readOnly', value);
		dijit.setWaiState(this.focusNode, "readonly", value);
		this._setStateClass();
	},

	postCreate: function(){
		if(dojo.isIE){ // IE won't stop the event with keypress
			this.connect(this.focusNode || this.domNode, "onkeydown", this._onKeyDown);
		}
		// Update our reset value if it hasn't yet been set (because this.attr
		// is only called when there *is* a value
		if(this._resetValue === undefined){
			this._resetValue = this.value;
		}
	},

	_setValueAttr: function(/*anything*/ newValue, /*Boolean, optional*/ priorityChange){
		// summary:
		//		Hook so attr('value', value) works.
		// description:
		//		Sets the value of the widget.
		//		If the value has changed, then fire onChange event, unless priorityChange
		//		is specified as null (or false?)
		this.value = newValue;
		this._handleOnChange(newValue, priorityChange);
	},

	_getValueAttr: function(){
		// summary:
		//		Hook so attr('value') works.
		return this._lastValue;
	},

	undo: function(){
		// summary:
		//		Restore the value to the last value passed to onChange
		this._setValueAttr(this._lastValueReported, false);
	},

	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time
		this._hasBeenBlurred = false;
		this._setValueAttr(this._resetValue, true);
	},

	_onKeyDown: function(e){
		if(e.keyCode == dojo.keys.ESCAPE && !(e.ctrlKey || e.altKey || e.metaKey)){
			var te;
			if(dojo.isIE){
				e.preventDefault(); // default behavior needs to be stopped here since keypress is too late
				te = document.createEventObject();
				te.keyCode = dojo.keys.ESCAPE;
				te.shiftKey = e.shiftKey;
				e.srcElement.fireEvent('onkeypress', te);
			}
		}
	},

	_layoutHackIE7: function(){
		// summary:
		//		Work around table sizing bugs on IE7 by forcing redraw

		if(dojo.isIE == 7){ // fix IE7 layout bug when the widget is scrolled out of sight
			var domNode = this.domNode;
			var parent = domNode.parentNode;
			var pingNode = domNode.firstChild || domNode; // target node most unlikely to have a custom filter
			var origFilter = pingNode.style.filter; // save custom filter, most likely nothing
			while(parent && parent.clientHeight == 0){ // search for parents that haven't rendered yet
				parent._disconnectHandle = this.connect(parent, "onscroll", dojo.hitch(this, function(e){
					this.disconnect(parent._disconnectHandle); // only call once
					parent.removeAttribute("_disconnectHandle"); // clean up DOM node
					pingNode.style.filter = (new Date()).getMilliseconds(); // set to anything that's unique
					setTimeout(function(){ pingNode.style.filter = origFilter }, 0); // restore custom filter, if any
				}));
				parent = parent.parentNode;
			}
		}
	}
});

}

if(!dojo._hasResource["dijit._Container"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Container"] = true;
dojo.provide("dijit._Container");

dojo.declare("dijit._Container",
	null,
	{
		// summary:
		//		Mixin for widgets that contain a set of widget children.
		// description:
		//		Use this mixin for widgets that needs to know about and
		//		keep track of their widget children. Suitable for widgets like BorderContainer
		//		and TabContainer which contain (only) a set of child widgets.
		//
		//		It's not suitable for widgets like ContentPane
		//		which contains mixed HTML (plain DOM nodes in addition to widgets),
		//		and where contained widgets are not necessarily directly below
		//		this.containerNode.   In that case calls like addChild(node, position)
		//		wouldn't make sense.

		// isContainer: [protected] Boolean
		//		Indicates that this widget acts as a "parent" to the descendant widgets.
		//		When the parent is started it will call startup() on the child widgets.
		//		See also `isLayoutContainer`.
		isContainer: true,

		buildRendering: function(){
			this.inherited(arguments);
			if(!this.containerNode){
				// all widgets with descendants must set containerNode
	 				this.containerNode = this.domNode;
			}
		},

		addChild: function(/*dijit._Widget*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Makes the given widget a child of this widget.
			// description:
			//		Inserts specified child widget's dom node as a child of this widget's
			//		container node, and possibly does other processing (such as layout).

			var refNode = this.containerNode;
			if(insertIndex && typeof insertIndex == "number"){
				var children = this.getChildren();
				if(children && children.length >= insertIndex){
					refNode = children[insertIndex-1].domNode;
					insertIndex = "after";
				}
			}
			dojo.place(widget.domNode, refNode, insertIndex);

			// If I've been started but the child widget hasn't been started,
			// start it now.  Make sure to do this after widget has been
			// inserted into the DOM tree, so it can see that it's being controlled by me,
			// so it doesn't try to size itself.
			if(this._started && !widget._started){
				widget.startup();
			}
		},

		removeChild: function(/*Widget or int*/ widget){
			// summary:
			//		Removes the passed widget instance from this widget but does
			//		not destroy it.  You can also pass in an integer indicating
			//		the index within the container to remove

			if(typeof widget == "number" && widget > 0){
				widget = this.getChildren()[widget];
			}

			if(widget && widget.domNode){
				var node = widget.domNode;
				node.parentNode.removeChild(node); // detach but don't destroy
			}
		},

		getChildren: function(){
			// summary:
			//		Returns array of children widgets.
			// description:
			//		Returns the widgets that are directly under this.containerNode.
			return dojo.query("> [widgetId]", this.containerNode).map(dijit.byNode); // Widget[]
		},

		hasChildren: function(){
			// summary:
			//		Returns true if widget has children, i.e. if this.containerNode contains something.
			return dojo.query("> [widgetId]", this.containerNode).length > 0;	// Boolean
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			// summary:
			//      Destroys all the widgets inside this.containerNode,
			//      but not this widget itself
			dojo.forEach(this.getChildren(), function(child){ child.destroyRecursive(preserveDom); });
		},

		_getSiblingOfChild: function(/*dijit._Widget*/ child, /*int*/ dir){
			// summary:
			//		Get the next or previous widget sibling of child
			// dir:
			//		if 1, get the next sibling
			//		if -1, get the previous sibling
			// tags:
			//      private
			var node = child.domNode,
				which = (dir>0 ? "nextSibling" : "previousSibling");
			do{
				node = node[which];
			}while(node && (node.nodeType != 1 || !dijit.byNode(node)));
			return node && dijit.byNode(node);	// dijit._Widget
		},

		getIndexOfChild: function(/*dijit._Widget*/ child){
			// summary:
			//		Gets the index of the child in this container or -1 if not found
			return dojo.indexOf(this.getChildren(), child);	// int
		},

		startup: function(){
			// summary:
			//		Called after all the widgets have been instantiated and their
			//		dom nodes have been inserted somewhere under dojo.doc.body.
			//
			//		Widgets should override this method to do any initialization
			//		dependent on other widgets existing, and then call
			//		this superclass method to finish things off.
			//
			//		startup() in subclasses shouldn't do anything
			//		size related because the size of the widget hasn't been set yet.

			if(this._started){ return; }

			// Startup all children of this widget
			dojo.forEach(this.getChildren(), function(child){ child.startup(); });

			this.inherited(arguments);
		}
	}
);

}

if(!dojo._hasResource["dijit._HasDropDown"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._HasDropDown"] = true;
dojo.provide("dijit._HasDropDown");




dojo.declare("dijit._HasDropDown",
	null,
	{
		// summary:
		//		Mixin for widgets that need drop down ability.

		// _buttonNode: [protected] DomNode
		//		The button/icon/node to click to display the drop down.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then either focusNode or domNode (if focusNode is also missing) will be used.
		_buttonNode: null,

		// _arrowWrapperNode: [protected] DomNode
		//		Will set CSS class dijitUpArrow, dijitDownArrow, dijitRightArrow etc. on this node depending
		//		on where the drop down is set to be positioned.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then _buttonNode will be used.
		_arrowWrapperNode: null,

		// _popupStateNode: [protected] DomNode
		//		The node to set the popupActive class on.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then focusNode or _buttonNode (if focusNode is missing) will be used.
		_popupStateNode: null,

		// _aroundNode: [protected] DomNode
		//		The node to display the popup around.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then domNode will be used.
		_aroundNode: null,

		// dropDown: [protected] Widget
		//		The widget to display as a popup.  This widget *must* be
		//		defined before the startup function is called.
		dropDown: null,

		// autoWidth: [protected] Boolean
		//		Set to true to make the drop down at least as wide as this
		//		widget.  Set to false if the drop down should just be its
		//		default width
		autoWidth: true,

		// forceWidth: [protected] Boolean
		//		Set to true to make the drop down exactly as wide as this
		//		widget.  Overrides autoWidth.
		forceWidth: false,

		// maxHeight: [protected] Integer
		//		The max height for our dropdown.  Set to 0 for no max height.
		//		any dropdown taller than this will have scrollbars
		maxHeight: 0,

		// dropDownPosition: [const] String[]
		//		This variable controls the position of the drop down.
		//		It's an array of strings with the following values:
		//
		//			* before: places drop down to the left of the target node/widget, or to the right in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* after: places drop down to the right of the target node/widget, or to the left in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* above: drop down goes above target node
		//			* below: drop down goes below target node
		//
		//		The list is positions is tried, in order, until a position is found where the drop down fits
		//		within the viewport.
		//
		dropDownPosition: ["below","above"],

		// _stopClickEvents: Boolean
		//		When set to false, the click events will not be stopped, in
		//		case you want to use them in your subwidget
		_stopClickEvents: true,

		_onDropDownMouse: function(/*Event*/ e){
			// summary:
			//		Callback when the user mouse clicks on the arrow icon, or presses the down
			//		arrow key, to open the drop down.

			// We handle mouse events using onmousedown in order to allow for selecting via
			// a mouseDown --> mouseMove --> mouseUp.  So, our click is already handled, unless
			// we are executed via keypress - in which case, this._seenKeydown
			// will be set to true.
			if(e.type == "click" && !this._seenKeydown){ return; }
			this._seenKeydown = false;

			// If we are a mouse event, set up the mouseup handler.  See _onDropDownMouse() for
			// details on this handler.
			if(e.type == "mousedown"){
				this._docHandler = this.connect(dojo.doc, "onmouseup", "_onDropDownMouseup");
			}
			if(this.disabled || this.readOnly){ return; }
			if(this._stopClickEvents){
				dojo.stopEvent(e);
			}
			this.toggleDropDown();

			// If we are a click, then we'll pretend we did a mouse up
			if(e.type == "click" || e.type == "keypress"){
				this._onDropDownMouseup();
			}
		},

		_onDropDownMouseup: function(/*Event?*/ e){
			// summary:
			//		Callback when the user lifts their mouse after mouse down on the arrow icon.
			//		If the drop is a simple menu and the mouse is over the menu, we execute it, otherwise, we focus our
			//		dropDown node.  If the event is missing, then we are not
			//		a mouseup event.
			//
			//		This is useful for the common mouse movement pattern
			//		with native browser <select> nodes:
			//			1. mouse down on the select node (probably on the arrow)
			//			2. move mouse to a menu item while holding down the mouse button
			//			3. mouse up.  this selects the menu item as though the user had clicked it.

			if(e && this._docHandler){
				this.disconnect(this._docHandler);
			}
			var dropDown = this.dropDown, overMenu = false;

			if(e && this._opened){
				// This code deals with the corner-case when the drop down covers the original widget,
				// because it's so large.  In that case mouse-up shouldn't select a value from the menu.
				// Find out if our target is somewhere in our dropdown widget,
				// but not over our _buttonNode (the clickable node)
				var c = dojo.position(this._buttonNode, true);
				if(!(e.pageX >= c.x && e.pageX <= c.x + c.w) ||
					!(e.pageY >= c.y && e.pageY <= c.y + c.h)){
					var t = e.target;
					while(t && !overMenu){
						if(dojo.hasClass(t, "dijitPopup")){
							overMenu = true;
						}else{
							t = t.parentNode;
						}
					}
					if(overMenu){
						t = e.target;
						if(dropDown.onItemClick){
							var menuItem;
							while(t && !(menuItem = dijit.byNode(t))){
								t = t.parentNode;
							}
							if(menuItem && menuItem.onClick && menuItem.getParent){
								menuItem.getParent().onItemClick(menuItem, e);
							}
						}
						return;
					}
				}
			}
			if(this._opened && dropDown.focus){
				// Focus the dropdown widget - do it on a delay so that we
				// don't steal our own focus.
				window.setTimeout(dojo.hitch(dropDown, "focus"), 1);
			}
		},

		_setupDropdown: function(){
			// summary:
			//		set up nodes and connect our mouse and keypress events
			this._buttonNode = this._buttonNode || this.focusNode || this.domNode;
			this._popupStateNode = this._popupStateNode || this.focusNode || this._buttonNode;
			this._aroundNode = this._aroundNode || this.domNode;
			this.connect(this._buttonNode, "onmousedown", "_onDropDownMouse");
			this.connect(this._buttonNode, "onclick", "_onDropDownMouse");
			this.connect(this._buttonNode, "onkeydown", "_onDropDownKeydown");
			this.connect(this._buttonNode, "onblur", "_onDropDownBlur");
			this.connect(this._buttonNode, "onkeypress", "_onKey");

			// If we have a _setStateClass function (which happens when
			// we are a form widget), then we need to connect our open/close
			// functions to it
			if(this._setStateClass){
				this.connect(this, "openDropDown", "_setStateClass");
				this.connect(this, "closeDropDown", "_setStateClass");
			}

			// Add a class to the "dijitDownArrowButton" type class to _buttonNode so theme can set direction of arrow
			// based on where drop down will normally appear
			var defaultPos = {
					"after" : this.isLeftToRight() ? "Right" : "Left",
					"before" : this.isLeftToRight() ? "Left" : "Right",
					"above" : "Up",
					"below" : "Down",
					"left" : "Left",
					"right" : "Right"
			}[this.dropDownPosition[0]] || this.dropDownPosition[0] || "Down";
			dojo.addClass(this._arrowWrapperNode || this._buttonNode, "dijit" + defaultPos + "ArrowButton");
		},

		postCreate: function(){
			this._setupDropdown();
			this.inherited(arguments);
		},

		destroyDescendants: function(){
			if(this.dropDown){
				// Destroy the drop down, unless it's already been destroyed.  This can happen because
				// the drop down is a direct child of <body> even though it's logically my child.
				if(!this.dropDown._destroyed){
					this.dropDown.destroyRecursive();
				}
				delete this.dropDown;
			}
			this.inherited(arguments);
		},

		_onDropDownKeydown: function(/*Event*/ e){
			this._seenKeydown = true;
		},

		_onKeyPress: function(/*Event*/ e){
			if(this._opened && e.charOrCode == dojo.keys.ESCAPE && !e.shiftKey && !e.ctrlKey && !e.altKey){
				this.toggleDropDown();
				dojo.stopEvent(e);
				return;
			}
			this.inherited(arguments);
		},

		_onDropDownBlur: function(/*Event*/ e){
			this._seenKeydown = false;
		},

		_onKey: function(/*Event*/ e){
			// summary:
			//		Callback when the user presses a key on menu popup node

			if(this.disabled || this.readOnly){ return; }
			var d = this.dropDown;
			if(d && this._opened && d.handleKey){
				if(d.handleKey(e) === false){ return; }
			}
			if(d && this._opened && e.keyCode == dojo.keys.ESCAPE){
				this.toggleDropDown();
				return;
			}
			if(e.keyCode == dojo.keys.DOWN_ARROW || e.keyCode == dojo.keys.ENTER || e.charOrCode == " "){
				this._onDropDownMouse(e);
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's dropdown

			this.closeDropDown();
			// don't focus on button.  the user has explicitly focused on something else.
			this.inherited(arguments);
		},

		isLoaded: function(){
			// summary:
			//		Returns whether or not the dropdown is loaded.  This can
			//		be overridden in order to force a call to loadDropDown().
			// tags:
			//		protected

			return true;
		},

		loadDropDown: function(/* Function */ loadCallback){
			// summary:
			//		Loads the data for the dropdown, and at some point, calls
			//		the given callback
			// tags:
			//		protected

			loadCallback();
		},

		toggleDropDown: function(){
			// summary:
			//		Toggle the drop-down widget; if it is up, close it, if not, open it
			// tags:
			//		protected

			if(this.disabled || this.readOnly){ return; }
			this.focus();
			var dropDown = this.dropDown;
			if(!dropDown){ return; }
			if(!this._opened){
				// If we aren't loaded, load it first so there isn't a flicker
				if(!this.isLoaded()){
					this.loadDropDown(dojo.hitch(this, "openDropDown"));
					return;
				}else{
					this.openDropDown();
				}
			}else{
				this.closeDropDown();
			}
		},

		openDropDown: function(){
			// summary:
			//		Opens the dropdown for this widget - it returns the
			//		return value of dijit.popup.open
			// tags:
			//		protected

			var dropDown = this.dropDown;
			var ddNode = dropDown.domNode;
			var self = this;

			// Prepare our popup's height and honor maxHeight if it exists.

			// TODO: isn't maxHeight dependent on the return value from dijit.popup.open(),
			// ie, dependent on how much space is available (BK)

			if(!this._preparedNode){
				dijit.popup.moveOffScreen(ddNode);
				this._preparedNode = true;			
				// Check if we have explicitly set width and height on the dropdown widget dom node
				if(ddNode.style.width){
					this._explicitDDWidth = true;
				}
				if(ddNode.style.height){
					this._explicitDDHeight = true;
				}
			}
			if(this.maxHeight || this.forceWidth || this.autoWidth){
				var myStyle = {
					display: "",
					visibility: "hidden"
				};
				if(!this._explicitDDWidth){
					myStyle.width = "";
				}
				if(!this._explicitDDHeight){
					myStyle.height = "";
				}
				dojo.style(ddNode, myStyle);
				var mb = dojo.marginBox(ddNode);
				var overHeight = (this.maxHeight && mb.h > this.maxHeight);
				dojo.style(ddNode, {overflow: overHeight ? "auto" : "hidden"});
				if(this.forceWidth){
					mb.w = this.domNode.offsetWidth;
				}else if(this.autoWidth){
					mb.w = Math.max(mb.w, this.domNode.offsetWidth);
				}else{
					delete mb.w;
				}
				if(overHeight){
					mb.h = this.maxHeight;
					if("w" in mb){
						mb.w += 16;
					}
				}else{
					delete mb.h;
				}
				delete mb.t;
				delete mb.l;
				if(dojo.isFunction(dropDown.resize)){
					dropDown.resize(mb);
				}else{
					dojo.marginBox(ddNode, mb);
				}
			}
			var retVal = dijit.popup.open({
				parent: this,
				popup: dropDown,
				around: this._aroundNode,
				orient: dijit.getPopupAroundAlignment((this.dropDownPosition && this.dropDownPosition.length) ? this.dropDownPosition : ["below"],this.isLeftToRight()),
				onExecute: function(){
					self.closeDropDown(true);
				},
				onCancel: function(){
					self.closeDropDown(true);
				},
				onClose: function(){
					dojo.attr(self._popupStateNode, "popupActive", false);
					dojo.removeClass(self._popupStateNode, "dijitHasDropDownOpen");
					self._opened = false;
					self.state = "";
				}
			});
			dojo.attr(this._popupStateNode, "popupActive", "true");
			dojo.addClass(self._popupStateNode, "dijitHasDropDownOpen");
			this._opened=true;
			this.state="Opened";
			// TODO: set this.checked and call setStateClass(), to affect button look while drop down is shown
			return retVal;
		},

		closeDropDown: function(/*Boolean*/ focus){
			// summary:
			//		Closes the drop down on this widget
			// tags:
			//		protected

			if(this._opened){
				dijit.popup.close(this.dropDown);
				if(focus){ this.focus(); }
				this._opened = false;
				this.state = "";
			}
		}

	}
);

}

if(!dojo._hasResource["dijit.form.Button"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Button"] = true;
dojo.provide("dijit.form.Button");





dojo.declare("dijit.form.Button",
	dijit.form._FormWidget,
	{
	// summary:
	//		Basically the same thing as a normal HTML button, but with special styling.
	// description:
	//		Buttons can display a label, an icon, or both.
	//		A label should always be specified (through innerHTML) or the label
	//		attribute.  It can be hidden via showLabel=false.
	// example:
	// |	<button dojoType="dijit.form.Button" onClick="...">Hello world</button>
	//
	// example:
	// |	var button1 = new dijit.form.Button({label: "hello world", onClick: foo});
	// |	dojo.body().appendChild(button1.domNode);

	// label: HTML String
	//		Text to display in button.
	//		If the label is hidden (showLabel=false) then and no title has
	//		been specified, then label is also set as title attribute of icon.
	label: "",

	// showLabel: Boolean
	//		Set this to true to hide the label text and display only the icon.
	//		(If showLabel=false then iconClass must be specified.)
	//		Especially useful for toolbars.
	//		If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
	//
	//		The exception case is for computers in high-contrast mode, where the label
	//		will still be displayed, since the icon doesn't appear.
	showLabel: true,

	// iconClass: String
	//		Class to apply to DOMNode in button to make it display an icon
	iconClass: "",

	// type: String
	//		Defines the type of button.  "button", "submit", or "reset".
	type: "button",

	baseClass: "dijitButton",

	templateString: dojo.cache("dijit.form", "templates/Button.html", "<span class=\"dijit dijitReset dijitLeft dijitInline\"\r\n\tdojoAttachEvent=\"onclick:_onButtonClick,onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\"\r\n\t><span class=\"dijitReset dijitRight dijitInline\"\r\n\t\t><span class=\"dijitReset dijitInline dijitButtonNode\"\r\n\t\t\t><button class=\"dijitReset dijitStretch dijitButtonContents\"\r\n\t\t\t\tdojoAttachPoint=\"titleNode,focusNode\"\r\n\t\t\t\t${nameAttrSetting} type=\"${type}\" value=\"${value}\" waiRole=\"button\" waiState=\"labelledby-${id}_label\"\r\n\t\t\t\t><span class=\"dijitReset dijitInline\" dojoAttachPoint=\"iconNode\"\r\n\t\t\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#10003;</span\r\n\t\t\t\t></span\r\n\t\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\r\n\t\t\t\t\tid=\"${id}_label\"\r\n\t\t\t\t\tdojoAttachPoint=\"containerNode\"\r\n\t\t\t\t></span\r\n\t\t\t></button\r\n\t\t></span\r\n\t></span\r\n></span>\r\n"),

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		label: { node: "containerNode", type: "innerHTML" },
		iconClass: { node: "iconNode", type: "class" }
	}),


	_onClick: function(/*Event*/ e){
		// summary:
		//		Internal function to handle click actions
		if(this.disabled){
			return false;
		}
		this._clicked(); // widget click actions
		return this.onClick(e); // user click actions
	},

	_onButtonClick: function(/*Event*/ e){
		// summary:
		//		Handler when the user activates the button portion.
		if(this._onClick(e) === false){ // returning nothing is same as true
			e.preventDefault(); // needed for checkbox
		}else if(this.type == "submit" && !this.focusNode.form){ // see if a nonform widget needs to be signalled
			for(var node=this.domNode; node.parentNode/*#5935*/; node=node.parentNode){
				var widget=dijit.byNode(node);
				if(widget && typeof widget._onSubmit == "function"){
					widget._onSubmit(e);
					break;
				}
			}
		}
	},

	_setValueAttr: function(/*String*/ value){
		// Verify that value cannot be set for BUTTON elements.
		var attr = this.attributeMap.value || '';
		if(this[attr.node || attr || 'domNode'].tagName == 'BUTTON'){
			// On IE, setting value actually overrides innerHTML, so disallow for everyone for consistency
			if(value != this.value){
				console.debug('Cannot change the value attribute on a Button widget.');
			}
		}
	},

	_fillContent: function(/*DomNode*/ source){
		// Overrides _Templated._fillContent().
		// If button label is specified as srcNodeRef.innerHTML rather than
		// this.params.label, handle it here.
		if(source && (!this.params || !("label" in this.params))){
			this.attr('label', source.innerHTML);
		}
	},

	postCreate: function(){
		dojo.setSelectable(this.focusNode, false);
		this.inherited(arguments);
	},

	_setShowLabelAttr: function(val){
		if(this.containerNode){
			dojo.toggleClass(this.containerNode, "dijitDisplayNone", !val);
		}
		this.showLabel = val;
	},

	onClick: function(/*Event*/ e){
		// summary:
		//		Callback for when button is clicked.
		//		If type="submit", return true to perform submit, or false to cancel it.
		// type:
		//		callback
		return true;		// Boolean
	},

	_clicked: function(/*Event*/ e){
		// summary:
		//		Internal overridable function for when the button is clicked
	},

	setLabel: function(/*String*/ content){
		// summary:
		//		Deprecated.  Use attr('label', ...) instead.
		dojo.deprecated("dijit.form.Button.setLabel() is deprecated.  Use attr('label', ...) instead.", "", "2.0");
		this.attr("label", content);
	},
	_setLabelAttr: function(/*String*/ content){
		// summary:
		//		Hook for attr('label', ...) to work.
		// description:
		//		Set the label (text) of the button; takes an HTML string.
		this.containerNode.innerHTML = this.label = content;
		if(this.showLabel == false && !this.params.title){
			this.titleNode.title = dojo.trim(this.containerNode.innerText || this.containerNode.textContent || '');
		}
	}
});


dojo.declare("dijit.form.DropDownButton", [dijit.form.Button, dijit._Container, dijit._HasDropDown], {
	// summary:
	//		A button with a drop down
	//
	// example:
	// |	<button dojoType="dijit.form.DropDownButton" label="Hello world">
	// |		<div dojotype="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.DropDownButton({ label: "hi", dropDown: new dijit.Menu(...) });
	// |	dojo.body().appendChild(button1);
	//

	baseClass : "dijitDropDownButton",

	templateString: dojo.cache("dijit.form", "templates/DropDownButton.html", "<span class=\"dijit dijitReset dijitLeft dijitInline\"\r\n\tdojoAttachPoint=\"_buttonNode\"\r\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\"\r\n\t><span class='dijitReset dijitRight dijitInline'\r\n\t\t><span class='dijitReset dijitInline dijitButtonNode'\r\n\t\t\t><button class=\"dijitReset dijitStretch dijitButtonContents\"\r\n\t\t\t\t${nameAttrSetting} type=\"${type}\" value=\"${value}\"\r\n\t\t\t\tdojoAttachPoint=\"focusNode,titleNode,_arrowWrapperNode\"\r\n\t\t\t\twaiRole=\"button\" waiState=\"haspopup-true,labelledby-${id}_label\"\r\n\t\t\t\t><span class=\"dijitReset dijitInline\"\r\n\t\t\t\t\tdojoAttachPoint=\"iconNode\"\r\n\t\t\t\t></span\r\n\t\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\r\n\t\t\t\t\tdojoAttachPoint=\"containerNode,_popupStateNode\"\r\n\t\t\t\t\tid=\"${id}_label\"\r\n\t\t\t\t></span\r\n\t\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\">&thinsp;</span\r\n\t\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\r\n\t\t\t></button\r\n\t\t></span\r\n\t></span\r\n></span>\r\n"),

	_fillContent: function(){
		// Overrides Button._fillContent().
		//
		// My inner HTML contains both the button contents and a drop down widget, like
		// <DropDownButton>  <span>push me</span>  <Menu> ... </Menu> </DropDownButton>
		// The first node is assumed to be the button content. The widget is the popup.

		if(this.srcNodeRef){ // programatically created buttons might not define srcNodeRef
			//FIXME: figure out how to filter out the widget and use all remaining nodes as button
			//	content, not just nodes[0]
			var nodes = dojo.query("*", this.srcNodeRef);
			dijit.form.DropDownButton.superclass._fillContent.call(this, nodes[0]);

			// save pointer to srcNode so we can grab the drop down widget after it's instantiated
			this.dropDownContainer = this.srcNodeRef;
		}
	},

	startup: function(){
		if(this._started){ return; }

		// the child widget from srcNodeRef is the dropdown widget.  Insert it in the page DOM,
		// make it invisible, and store a reference to pass to the popup code.
		if(!this.dropDown){
			var dropDownNode = dojo.query("[widgetId]", this.dropDownContainer)[0];
			this.dropDown = dijit.byNode(dropDownNode);
			delete this.dropDownContainer;
		}
		dijit.popup.moveOffScreen(this.dropDown.domNode);

		this.inherited(arguments);
	},

	isLoaded: function(){
		// Returns whether or not we are loaded - if our dropdown has an href,
		// then we want to check that.
		var dropDown = this.dropDown;
		return (!dropDown.href || dropDown.isLoaded);
	},

	loadDropDown: function(){
		// Loads our dropdown
		var dropDown = this.dropDown;
		if(!dropDown){ return; }
		if(!this.isLoaded()){
			var handler = dojo.connect(dropDown, "onLoad", this, function(){
				dojo.disconnect(handler);
				this.openDropDown();
			});
			dropDown.refresh();
		}else{
			this.openDropDown();
		}
	},

	isFocusable: function(){
		// Overridden so that focus is handled by the _HasDropDown mixin, not by
		// the _FormWidget mixin.
		return this.inherited(arguments) && !this._mouseDown;
	}
});

dojo.declare("dijit.form.ComboButton", dijit.form.DropDownButton, {
	// summary:
	//		A combination button and drop-down button.
	//		Users can click one side to "press" the button, or click an arrow
	//		icon to display the drop down.
	//
	// example:
	// |	<button dojoType="dijit.form.ComboButton" onClick="...">
	// |		<span>Hello world</span>
	// |		<div dojoType="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.ComboButton({label: "hello world", onClick: foo, dropDown: "myMenu"});
	// |	dojo.body().appendChild(button1.domNode);
	//

	templateString: dojo.cache("dijit.form", "templates/ComboButton.html", "<table class='dijit dijitReset dijitInline dijitLeft'\r\n\tcellspacing='0' cellpadding='0' waiRole=\"presentation\"\r\n\t><tbody waiRole=\"presentation\"><tr waiRole=\"presentation\"\r\n\t\t><td class=\"dijitReset dijitStretch dijitButtonNode\"><button id=\"${id}_button\" class=\"dijitReset dijitButtonContents\"\r\n\t\t\tdojoAttachEvent=\"onclick:_onButtonClick,onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse,onkeypress:_onButtonKeyPress\"  dojoAttachPoint=\"titleNode\"\r\n\t\t\twaiRole=\"button\" waiState=\"labelledby-${id}_label\"\r\n\t\t\t><div class=\"dijitReset dijitInline\" dojoAttachPoint=\"iconNode\" waiRole=\"presentation\"></div\r\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText\" id=\"${id}_label\" dojoAttachPoint=\"containerNode\" waiRole=\"presentation\"></div\r\n\t\t></button></td\r\n\t\t><td id=\"${id}_arrow\" class='dijitReset dijitRight dijitButtonNode dijitArrowButton'\r\n\t\t\tdojoAttachPoint=\"_popupStateNode,focusNode,_buttonNode\"\r\n\t\t\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onkeypress:_onArrowKeyPress\"\r\n\t\t\tstateModifier=\"DownArrow\"\r\n\t\t\ttitle=\"${optionsTitle}\" ${nameAttrSetting}\r\n\t\t\twaiRole=\"button\" waiState=\"haspopup-true\"\r\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" waiRole=\"presentation\">&thinsp;</div\r\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" waiRole=\"presentation\">&#9660;</div\r\n\t\t></td\r\n\t></tr></tbody\r\n></table>\r\n"),

	attributeMap: dojo.mixin(dojo.clone(dijit.form.Button.prototype.attributeMap), {
		id: "",
		tabIndex: ["focusNode", "titleNode"],
		title: "titleNode"
	}),

	// optionsTitle: String
	//		Text that describes the options menu (accessibility)
	optionsTitle: "",

	baseClass: "dijitComboButton",

	_focusedNode: null,

	postCreate: function(){
		this.inherited(arguments);
		this._focalNodes = [this.titleNode, this._popupStateNode];
		var isIE = dojo.isIE;
		dojo.forEach(this._focalNodes, dojo.hitch(this, function(node){
			this.connect(node, isIE? "onactivate" : "onfocus", this._onNodeFocus);
			this.connect(node, isIE? "ondeactivate" : "onblur", this._onNodeBlur);
		}));
		if(isIE && (isIE < 8 || dojo.isQuirks)){ // fixed in IE8/strict
			with(this.titleNode){ // resize BUTTON tag so parent TD won't inherit extra padding
				style.width = scrollWidth + "px";
				this.connect(this.titleNode, "onresize", function(){
					setTimeout( function(){ style.width = scrollWidth + "px"; }, 0);
				});
			}
		}
	},

	_onNodeFocus: function(evt){
		this._focusedNode = evt.currentTarget;
		var fnc = this._focusedNode == this.focusNode ? "dijitDownArrowButtonFocused" : "dijitButtonContentsFocused";
		dojo.addClass(this._focusedNode, fnc);
	},

	_onNodeBlur: function(evt){
		var fnc = evt.currentTarget == this.focusNode ? "dijitDownArrowButtonFocused" : "dijitButtonContentsFocused";
		dojo.removeClass(evt.currentTarget, fnc);
	},

	_onBlur: function(){
		this.inherited(arguments);
		this._focusedNode = null;
	},
	
	_onButtonKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handler for right arrow key when focus is on left part of button
		if(evt.charOrCode == dojo.keys[this.isLeftToRight() ? "RIGHT_ARROW" : "LEFT_ARROW"]){
			dijit.focus(this._popupStateNode);
			dojo.stopEvent(evt);
		}
	},

	_onArrowKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handler for left arrow key when focus is on right part of button
		if(evt.charOrCode == dojo.keys[this.isLeftToRight() ? "LEFT_ARROW" : "RIGHT_ARROW"]){
			dijit.focus(this.titleNode);
			dojo.stopEvent(evt);
		}
	},
	
	focus: function(/*String*/ position){
		// summary:
		//		Focuses this widget to according to position, if specified,
		//		otherwise on arrow node
		// position:
		//		"start" or "end"
		
		dijit.focus(position == "start" ? this.titleNode : this._popupStateNode);
	}
});

dojo.declare("dijit.form.ToggleButton", dijit.form.Button, {
	// summary:
	//		A button that can be in two states (checked or not).
	//		Can be base class for things like tabs or checkbox or radio buttons

	baseClass: "dijitToggleButton",

	// checked: Boolean
	//		Corresponds to the native HTML <input> element's attribute.
	//		In markup, specified as "checked='checked'" or just "checked".
	//		True if the button is depressed, or the checkbox is checked,
	//		or the radio button is selected, etc.
	checked: false,

	attributeMap: dojo.mixin(dojo.clone(dijit.form.Button.prototype.attributeMap), {
		checked:"focusNode"
	}),

	_clicked: function(/*Event*/ evt){
		this.attr('checked', !this.checked);
	},

	_setCheckedAttr: function(/*Boolean*/ value){
		this.checked = value;
		dojo.attr(this.focusNode || this.domNode, "checked", value);
		dijit.setWaiState(this.focusNode || this.domNode, "pressed", value);
		this._setStateClass();
		this._handleOnChange(value, true);
	},

	setChecked: function(/*Boolean*/ checked){
		// summary:
		//		Deprecated.   Use attr('checked', true/false) instead.
		dojo.deprecated("setChecked("+checked+") is deprecated. Use attr('checked',"+checked+") instead.", "", "2.0");
		this.attr('checked', checked);
	},

	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time

		this._hasBeenBlurred = false;

		// set checked state to original setting
		this.attr('checked', this.params.checked || false);
	}
});

}

if(!dojo._hasResource["dojo.i18n"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.i18n"] = true;
dojo.provide("dojo.i18n");

/*=====
dojo.i18n = {
	// summary: Utility classes to enable loading of resources for internationalization (i18n)
};
=====*/

dojo.i18n.getLocalization = function(/*String*/packageName, /*String*/bundleName, /*String?*/locale){
	//	summary:
	//		Returns an Object containing the localization for a given resource
	//		bundle in a package, matching the specified locale.
	//	description:
	//		Returns a hash containing name/value pairs in its prototypesuch
	//		that values can be easily overridden.  Throws an exception if the
	//		bundle is not found.  Bundle must have already been loaded by
	//		`dojo.requireLocalization()` or by a build optimization step.  NOTE:
	//		try not to call this method as part of an object property
	//		definition (`var foo = { bar: dojo.i18n.getLocalization() }`).  In
	//		some loading situations, the bundle may not be available in time
	//		for the object definition.  Instead, call this method inside a
	//		function that is run after all modules load or the page loads (like
	//		in `dojo.addOnLoad()`), or in a widget lifecycle method.
	//	packageName:
	//		package which is associated with this resource
	//	bundleName:
	//		the base filename of the resource bundle (without the ".js" suffix)
	//	locale:
	//		the variant to load (optional).  By default, the locale defined by
	//		the host environment: dojo.locale

	locale = dojo.i18n.normalizeLocale(locale);

	// look for nearest locale match
	var elements = locale.split('-');
	var module = [packageName,"nls",bundleName].join('.');
	var bundle = dojo._loadedModules[module];
	if(bundle){
		var localization;
		for(var i = elements.length; i > 0; i--){
			var loc = elements.slice(0, i).join('_');
			if(bundle[loc]){
				localization = bundle[loc];
				break;
			}
		}
		if(!localization){
			localization = bundle.ROOT;
		}

		// make a singleton prototype so that the caller won't accidentally change the values globally
		if(localization){
			var clazz = function(){};
			clazz.prototype = localization;
			return new clazz(); // Object
		}
	}

	throw new Error("Bundle not found: " + bundleName + " in " + packageName+" , locale=" + locale);
};

dojo.i18n.normalizeLocale = function(/*String?*/locale){
	//	summary:
	//		Returns canonical form of locale, as used by Dojo.
	//
	//  description:
	//		All variants are case-insensitive and are separated by '-' as specified in [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	//		If no locale is specified, the dojo.locale is returned.  dojo.locale is defined by
	//		the user agent's locale unless overridden by djConfig.

	var result = locale ? locale.toLowerCase() : dojo.locale;
	if(result == "root"){
		result = "ROOT";
	}
	return result; // String
};

dojo.i18n._requireLocalization = function(/*String*/moduleName, /*String*/bundleName, /*String?*/locale, /*String?*/availableFlatLocales){
	//	summary:
	//		See dojo.requireLocalization()
	//	description:
	// 		Called by the bootstrap, but factored out so that it is only
	// 		included in the build when needed.

	var targetLocale = dojo.i18n.normalizeLocale(locale);
 	var bundlePackage = [moduleName, "nls", bundleName].join(".");
	// NOTE: 
	//		When loading these resources, the packaging does not match what is
	//		on disk.  This is an implementation detail, as this is just a
	//		private data structure to hold the loaded resources.  e.g.
	//		`tests/hello/nls/en-us/salutations.js` is loaded as the object
	//		`tests.hello.nls.salutations.en_us={...}` The structure on disk is
	//		intended to be most convenient for developers and translators, but
	//		in memory it is more logical and efficient to store in a different
	//		order.  Locales cannot use dashes, since the resulting path will
	//		not evaluate as valid JS, so we translate them to underscores.
	
	//Find the best-match locale to load if we have available flat locales.
	var bestLocale = "";
	if(availableFlatLocales){
		var flatLocales = availableFlatLocales.split(",");
		for(var i = 0; i < flatLocales.length; i++){
			//Locale must match from start of string.
			//Using ["indexOf"] so customBase builds do not see
			//this as a dojo._base.array dependency.
			if(targetLocale["indexOf"](flatLocales[i]) == 0){
				if(flatLocales[i].length > bestLocale.length){
					bestLocale = flatLocales[i];
				}
			}
		}
		if(!bestLocale){
			bestLocale = "ROOT";
		}		
	}

	//See if the desired locale is already loaded.
	var tempLocale = availableFlatLocales ? bestLocale : targetLocale;
	var bundle = dojo._loadedModules[bundlePackage];
	var localizedBundle = null;
	if(bundle){
		if(dojo.config.localizationComplete && bundle._built){return;}
		var jsLoc = tempLocale.replace(/-/g, '_');
		var translationPackage = bundlePackage+"."+jsLoc;
		localizedBundle = dojo._loadedModules[translationPackage];
	}

	if(!localizedBundle){
		bundle = dojo["provide"](bundlePackage);
		var syms = dojo._getModuleSymbols(moduleName);
		var modpath = syms.concat("nls").join("/");
		var parent;

		dojo.i18n._searchLocalePath(tempLocale, availableFlatLocales, function(loc){
			var jsLoc = loc.replace(/-/g, '_');
			var translationPackage = bundlePackage + "." + jsLoc;
			var loaded = false;
			if(!dojo._loadedModules[translationPackage]){
				// Mark loaded whether it's found or not, so that further load attempts will not be made
				dojo["provide"](translationPackage);
				var module = [modpath];
				if(loc != "ROOT"){module.push(loc);}
				module.push(bundleName);
				var filespec = module.join("/") + '.js';
				loaded = dojo._loadPath(filespec, null, function(hash){
					// Use singleton with prototype to point to parent bundle, then mix-in result from loadPath
					var clazz = function(){};
					clazz.prototype = parent;
					bundle[jsLoc] = new clazz();
					for(var j in hash){ bundle[jsLoc][j] = hash[j]; }
				});
			}else{
				loaded = true;
			}
			if(loaded && bundle[jsLoc]){
				parent = bundle[jsLoc];
			}else{
				bundle[jsLoc] = parent;
			}
			
			if(availableFlatLocales){
				//Stop the locale path searching if we know the availableFlatLocales, since
				//the first call to this function will load the only bundle that is needed.
				return true;
			}
		});
	}

	//Save the best locale bundle as the target locale bundle when we know the
	//the available bundles.
	if(availableFlatLocales && targetLocale != bestLocale){
		bundle[targetLocale.replace(/-/g, '_')] = bundle[bestLocale.replace(/-/g, '_')];
	}
};

(function(){
	// If other locales are used, dojo.requireLocalization should load them as
	// well, by default. 
	// 
	// Override dojo.requireLocalization to do load the default bundle, then
	// iterate through the extraLocale list and load those translations as
	// well, unless a particular locale was requested.

	var extra = dojo.config.extraLocale;
	if(extra){
		if(!extra instanceof Array){
			extra = [extra];
		}

		var req = dojo.i18n._requireLocalization;
		dojo.i18n._requireLocalization = function(m, b, locale, availableFlatLocales){
			req(m,b,locale, availableFlatLocales);
			if(locale){return;}
			for(var i=0; i<extra.length; i++){
				req(m,b,extra[i], availableFlatLocales);
			}
		};
	}
})();

dojo.i18n._searchLocalePath = function(/*String*/locale, /*Boolean*/down, /*Function*/searchFunc){
	//	summary:
	//		A helper method to assist in searching for locale-based resources.
	//		Will iterate through the variants of a particular locale, either up
	//		or down, executing a callback function.  For example, "en-us" and
	//		true will try "en-us" followed by "en" and finally "ROOT".

	locale = dojo.i18n.normalizeLocale(locale);

	var elements = locale.split('-');
	var searchlist = [];
	for(var i = elements.length; i > 0; i--){
		searchlist.push(elements.slice(0, i).join('-'));
	}
	searchlist.push(false);
	if(down){searchlist.reverse();}

	for(var j = searchlist.length - 1; j >= 0; j--){
		var loc = searchlist[j] || "ROOT";
		var stop = searchFunc(loc);
		if(stop){ break; }
	}
};

dojo.i18n._preloadLocalizations = function(/*String*/bundlePrefix, /*Array*/localesGenerated){
	//	summary:
	//		Load built, flattened resource bundles, if available for all
	//		locales used in the page. Only called by built layer files.

	function preload(locale){
		locale = dojo.i18n.normalizeLocale(locale);
		dojo.i18n._searchLocalePath(locale, true, function(loc){
			for(var i=0; i<localesGenerated.length;i++){
				if(localesGenerated[i] == loc){
					dojo["require"](bundlePrefix+"_"+loc);
					return true; // Boolean
				}
			}
			return false; // Boolean
		});
	}
	preload();
	var extra = dojo.config.extraLocale||[];
	for(var i=0; i<extra.length; i++){
		preload(extra[i]);
	}
};

}

if(!dojo._hasResource["dijit.form.TextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.TextBox"] = true;
dojo.provide("dijit.form.TextBox");



dojo.declare(
	"dijit.form.TextBox",
	dijit.form._FormValueWidget,
	{
		// summary:
		//		A base class for textbox form inputs

		// trim: Boolean
		//		Removes leading and trailing whitespace if true.  Default is false.
		trim: false,

		// uppercase: Boolean
		//		Converts all characters to uppercase if true.  Default is false.
		uppercase: false,

		// lowercase: Boolean
		//		Converts all characters to lowercase if true.  Default is false.
		lowercase: false,

		// propercase: Boolean
		//		Converts the first character of each word to uppercase if true.
		propercase: false,

		//	maxLength: String
		//		HTML INPUT tag maxLength declaration.
		maxLength: "",

		//	selectOnClick: [const] Boolean
		//		If true, all text will be selected when focused with mouse
		selectOnClick: false,

		templateString: dojo.cache("dijit.form", "templates/TextBox.html", "<input class=\"dijit dijitReset dijitLeft\" dojoAttachPoint='textbox,focusNode'\r\n\tdojoAttachEvent='onmouseenter:_onMouse,onmouseleave:_onMouse'\r\n\tautocomplete=\"off\" type=\"${type}\" ${nameAttrSetting}\r\n\t/>\r\n"),
		baseClass: "dijitTextBox",

		attributeMap: dojo.delegate(dijit.form._FormValueWidget.prototype.attributeMap, {
			maxLength: "focusNode"
		}),

		_getValueAttr: function(){
			// summary:
			//		Hook so attr('value') works as we like.
			// description:
			//		For `dijit.form.TextBox` this basically returns the value of the <input>.
			//
			//		For `dijit.form.MappedTextBox` subclasses, which have both
			//		a "displayed value" and a separate "submit value",
			//		This treats the "displayed value" as the master value, computing the
			//		submit value from it via this.parse().
			return this.parse(this.attr('displayedValue'), this.constraints);
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so attr('value', ...) works.
			//
			// description:
			//		Sets the value of the widget to "value" which can be of
			//		any type as determined by the widget.
			//
			// value:
			//		The visual element value is also set to a corresponding,
			//		but not necessarily the same, value.
			//
			// formattedValue:
			//		If specified, used to set the visual element value,
			//		otherwise a computed visual value is used.
			//
			// priorityChange:
			//		If true, an onChange event is fired immediately instead of
			//		waiting for the next blur event.

			var filteredValue;
			if(value !== undefined){
				// TODO: this is calling filter() on both the display value and the actual value.
				// I added a comment to the filter() definition about this, but it should be changed.
				filteredValue = this.filter(value);
				if(typeof formattedValue != "string"){
					if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
						formattedValue = this.filter(this.format(filteredValue, this.constraints));
					}else{ formattedValue = ''; }
				}
			}
			if(formattedValue != null && formattedValue != undefined && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
				this.textbox.value = formattedValue;
			}
			this.inherited(arguments, [filteredValue, priorityChange]);
		},

		// displayedValue: String
		//		For subclasses like ComboBox where the displayed value
		//		(ex: Kentucky) and the serialized value (ex: KY) are different,
		//		this represents the displayed value.
		//
		//		Setting 'displayedValue' through attr('displayedValue', ...)
		//		updates 'value', and vice-versa.  Othewise 'value' is updated
		//		from 'displayedValue' periodically, like onBlur etc.
		//
		//		TODO: move declaration to MappedTextBox?
		//		Problem is that ComboBox references displayedValue,
		//		for benefit of FilteringSelect.
		displayedValue: "",

		getDisplayedValue: function(){
			// summary:
			//		Deprecated.   Use attr('displayedValue') instead.
			// tags:
			//		deprecated
			dojo.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use attr('displayedValue') instead.", "", "2.0");
			return this.attr('displayedValue');
		},

		_getDisplayedValueAttr: function(){
			// summary:
			//		Hook so attr('displayedValue') works.
			// description:
			//		Returns the displayed value (what the user sees on the screen),
			// 		after filtering (ie, trimming spaces etc.).
			//
			//		For some subclasses of TextBox (like ComboBox), the displayed value
			//		is different from the serialized value that's actually
			//		sent to the server (see dijit.form.ValidationTextBox.serialize)

			return this.filter(this.textbox.value);
		},

		setDisplayedValue: function(/*String*/value){
			// summary:
			//		Deprecated.   Use attr('displayedValue', ...) instead.
			// tags:
			//		deprecated
			dojo.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use attr('displayedValue', ...) instead.", "", "2.0");
			this.attr('displayedValue', value);
		},

		_setDisplayedValueAttr: function(/*String*/value){
			// summary:
			//		Hook so attr('displayedValue', ...) works.
			// description:
			//		Sets the value of the visual element to the string "value".
			//		The widget value is also set to a corresponding,
			//		but not necessarily the same, value.

			if(value === null || value === undefined){ value = '' }
			else if(typeof value != "string"){ value = String(value) }
			this.textbox.value = value;
			this._setValueAttr(this.attr('value'), undefined, value);
		},

		format: function(/* String */ value, /* Object */ constraints){
			// summary:
			//		Replacable function to convert a value to a properly formatted string.
			// tags:
			//		protected extension
			return ((value == null || value == undefined) ? "" : (value.toString ? value.toString() : value));
		},

		parse: function(/* String */ value, /* Object */ constraints){
			// summary:
			//		Replacable function to convert a formatted string to a value
			// tags:
			//		protected extension

			return value;	// String
		},

		_refreshState: function(){
			// summary:
			//		After the user types some characters, etc., this method is
			//		called to check the field for validity etc.  The base method
			//		in `dijit.form.TextBox` does nothing, but subclasses override.
			// tags:
			//		protected
		},

		_onInput: function(e){
			if(e && e.type && /key/i.test(e.type) && e.keyCode){
				switch(e.keyCode){
					case dojo.keys.SHIFT:
					case dojo.keys.ALT:
					case dojo.keys.CTRL:
					case dojo.keys.TAB:
						return;
				}
			}
			if(this.intermediateChanges){
				var _this = this;
				// the setTimeout allows the key to post to the widget input box
				setTimeout(function(){ _this._handleOnChange(_this.attr('value'), false); }, 0);
			}
			this._refreshState();
		},

		postCreate: function(){
			// setting the value here is needed since value="" in the template causes "undefined"
			// and setting in the DOM (instead of the JS object) helps with form reset actions
			this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values shuld be the same
			this.inherited(arguments);
			if(dojo.isMoz || dojo.isOpera){
				this.connect(this.textbox, "oninput", this._onInput);
			}else{
				this.connect(this.textbox, "onkeydown", this._onInput);
				this.connect(this.textbox, "onkeyup", this._onInput);
				this.connect(this.textbox, "onpaste", this._onInput);
				this.connect(this.textbox, "oncut", this._onInput);
			}
		},

		_blankValue: '', // if the textbox is blank, what value should be reported
		filter: function(val){
			// summary:
			//		Auto-corrections (such as trimming) that are applied to textbox
			//		value on blur or form submit.
			// description:
			//		For MappedTextBox subclasses, this is called twice
			// 			- once with the display value
			//			- once the value as set/returned by attr('value', ...)
			//		and attr('value'), ex: a Number for NumberTextBox.
			//
			//		In the latter case it does corrections like converting null to NaN.  In
			//		the former case the NumberTextBox.filter() method calls this.inherited()
			//		to execute standard trimming code in TextBox.filter().
			//
			//		TODO: break this into two methods in 2.0
			//
			// tags:
			//		protected extension
			if(val === null){ return this._blankValue; }
			if(typeof val != "string"){ return val; }
			if(this.trim){
				val = dojo.trim(val);
			}
			if(this.uppercase){
				val = val.toUpperCase();
			}
			if(this.lowercase){
				val = val.toLowerCase();
			}
			if(this.propercase){
				val = val.replace(/[^\s]+/g, function(word){
					return word.substring(0,1).toUpperCase() + word.substring(1);
				});
			}
			return val;
		},

		_setBlurValue: function(){
			this._setValueAttr(this.attr('value'), true);
		},

		_onBlur: function(e){
			if(this.disabled){ return; }
			this._setBlurValue();
			this.inherited(arguments);

			if(this._selectOnClickHandle){
				this.disconnect(this._selectOnClickHandle);
			}
			if(this.selectOnClick && dojo.isMoz){
				this.textbox.selectionStart = this.textbox.selectionEnd = undefined; // clear selection so that the next mouse click doesn't reselect
			}
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){ return; }

			// Select all text on focus via click if nothing already selected.
			// Since mouse-up will clear the selection need to defer selection until after mouse-up.
			// Don't do anything on focus by tabbing into the widgetm since there's no associated mouse-up event.
			if(this.selectOnClick && by == "mouse"){
				this._selectOnClickHandle = this.connect(this.domNode, "onmouseup", function(){
					// Only select all text on first click; otherwise users would have no way to clear
					// the selection.
					this.disconnect(this._selectOnClickHandle);

					// Check if the user selected some text manually (mouse-down, mouse-move, mouse-up)
					// and if not, then select all the text
					var textIsNotSelected;
					if(dojo.isIE){
						var range = dojo.doc.selection.createRange();
						var parent = range.parentElement();
						textIsNotSelected = parent == this.textbox && range.text.length == 0;
					}else{
						textIsNotSelected = this.textbox.selectionStart == this.textbox.selectionEnd;
					}
					if(textIsNotSelected){
						dijit.selectInputText(this.textbox);
					}
				});
			}

			this._refreshState();
			this.inherited(arguments);
		},

		reset: function(){
			// Overrides dijit._FormWidget.reset().
			// Additionally resets the displayed textbox value to ''
			this.textbox.value = '';
			this.inherited(arguments);
		}
	}
);

dijit.selectInputText = function(/*DomNode*/element, /*Number?*/ start, /*Number?*/ stop){
	// summary:
	//		Select text in the input element argument, from start (default 0), to stop (default end).

	// TODO: use functions in _editor/selection.js?
	var _window = dojo.global;
	var _document = dojo.doc;
	element = dojo.byId(element);
	if(isNaN(start)){ start = 0; }
	if(isNaN(stop)){ stop = element.value ? element.value.length : 0; }
	dijit.focus(element);
	if(_document["selection"] && dojo.body()["createTextRange"]){ // IE
		if(element.createTextRange){
			var range = element.createTextRange();
			with(range){
				collapse(true);
				moveStart("character", -99999); // move to 0
				moveStart("character", start); // delta from 0 is the correct position
				moveEnd("character", stop-start);
				select();
			}
		}
	}else if(_window["getSelection"]){
		if(element.setSelectionRange){
			element.setSelectionRange(start, stop);
		}
	}
};

}

if(!dojo._hasResource["dijit.Tooltip"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Tooltip"] = true;
dojo.provide("dijit.Tooltip");




dojo.declare(
	"dijit._MasterTooltip",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		Internal widget that holds the actual tooltip markup,
		//		which occurs once per page.
		//		Called by Tooltip widgets which are just containers to hold
		//		the markup
		// tags:
		//		protected

		// duration: Integer
		//		Milliseconds to fade in/fade out
		duration: dijit.defaultDuration,

		templateString: dojo.cache("dijit", "templates/Tooltip.html", "<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\">\r\n\t<div class=\"dijitTooltipContainer dijitTooltipContents\" dojoAttachPoint=\"containerNode\" waiRole='alert'></div>\r\n\t<div class=\"dijitTooltipConnector\"></div>\r\n</div>\r\n"),

		postCreate: function(){
			dojo.body().appendChild(this.domNode);

			this.bgIframe = new dijit.BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = dojo.fadeIn({ node: this.domNode, duration: this.duration, onEnd: dojo.hitch(this, "_onShow") });
			this.fadeOut = dojo.fadeOut({ node: this.domNode, duration: this.duration, onEnd: dojo.hitch(this, "_onHide") });

		},

		show: function(/*String*/ innerHTML, /*DomNode*/ aroundNode, /*String[]?*/ position){
			// summary:
			//		Display tooltip w/specified contents to right of specified node
			//		(To left if there's no space on the right, or if LTR==right)

			if(this.aroundNode && this.aroundNode === aroundNode){
				return;
			}

			if(this.fadeOut.status() == "playing"){
				// previous tooltip is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			this.containerNode.innerHTML=innerHTML;

			// Firefox bug. when innerHTML changes to be shorter than previous
			// one, the node size will not be updated until it moves.
			this.domNode.style.top = (this.domNode.offsetTop + 1) + "px";

			var pos = dijit.placeOnScreenAroundElement(this.domNode, aroundNode, dijit.getPopupAroundAlignment((position && position.length) ? position : dijit.Tooltip.defaultPosition, this.isLeftToRight()), dojo.hitch(this, "orient"));

			// show it
			dojo.style(this.domNode, "opacity", 0);
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;
		},

		orient: function(/* DomNode */ node, /* String */ aroundCorner, /* String */ tooltipCorner){
			// summary:
			//		Private function to set CSS for tooltip node based on which position it's in.
			//		This is called by the dijit popup code.
			// tags:
			//		protected

			node.className = "dijitTooltip " +
				{
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft"
				}[aroundCorner + "-" + tooltipCorner];
		},

		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(dojo.isIE){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},

		hide: function(aroundNode){
			// summary:
			//		Hide the tooltip
			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode){
				// this hide request is for the currently displayed tooltip
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				this.fadeOut.play();
			}else{
				// just ignore the call, it's for a tooltip that has already been erased
			}
		},

		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			this.domNode.style.cssText="";	// to position offscreen again
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		}

	}
);

dijit.showTooltip = function(/*String*/ innerHTML, /*DomNode*/ aroundNode, /*String[]?*/ position){
	// summary:
	//		Display tooltip w/specified contents in specified position.
	//		See description of dijit.Tooltip.defaultPosition for details on position parameter.
	//		If position is not specified then dijit.Tooltip.defaultPosition is used.
	if(!dijit._masterTT){ dijit._masterTT = new dijit._MasterTooltip(); }
	return dijit._masterTT.show(innerHTML, aroundNode, position);
};

dijit.hideTooltip = function(aroundNode){
	// summary:
	//		Hide the tooltip
	if(!dijit._masterTT){ dijit._masterTT = new dijit._MasterTooltip(); }
	return dijit._masterTT.hide(aroundNode);
};

dojo.declare(
	"dijit.Tooltip",
	dijit._Widget,
	{
		// summary:
		//		Pops up a tooltip (a help message) when you hover over a node.

		// label: String
		//		Text to display in the tooltip.
		//		Specified as innerHTML when creating the widget from markup.
		label: "",

		// showDelay: Integer
		//		Number of milliseconds to wait after hovering over/focusing on the object, before
		//		the tooltip is displayed.
		showDelay: 400,

		// connectId: [const] String[]
		//		Id's of domNodes to attach the tooltip to.
		//		When user hovers over any of the specified dom nodes, the tooltip will appear.
		//
		//		Note: Currently connectId can only be specified on initialization, it cannot
		//		be changed via attr('connectId', ...)
		//
		//		Note: in 2.0 this will be renamed to connectIds for less confusion.
		connectId: [],

		// position: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on position parameter.
		position: [],

		constructor: function(){
			// Map id's of nodes I'm connected to to a list of the this.connect() handles
			this._nodeConnectionsById = {};
		},

		_setConnectIdAttr: function(newIds){
			for(var oldId in this._nodeConnectionsById){
				this.removeTarget(oldId);
			}
			dojo.forEach(dojo.isArrayLike(newIds) ? newIds : [newIds], this.addTarget, this);
		},

		_getConnectIdAttr: function(){
			var ary = [];
			for(var id in this._nodeConnectionsById){
				ary.push(id);
			}
			return ary;
		},

		addTarget: function(/*DOMNODE || String*/ id){
			// summary:
			//		Attach tooltip to specified node, if it's not already connected
			var node = dojo.byId(id);
			if(!node){ return; }
			if(node.id in this._nodeConnectionsById){ return; }//Already connected

			this._nodeConnectionsById[node.id] = [
				this.connect(node, "onmouseenter", "_onTargetMouseEnter"),
				this.connect(node, "onmouseleave", "_onTargetMouseLeave"),
				this.connect(node, "onfocus", "_onTargetFocus"),
				this.connect(node, "onblur", "_onTargetBlur")
			];
			if(dojo.isIE && !node.style.zoom){//preserve zoom
				// BiDi workaround
				node.style.zoom = 1;
			}
		},

		removeTarget: function(/*DOMNODE || String*/ node){
			// summary:
			//		Detach tooltip from specified node

			// map from DOMNode back to plain id string
			var id = node.id || node;

			if(id in this._nodeConnectionsById){
				dojo.forEach(this._nodeConnectionsById[id], this.disconnect, this);
				delete this._nodeConnectionsById[id];
			}
		},

		postCreate: function(){
			dojo.addClass(this.domNode,"dijitTooltipData");
		},

		startup: function(){
			this.inherited(arguments);

			// If this tooltip was created in a template, or for some other reason the specified connectId[s]
			// didn't exist during the widget's initialization, then connect now.
			var ids = this.connectId;
			dojo.forEach(dojo.isArrayLike(ids) ? ids : [ids], this.addTarget, this);
		},

		_onTargetMouseEnter: function(/*Event*/ e){
			// summary:
			//		Handler for mouseenter event on the target node
			// tags:
			//		private
			this._onHover(e);
		},

		_onTargetMouseLeave: function(/*Event*/ e){
			// summary:
			//		Handler for mouseleave event on the target node
			// tags:
			//		private
			this._onUnHover(e);
		},

		_onTargetFocus: function(/*Event*/ e){
			// summary:
			//		Handler for focus event on the target node
			// tags:
			//		private

			this._focus = true;
			this._onHover(e);
		},

		_onTargetBlur: function(/*Event*/ e){
			// summary:
			//		Handler for blur event on the target node
			// tags:
			//		private

			this._focus = false;
			this._onUnHover(e);
		},

		_onHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both hover and focus
			//		events on the target node, setting a timer to show the tooltip.
			// tags:
			//		private
			if(!this._showTimer){
				var target = e.target;
				this._showTimer = setTimeout(dojo.hitch(this, function(){this.open(target)}), this.showDelay);
			}
		},

		_onUnHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both mouseleave and blur
			//		events on the target node, hiding the tooltip.
			// tags:
			//		private

			// keep a tooltip open if the associated element still has focus (even though the
			// mouse moved away)
			if(this._focus){ return; }

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			this.close();
		},

		open: function(/*DomNode*/ target){
 			// summary:
			//		Display the tooltip; usually not called directly.
			// tags:
			//		private

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			dijit.showTooltip(this.label || this.domNode.innerHTML, target, this.position);

			this._connectNode = target;
			this.onShow(target, this.position);
		},

		close: function(){
			// summary:
			//		Hide the tooltip or cancel timer for show of tooltip
			// tags:
			//		private

			if(this._connectNode){
				// if tooltip is currently shown
				dijit.hideTooltip(this._connectNode);
				delete this._connectNode;
				this.onHide();
			}
			if(this._showTimer){
				// if tooltip is scheduled to be shown (after a brief delay)
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
		},

		onShow: function(target, position){
			// summary:
			//		Called when the tooltip is shown
			// tags:
			//		callback
		},

		onHide: function(){
			// summary:
			//		Called when the tooltip is hidden
			// tags:
			//		callback
		},

		uninitialize: function(){
			this.close();
			this.inherited(arguments);
		}
	}
);

// dijit.Tooltip.defaultPosition: String[]
//		This variable controls the position of tooltips, if the position is not specified to
//		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the following values:
//
//			* before: places tooltip to the left of the target node/widget, or to the right in
//			  the case of RTL scripts like Hebrew and Arabic
//			* after: places tooltip to the right of the target node/widget, or to the left in
//			  the case of RTL scripts like Hebrew and Arabic
//			* above: tooltip goes above target node
//			* below: tooltip goes below target node
//
//		The list is positions is tried, in order, until a position is found where the tooltip fits
//		within the viewport.
//
//		Be careful setting this parameter.  A value of "above" may work fine until the user scrolls
//		the screen so that there's no room above the target node.   Nodes with drop downs, like
//		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
//		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
//		is only room below (or above) the target node, but not both.
dijit.Tooltip.defaultPosition = ["after", "before"];

}

if(!dojo._hasResource["dijit.form.ValidationTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ValidationTextBox"] = true;
dojo.provide("dijit.form.ValidationTextBox");








/*=====
	dijit.form.ValidationTextBox.__Constraints = function(){
		// locale: String
		//		locale used for validation, picks up value from this widget's lang attribute
		// _flags_: anything
		//		various flags passed to regExpGen function
		this.locale = "";
		this._flags_ = "";
	}
=====*/

dojo.declare(
	"dijit.form.ValidationTextBox",
	dijit.form.TextBox,
	{
		// summary:
		//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.
		// tags:
		//		protected

		templateString: dojo.cache("dijit.form", "templates/ValidationTextBox.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\r\n\tid=\"widget_${id}\"\r\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\" waiRole=\"presentation\"\r\n\t><div style=\"overflow:hidden;\"\r\n\t\t><div class=\"dijitReset dijitValidationIcon\"><br></div\r\n\t\t><div class=\"dijitReset dijitValidationIconText\">&Chi;</div\r\n\t\t><div class=\"dijitReset dijitInputField\"\r\n\t\t\t><input class=\"dijitReset\" dojoAttachPoint='textbox,focusNode' autocomplete=\"off\"\r\n\t\t\t${nameAttrSetting} type='${type}'\r\n\t\t/></div\r\n\t></div\r\n></div>\r\n"),
		baseClass: "dijitTextBox",

		// required: Boolean
		//		User is required to enter data into this field.
		required: false,

		// promptMessage: String
		//		If defined, display this hint string immediately on focus to the textbox, if empty.
		//		Think of this like a tooltip that tells the user what to do, not an error message
		//		that tells the user what they've done wrong.
		//
		//		Message disappears when user starts typing.
		promptMessage: "",

		// invalidMessage: String
		// 		The message to display if value is invalid.
		invalidMessage: "$_unset_$", // read from the message file if not overridden

		// constraints: dijit.form.ValidationTextBox.__Constraints
		//		user-defined object needed to pass parameters to the validator functions
		constraints: {},

		// regExp: [extension protected] String
		//		regular expression string used to validate the input
		//		Do not specify both regExp and regExpGen
		regExp: ".*",

		regExpGen: function(/*dijit.form.ValidationTextBox.__Constraints*/constraints){
			// summary:
			//		Overridable function used to generate regExp when dependent on constraints.
			//		Do not specify both regExp and regExpGen.
			// tags:
			//		extension protected
			return this.regExp; // String
		},

		// state: [readonly] String
		//		Shows current state (ie, validation result) of input (Normal, Warning, or Error)
		state: "",

		// tooltipPosition: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		_setValueAttr: function(){
			// summary:
			//		Hook so attr('value', ...) works.
			this.inherited(arguments);
			this.validate(this._focused);
		},

		validator: function(/*anything*/value, /*dijit.form.ValidationTextBox.__Constraints*/constraints){
			// summary:
			//		Overridable function used to validate the text input against the regular expression.
			// tags:
			//		protected
			return (new RegExp("^(?:" + this.regExpGen(constraints) + ")"+(this.required?"":"?")+"$")).test(value) &&
				(!this.required || !this._isEmpty(value)) &&
				(this._isEmpty(value) || this.parse(value, constraints) !== undefined); // Boolean
		},

		_isValidSubset: function(){
			// summary:
			//		Returns true if the value is either already valid or could be made valid by appending characters.
			//		This is used for validation while the user [may be] still typing.
			return this.textbox.value.search(this._partialre) == 0;
		},

		isValid: function(/*Boolean*/ isFocused){
			// summary:
			//		Tests if value is valid.
			//		Can override with your own routine in a subclass.
			// tags:
			//		protected
			return this.validator(this.textbox.value, this.constraints);
		},

		_isEmpty: function(value){
			// summary:
			//		Checks for whitespace
			return /^\s*$/.test(value); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// summary:
			//		Return an error message to show if appropriate
			// tags:
			//		protected
			return this.invalidMessage; // String
		},

		getPromptMessage: function(/*Boolean*/ isFocused){
			// summary:
			//		Return a hint message to show when widget is first focused
			// tags:
			//		protected
			return this.promptMessage; // String
		},

		_maskValidSubsetError: true,
		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress.
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			// tags:
			//		protected
			var message = "";
			var isValid = this.disabled || this.isValid(isFocused);
			if(isValid){ this._maskValidSubsetError = true; }
			var isValidSubset = !isValid && isFocused && this._isValidSubset();
			var isEmpty = this._isEmpty(this.textbox.value);
			if(isEmpty){ this._maskValidSubsetError = true; }
			this.state = (isValid || (!this._hasBeenBlurred && isEmpty) || isValidSubset) ? "" : "Error";
			if(this.state == "Error"){ this._maskValidSubsetError = false; }
			this._setStateClass();
			dijit.setWaiState(this.focusNode, "invalid", isValid ? "false" : "true");
			if(isFocused){
				if(isEmpty){
					message = this.getPromptMessage(true);
				}
				if(!message && (this.state == "Error" || (isValidSubset && !this._maskValidSubsetError))){
					message = this.getErrorMessage(true);
				}
			}
			this.displayMessage(message);
			return isValid;
		},

		// _message: String
		//		Currently displayed message
		_message: "",

		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a tooltip.
			// tags:
			//		extension
			if(this._message == message){ return; }
			this._message = message;
			dijit.hideTooltip(this.domNode);
			if(message){
				dijit.showTooltip(message, this.domNode, this.tooltipPosition);
			}
		},

		_refreshState: function(){
			// Overrides TextBox._refreshState()
			this.validate(this._focused);
			this.inherited(arguments);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.constraints = {};
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this.constraints.locale = this.lang;
			this.messages = dojo.i18n.getLocalization("dijit.form", "validate", this.lang);
			if(this.invalidMessage == "$_unset_$"){ this.invalidMessage = this.messages.invalidMessage; }
			var p = this.regExpGen(this.constraints);
			this.regExp = p;
			var partialre = "";
			// parse the regexp and produce a new regexp that matches valid subsets
			// if the regexp is .* then there's no use in matching subsets since everything is valid
			if(p != ".*"){ this.regExp.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g,
				function (re){
					switch(re.charAt(0)){
						case '{':
						case '+':
						case '?':
						case '*':
						case '^':
						case '$':
						case '|':
						case '(':
							partialre += re;
							break;
						case ")":
							partialre += "|$)";
							break;
						 default:
							partialre += "(?:"+re+"|$)";
							break;
					}
				}
			);}
			try{ // this is needed for now since the above regexp parsing needs more test verification
				"".search(partialre);
			}catch(e){ // should never be here unless the original RE is bad or the parsing is bad
				partialre = this.regExp;
				console.warn('RegExp error in ' + this.declaredClass + ': ' + this.regExp);
			} // should never be here unless the original RE is bad or the parsing is bad
			this._partialre = "^(?:" + partialre + ")$";
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);	// call FormValueWidget._setDisabledAttr()
			this._refreshState();
		},

		_setRequiredAttr: function(/*Boolean*/ value){
			this.required = value;
			dijit.setWaiState(this.focusNode,"required", value);
			this._refreshState();
		},

		postCreate: function(){
			if(dojo.isIE){ // IE INPUT tag fontFamily has to be set directly using STYLE
				var s = dojo.getComputedStyle(this.focusNode);
				if(s){
					var ff = s.fontFamily;
					if(ff){
						this.focusNode.style.fontFamily = ff;
					}
				}
			}
			this.inherited(arguments);
		},

		reset:function(){
			// Overrides dijit.form.TextBox.reset() by also
			// hiding errors about partial matches
			this._maskValidSubsetError = true;
			this.inherited(arguments);
		},

		_onBlur: function(){
			this.displayMessage('');
			this.inherited(arguments);
		}
	}
);

dojo.declare(
	"dijit.form.MappedTextBox",
	dijit.form.ValidationTextBox,
	{
		// summary:
		//		A dijit.form.ValidationTextBox subclass which provides a base class for widgets that have
		//		a visible formatted display value, and a serializable
		//		value in a hidden input field which is actually sent to the server.
		// description:
		//		The visible display may
		//		be locale-dependent and interactive.  The value sent to the server is stored in a hidden
		//		input field which uses the `name` attribute declared by the original widget.  That value sent
		//		to the server is defined by the dijit.form.MappedTextBox.serialize method and is typically
		//		locale-neutral.
		// tags:
		//		protected

		postMixInProperties: function(){
			this.inherited(arguments);

			// we want the name attribute to go to the hidden <input>, not the displayed <input>,
			// so override _FormWidget.postMixInProperties() setting of nameAttrSetting
			this.nameAttrSetting = "";
		},

		serialize: function(/*anything*/val, /*Object?*/options){
			// summary:
			//		Overridable function used to convert the attr('value') result to a canonical
			//		(non-localized) string.  For example, will print dates in ISO format, and
			//		numbers the same way as they are represented in javascript.
			// tags:
			//		protected extension
			return val.toString ? val.toString() : ""; // String
		},

		toString: function(){
			// summary:
			//		Returns widget as a printable string using the widget's value
			// tags:
			//		protected
			var val = this.filter(this.attr('value')); // call filter in case value is nonstring and filter has been customized
			return val != null ? (typeof val == "string" ? val : this.serialize(val, this.constraints)) : ""; // String
		},

		validate: function(){
			// Overrides `dijit.form.TextBox.validate`
			this.valueNode.value = this.toString();
			return this.inherited(arguments);
		},

		buildRendering: function(){
			// Overrides `dijit._Templated.buildRendering`

			this.inherited(arguments);

			// Create a hidden <input> node with the serialized value used for submit
			// (as opposed to the displayed value).
			// Passing in name as markup rather than calling dojo.create() with an attrs argument
			// to make dojo.query(input[name=...]) work on IE. (see #8660)
			this.valueNode = dojo.place("<input type='hidden'" + (this.name ? " name='" + this.name + "'" : "") + ">", this.textbox, "after");
		},

		reset:function(){
			// Overrides `dijit.form.ValidationTextBox.reset` to
			// reset the hidden textbox value to ''
			this.valueNode.value = '';
			this.inherited(arguments);
		}
	}
);

/*=====
	dijit.form.RangeBoundTextBox.__Constraints = function(){
		// min: Number
		//		Minimum signed value.  Default is -Infinity
		// max: Number
		//		Maximum signed value.  Default is +Infinity
		this.min = min;
		this.max = max;
	}
=====*/

dojo.declare(
	"dijit.form.RangeBoundTextBox",
	dijit.form.MappedTextBox,
	{
		// summary:
		//		Base class for textbox form widgets which defines a range of valid values.

		// rangeMessage: String
		//		The message to display if value is out-of-range
		rangeMessage: "",

		/*=====
		// constraints: dijit.form.RangeBoundTextBox.__Constraints
		constraints: {},
		======*/

		rangeCheck: function(/*Number*/ primitive, /*dijit.form.RangeBoundTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the range of the numeric input value.
			// tags:
			//		protected
			return	("min" in constraints? (this.compare(primitive,constraints.min) >= 0) : true) &&
				("max" in constraints? (this.compare(primitive,constraints.max) <= 0) : true); // Boolean
		},

		isInRange: function(/*Boolean*/ isFocused){
			// summary:
			//		Tests if the value is in the min/max range specified in constraints
			// tags:
			//		protected
			return this.rangeCheck(this.attr('value'), this.constraints);
		},

		_isDefinitelyOutOfRange: function(){
			// summary:
			//		Returns true if the value is out of range and will remain
			//		out of range even if the user types more characters
			var val = this.attr('value');
			var isTooLittle = false;
			var isTooMuch = false;
			if("min" in this.constraints){
				var min = this.constraints.min;
				min = this.compare(val, ((typeof min == "number") && min >= 0 && val !=0) ? 0 : min);
				isTooLittle = (typeof min == "number") && min < 0;
			}
			if("max" in this.constraints){
				var max = this.constraints.max;
				max = this.compare(val, ((typeof max != "number") || max > 0) ? max : 0);
				isTooMuch = (typeof max == "number") && max > 0;
			}
			return isTooLittle || isTooMuch;
		},

		_isValidSubset: function(){
			// summary:
			//		Overrides `dijit.form.ValidationTextBox._isValidSubset`.
			//		Returns true if the input is syntactically valid, and either within
			//		range or could be made in range by more typing.
			return this.inherited(arguments) && !this._isDefinitelyOutOfRange();
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.isValid to check that the value is also in range.
			return this.inherited(arguments) &&
				((this._isEmpty(this.textbox.value) && !this.required) || this.isInRange(isFocused)); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.getErrorMessage to print "out of range" message if appropriate
			var v = this.attr('value');
			if(v !== null && v !== '' && v !== undefined && !this.isInRange(isFocused)){ // don't check isInRange w/o a real value
				return this.rangeMessage; // String
			}
			return this.inherited(arguments);
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			if(!this.rangeMessage){
				this.messages = dojo.i18n.getLocalization("dijit.form", "validate", this.lang);
				this.rangeMessage = this.messages.rangeMessage;
			}
		},

		postCreate: function(){
			this.inherited(arguments);
			if(this.constraints.min !== undefined){
				dijit.setWaiState(this.focusNode, "valuemin", this.constraints.min);
			}
			if(this.constraints.max !== undefined){
				dijit.setWaiState(this.focusNode, "valuemax", this.constraints.max);
			}
		},

		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so attr('value', ...) works.

			dijit.setWaiState(this.focusNode, "valuenow", value);
			this.inherited(arguments);
		}
	}
);

}

if(!dojo._hasResource["dojo.cldr.supplemental"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cldr.supplemental"] = true;
dojo.provide("dojo.cldr.supplemental");



dojo.cldr.supplemental.getFirstDayOfWeek = function(/*String?*/locale){
// summary: Returns a zero-based index for first day of the week
// description:
//		Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
//		e.g. Sunday (returns 0), or Monday (returns 1)

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/firstDay
	var firstDay = {/*default is 1=Monday*/
		mv:5,
		ae:6,af:6,bh:6,dj:6,dz:6,eg:6,er:6,et:6,iq:6,ir:6,jo:6,ke:6,kw:6,lb:6,ly:6,ma:6,om:6,qa:6,sa:6,
		sd:6,so:6,tn:6,ye:6,
		as:0,au:0,az:0,bw:0,ca:0,cn:0,fo:0,ge:0,gl:0,gu:0,hk:0,ie:0,il:0,is:0,jm:0,jp:0,kg:0,kr:0,la:0,
		mh:0,mo:0,mp:0,mt:0,nz:0,ph:0,pk:0,sg:0,th:0,tt:0,tw:0,um:0,us:0,uz:0,vi:0,za:0,zw:0,
		et:0,mw:0,ng:0,tj:0,
// variant. do not use?		gb:0,
		sy:4
	};

	var country = dojo.cldr.supplemental._region(locale);
	var dow = firstDay[country];
	return (dow === undefined) ? 1 : dow; /*Number*/
};

dojo.cldr.supplemental._region = function(/*String?*/locale){
	locale = dojo.i18n.normalizeLocale(locale);
	var tags = locale.split('-');
	var region = tags[1];
	if(!region){
		// IE often gives language only (#2269)
		// Arbitrary mappings of language-only locales to a country:
		region = {de:"de", en:"us", es:"es", fi:"fi", fr:"fr", he:"il", hu:"hu", it:"it",
			ja:"jp", ko:"kr", nl:"nl", pt:"br", sv:"se", zh:"cn"}[tags[0]];
	}else if(region.length == 4){
		// The ISO 3166 country code is usually in the second position, unless a
		// 4-letter script is given. See http://www.ietf.org/rfc/rfc4646.txt
		region = tags[2];
	}
	return region;
}

dojo.cldr.supplemental.getWeekend = function(/*String?*/locale){
// summary: Returns a hash containing the start and end days of the weekend
// description:
//		Returns a hash containing the start and end days of the weekend according to local custom using locale,
//		or by default in the user's locale.
//		e.g. {start:6, end:0}

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/weekend{Start,End}
	var weekendStart = {/*default is 6=Saturday*/
		eg:5,il:5,sy:5,
		'in':0,
		ae:4,bh:4,dz:4,iq:4,jo:4,kw:4,lb:4,ly:4,ma:4,om:4,qa:4,sa:4,sd:4,tn:4,ye:4		
	};

	var weekendEnd = {/*default is 0=Sunday*/
		ae:5,bh:5,dz:5,iq:5,jo:5,kw:5,lb:5,ly:5,ma:5,om:5,qa:5,sa:5,sd:5,tn:5,ye:5,af:5,ir:5,
		eg:6,il:6,sy:6
	};

	var country = dojo.cldr.supplemental._region(locale);
	var start = weekendStart[country];
	var end = weekendEnd[country];
	if(start === undefined){start=6;}
	if(end === undefined){end=0;}
	return {start:start, end:end}; /*Object {start,end}*/
};

}

if(!dojo._hasResource["dojo.date"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date"] = true;
dojo.provide("dojo.date");

/*=====
dojo.date = {
	// summary: Date manipulation utilities
}
=====*/

dojo.date.getDaysInMonth = function(/*Date*/dateObject){
	//	summary:
	//		Returns the number of days in the month used by dateObject
	var month = dateObject.getMonth();
	var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	if(month == 1 && dojo.date.isLeapYear(dateObject)){ return 29; } // Number
	return days[month]; // Number
}

dojo.date.isLeapYear = function(/*Date*/dateObject){
	//	summary:
	//		Determines if the year of the dateObject is a leap year
	//	description:
	//		Leap years are years with an additional day YYYY-02-29, where the
	//		year number is a multiple of four with the following exception: If
	//		a year is a multiple of 100, then it is only a leap year if it is
	//		also a multiple of 400. For example, 1900 was not a leap year, but
	//		2000 is one.

	var year = dateObject.getFullYear();
	return !(year%400) || (!(year%4) && !!(year%100)); // Boolean
}

// FIXME: This is not localized
dojo.date.getTimezoneName = function(/*Date*/dateObject){
	//	summary:
	//		Get the user's time zone as provided by the browser
	// dateObject:
	//		Needed because the timezone may vary with time (daylight savings)
	//	description:
	//		Try to get time zone info from toString or toLocaleString method of
	//		the Date object -- UTC offset is not a time zone.  See
	//		http://www.twinsun.com/tz/tz-link.htm Note: results may be
	//		inconsistent across browsers.

	var str = dateObject.toString(); // Start looking in toString
	var tz = ''; // The result -- return empty string if nothing found
	var match;

	// First look for something in parentheses -- fast lookup, no regex
	var pos = str.indexOf('(');
	if(pos > -1){
		tz = str.substring(++pos, str.indexOf(')'));
	}else{
		// If at first you don't succeed ...
		// If IE knows about the TZ, it appears before the year
		// Capital letters or slash before a 4-digit year 
		// at the end of string
		var pat = /([A-Z\/]+) \d{4}$/;
		if((match = str.match(pat))){
			tz = match[1];
		}else{
		// Some browsers (e.g. Safari) glue the TZ on the end
		// of toLocaleString instead of putting it in toString
			str = dateObject.toLocaleString();
			// Capital letters or slash -- end of string, 
			// after space
			pat = / ([A-Z\/]+)$/;
			if((match = str.match(pat))){
				tz = match[1];
			}
		}
	}

	// Make sure it doesn't somehow end up return AM or PM
	return (tz == 'AM' || tz == 'PM') ? '' : tz; // String
}

// Utility methods to do arithmetic calculations with Dates

dojo.date.compare = function(/*Date*/date1, /*Date?*/date2, /*String?*/portion){
	//	summary:
	//		Compare two date objects by date, time, or both.
	//	description:
	//  	Returns 0 if equal, positive if a > b, else negative.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	portion:
	//		A string indicating the "date" or "time" portion of a Date object.
	//		Compares both "date" and "time" by default.  One of the following:
	//		"date", "time", "datetime"

	// Extra step required in copy for IE - see #3112
	date1 = new Date(+date1);
	date2 = new Date(+(date2 || new Date()));

	if(portion == "date"){
		// Ignore times and compare dates.
		date1.setHours(0, 0, 0, 0);
		date2.setHours(0, 0, 0, 0);
	}else if(portion == "time"){
		// Ignore dates and compare times.
		date1.setFullYear(0, 0, 0);
		date2.setFullYear(0, 0, 0);
	}
	
	if(date1 > date2){ return 1; } // int
	if(date1 < date2){ return -1; } // int
	return 0; // int
};

dojo.date.add = function(/*Date*/date, /*String*/interval, /*int*/amount){
	//	summary:
	//		Add to a Date in intervals of different size, from milliseconds to years
	//	date: Date
	//		Date object to start with
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//	amount:
	//		How much to add to the date.

	var sum = new Date(+date); // convert to Number before copying to accomodate IE (#3112)
	var fixOvershoot = false;
	var property = "Date";

	switch(interval){
		case "day":
			break;
		case "weekday":
			//i18n FIXME: assumes Saturday/Sunday weekend, but this is not always true.  see dojo.cldr.supplemental

			// Divide the increment time span into weekspans plus leftover days
			// e.g., 8 days is one 5-day weekspan / and two leftover days
			// Can't have zero leftover days, so numbers divisible by 5 get
			// a days value of 5, and the remaining days make up the number of weeks
			var days, weeks;
			var mod = amount % 5;
			if(!mod){
				days = (amount > 0) ? 5 : -5;
				weeks = (amount > 0) ? ((amount-5)/5) : ((amount+5)/5);
			}else{
				days = mod;
				weeks = parseInt(amount/5);
			}
			// Get weekday value for orig date param
			var strt = date.getDay();
			// Orig date is Sat / positive incrementer
			// Jump over Sun
			var adj = 0;
			if(strt == 6 && amount > 0){
				adj = 1;
			}else if(strt == 0 && amount < 0){
			// Orig date is Sun / negative incrementer
			// Jump back over Sat
				adj = -1;
			}
			// Get weekday val for the new date
			var trgt = strt + days;
			// New date is on Sat or Sun
			if(trgt == 0 || trgt == 6){
				adj = (amount > 0) ? 2 : -2;
			}
			// Increment by number of weeks plus leftover days plus
			// weekend adjustments
			amount = (7 * weeks) + days + adj;
			break;
		case "year":
			property = "FullYear";
			// Keep increment/decrement from 2/29 out of March
			fixOvershoot = true;
			break;
		case "week":
			amount *= 7;
			break;
		case "quarter":
			// Naive quarter is just three months
			amount *= 3;
			// fallthrough...
		case "month":
			// Reset to last day of month if you overshoot
			fixOvershoot = true;
			property = "Month";
			break;
//		case "hour":
//		case "minute":
//		case "second":
//		case "millisecond":
		default:
			property = "UTC"+interval.charAt(0).toUpperCase() + interval.substring(1) + "s";
	}

	if(property){
		sum["set"+property](sum["get"+property]()+amount);
	}

	if(fixOvershoot && (sum.getDate() < date.getDate())){
		sum.setDate(0);
	}

	return sum; // Date
};

dojo.date.difference = function(/*Date*/date1, /*Date?*/date2, /*String?*/interval){
	//	summary:
	//		Get the difference in a specific unit of time (e.g., number of
	//		months, weeks, days, etc.) between two dates, rounded to the
	//		nearest integer.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//		Defaults to "day".

	date2 = date2 || new Date();
	interval = interval || "day";
	var yearDiff = date2.getFullYear() - date1.getFullYear();
	var delta = 1; // Integer return value

	switch(interval){
		case "quarter":
			var m1 = date1.getMonth();
			var m2 = date2.getMonth();
			// Figure out which quarter the months are in
			var q1 = Math.floor(m1/3) + 1;
			var q2 = Math.floor(m2/3) + 1;
			// Add quarters for any year difference between the dates
			q2 += (yearDiff * 4);
			delta = q2 - q1;
			break;
		case "weekday":
			var days = Math.round(dojo.date.difference(date1, date2, "day"));
			var weeks = parseInt(dojo.date.difference(date1, date2, "week"));
			var mod = days % 7;

			// Even number of weeks
			if(mod == 0){
				days = weeks*5;
			}else{
				// Weeks plus spare change (< 7 days)
				var adj = 0;
				var aDay = date1.getDay();
				var bDay = date2.getDay();

				weeks = parseInt(days/7);
				mod = days % 7;
				// Mark the date advanced by the number of
				// round weeks (may be zero)
				var dtMark = new Date(date1);
				dtMark.setDate(dtMark.getDate()+(weeks*7));
				var dayMark = dtMark.getDay();

				// Spare change days -- 6 or less
				if(days > 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = -1;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 0;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = -1;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = -2;
							break;
						// Range contains weekend
						case (dayMark + mod) > 5:
							adj = -2;
					}
				}else if(days < 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = 0;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 1;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = 2;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = 1;
							break;
						// Range contains weekend
						case (dayMark + mod) < 0:
							adj = 2;
					}
				}
				days += adj;
				days -= (weeks*2);
			}
			delta = days;
			break;
		case "year":
			delta = yearDiff;
			break;
		case "month":
			delta = (date2.getMonth() - date1.getMonth()) + (yearDiff * 12);
			break;
		case "week":
			// Truncate instead of rounding
			// Don't use Math.floor -- value may be negative
			delta = parseInt(dojo.date.difference(date1, date2, "day")/7);
			break;
		case "day":
			delta /= 24;
			// fallthrough
		case "hour":
			delta /= 60;
			// fallthrough
		case "minute":
			delta /= 60;
			// fallthrough
		case "second":
			delta /= 1000;
			// fallthrough
		case "millisecond":
			delta *= date2.getTime() - date1.getTime();
	}

	// Round for fractional values and DST leaps
	return Math.round(delta); // Number (integer)
};

}

if(!dojo._hasResource["dojo.regexp"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.regexp"] = true;
dojo.provide("dojo.regexp");

/*=====
dojo.regexp = {
	// summary: Regular expressions and Builder resources
};
=====*/

dojo.regexp.escapeString = function(/*String*/str, /*String?*/except){
	//	summary:
	//		Adds escape sequences for special characters in regular expressions
	// except:
	//		a String with special characters to be left unescaped

	return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(ch){
		if(except && except.indexOf(ch) != -1){
			return ch;
		}
		return "\\" + ch;
	}); // String
}

dojo.regexp.buildGroupRE = function(/*Object|Array*/arr, /*Function*/re, /*Boolean?*/nonCapture){
	//	summary:
	//		Builds a regular expression that groups subexpressions
	//	description:
	//		A utility function used by some of the RE generators. The
	//		subexpressions are constructed by the function, re, in the second
	//		parameter.  re builds one subexpression for each elem in the array
	//		a, in the first parameter. Returns a string for a regular
	//		expression that groups all the subexpressions.
	// arr:
	//		A single value or an array of values.
	// re:
	//		A function. Takes one parameter and converts it to a regular
	//		expression. 
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression. Defaults to false

	// case 1: a is a single value.
	if(!(arr instanceof Array)){
		return re(arr); // String
	}

	// case 2: a is an array
	var b = [];
	for(var i = 0; i < arr.length; i++){
		// convert each elem to a RE
		b.push(re(arr[i]));
	}

	 // join the REs as alternatives in a RE group.
	return dojo.regexp.group(b.join("|"), nonCapture); // String
}

dojo.regexp.group = function(/*String*/expression, /*Boolean?*/nonCapture){
	// summary:
	//		adds group match to expression
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression. 
	return "(" + (nonCapture ? "?:":"") + expression + ")"; // String
}

}

if(!dojo._hasResource["dojo.date.locale"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date.locale"] = true;
dojo.provide("dojo.date.locale");

// Localization methods for Date.   Honor local customs using locale-dependent dojo.cldr data.







// Load the bundles containing localization information for
// names and formats


//NOTE: Everything in this module assumes Gregorian calendars.
// Other calendars will be implemented in separate modules.

(function(){
	// Format a pattern without literals
	function formatPattern(dateObject, bundle, options, pattern){
		return pattern.replace(/([a-z])\1*/ig, function(match){
			var s, pad,
				c = match.charAt(0),
				l = match.length,
				widthList = ["abbr", "wide", "narrow"];
			switch(c){
				case 'G':
					s = bundle[(l < 4) ? "eraAbbr" : "eraNames"][dateObject.getFullYear() < 0 ? 0 : 1];
					break;
				case 'y':
					s = dateObject.getFullYear();
					switch(l){
						case 1:
							break;
						case 2:
							if(!options.fullYear){
								s = String(s); s = s.substr(s.length - 2);
								break;
							}
							// fallthrough
						default:
							pad = true;
					}
					break;
				case 'Q':
				case 'q':
					s = Math.ceil((dateObject.getMonth()+1)/3);
//					switch(l){
//						case 1: case 2:
							pad = true;
//							break;
//						case 3: case 4: // unimplemented
//					}
					break;
				case 'M':
					var m = dateObject.getMonth();
					if(l<3){
						s = m+1; pad = true;
					}else{
						var propM = ["months", "format", widthList[l-3]].join("-");
						s = bundle[propM][m];
					}
					break;
				case 'w':
					var firstDay = 0;
					s = dojo.date.locale._getWeekOfYear(dateObject, firstDay); pad = true;
					break;
				case 'd':
					s = dateObject.getDate(); pad = true;
					break;
				case 'D':
					s = dojo.date.locale._getDayOfYear(dateObject); pad = true;
					break;
				case 'E':
					var d = dateObject.getDay();
					if(l<3){
						s = d+1; pad = true;
					}else{
						var propD = ["days", "format", widthList[l-3]].join("-");
						s = bundle[propD][d];
					}
					break;
				case 'a':
					var timePeriod = (dateObject.getHours() < 12) ? 'am' : 'pm';
					s = bundle[timePeriod];
					break;
				case 'h':
				case 'H':
				case 'K':
				case 'k':
					var h = dateObject.getHours();
					// strange choices in the date format make it impossible to write this succinctly
					switch (c){
						case 'h': // 1-12
							s = (h % 12) || 12;
							break;
						case 'H': // 0-23
							s = h;
							break;
						case 'K': // 0-11
							s = (h % 12);
							break;
						case 'k': // 1-24
							s = h || 24;
							break;
					}
					pad = true;
					break;
				case 'm':
					s = dateObject.getMinutes(); pad = true;
					break;
				case 's':
					s = dateObject.getSeconds(); pad = true;
					break;
				case 'S':
					s = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3)); pad = true;
					break;
				case 'v': // FIXME: don't know what this is. seems to be same as z?
				case 'z':
					// We only have one timezone to offer; the one from the browser
					s = dojo.date.locale._getZone(dateObject, true, options);
					if(s){break;}
					l=4;
					// fallthrough... use GMT if tz not available
				case 'Z':
					var offset = dojo.date.locale._getZone(dateObject, false, options);
					var tz = [
						(offset<=0 ? "+" : "-"),
						dojo.string.pad(Math.floor(Math.abs(offset)/60), 2),
						dojo.string.pad(Math.abs(offset)% 60, 2)
					];
					if(l==4){
						tz.splice(0, 0, "GMT");
						tz.splice(3, 0, ":");
					}
					s = tz.join("");
					break;
//				case 'Y': case 'u': case 'W': case 'F': case 'g': case 'A': case 'e':
//					console.log(match+" modifier unimplemented");
				default:
					throw new Error("dojo.date.locale.format: invalid pattern char: "+pattern);
			}
			if(pad){ s = dojo.string.pad(s, l); }
			return s;
		});
	}

/*=====
	dojo.date.locale.__FormatOptions = function(){
	//	selector: String
	//		choice of 'time','date' (default: date and time)
	//	formatLength: String
	//		choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'
	//	datePattern:String
	//		override pattern with this string
	//	timePattern:String
	//		override pattern with this string
	//	am: String
	//		override strings for am in times
	//	pm: String
	//		override strings for pm in times
	//	locale: String
	//		override the locale used to determine formatting rules
	//	fullYear: Boolean
	//		(format only) use 4 digit years whenever 2 digit years are called for
	//	strict: Boolean
	//		(parse only) strict parsing, off by default
		this.selector = selector;
		this.formatLength = formatLength;
		this.datePattern = datePattern;
		this.timePattern = timePattern;
		this.am = am;
		this.pm = pm;
		this.locale = locale;
		this.fullYear = fullYear;
		this.strict = strict;
	}
=====*/

dojo.date.locale._getZone = function(/*Date*/dateObject, /*boolean*/getName, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Returns the zone (or offset) for the given date and options.  This
	//		is broken out into a separate function so that it can be overridden
	//		by timezone-aware code.
	//
	// dateObject:
	//		the date and/or time being formatted.
	//
	// getName:
	//		Whether to return the timezone string (if true), or the offset (if false)
	//
	// options:
	//		The options being used for formatting
	if(getName){
		return dojo.date.getTimezoneName(dateObject);
	}else{
		return dateObject.getTimezoneOffset();
	}
};


dojo.date.locale.format = function(/*Date*/dateObject, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Format a Date object as a String, using locale-specific settings.
	//
	// description:
	//		Create a string from a Date object using a known localized pattern.
	//		By default, this method formats both date and time from dateObject.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//
	// dateObject:
	//		the date and/or time to be formatted.  If a time only is formatted,
	//		the values in the year, month, and day fields are irrelevant.  The
	//		opposite is true when formatting only dates.

	options = options || {};

	var locale = dojo.i18n.normalizeLocale(options.locale),
		formatLength = options.formatLength || 'short',
		bundle = dojo.date.locale._getGregorianBundle(locale),
		str = [],
		sauce = dojo.hitch(this, formatPattern, dateObject, bundle, options);
	if(options.selector == "year"){
		return _processPattern(bundle["dateFormatItem-yyyy"] || "yyyy", sauce);
	}
	var pattern;
	if(options.selector != "date"){
		pattern = options.timePattern || bundle["timeFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}
	if(options.selector != "time"){
		pattern = options.datePattern || bundle["dateFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}

	return str.length == 1 ? str[0] : bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
		function(match, key){ return str[key]; }); // String
};

dojo.date.locale.regexp = function(/*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Builds the regular needed to parse a localized date

	return dojo.date.locale._parseInfo(options).regexp; // String
};

dojo.date.locale._parseInfo = function(/*dojo.date.locale.__FormatOptions?*/options){
	options = options || {};
	var locale = dojo.i18n.normalizeLocale(options.locale),
		bundle = dojo.date.locale._getGregorianBundle(locale),
		formatLength = options.formatLength || 'short',
		datePattern = options.datePattern || bundle["dateFormat-" + formatLength],
		timePattern = options.timePattern || bundle["timeFormat-" + formatLength],
		pattern;
	if(options.selector == 'date'){
		pattern = datePattern;
	}else if(options.selector == 'time'){
		pattern = timePattern;
	}else{
		pattern = bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
			function(match, key){ return [timePattern, datePattern][key]; });
	}

	var tokens = [],
		re = _processPattern(pattern, dojo.hitch(this, _buildDateTimeRE, tokens, bundle, options));
	return {regexp: re, tokens: tokens, bundle: bundle};
};

dojo.date.locale.parse = function(/*String*/value, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Convert a properly formatted string to a primitive Date object,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Date object from a string using a known localized pattern.
	//		By default, this method parses looking for both date and time in the string.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//	
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//		When two digit years are used, a century is chosen according to a sliding 
	//		window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
	//		year < 100CE requires strict mode.
	//
	// value:
	//		A string representation of a date

	var info = dojo.date.locale._parseInfo(options),
		tokens = info.tokens, bundle = info.bundle,
		re = new RegExp("^" + info.regexp + "$", info.strict ? "" : "i"),
		match = re.exec(value);

	if(!match){ return null; } // null

	var widthList = ['abbr', 'wide', 'narrow'],
		result = [1970,0,1,0,0,0,0], // will get converted to a Date at the end
		amPm = "",
		valid = dojo.every(match, function(v, i){
		if(!i){return true;}
		var token=tokens[i-1];
		var l=token.length;
		switch(token.charAt(0)){
			case 'y':
				if(l != 2 && options.strict){
					//interpret year literally, so '5' would be 5 A.D.
					result[0] = v;
				}else{
					if(v<100){
						v = Number(v);
						//choose century to apply, according to a sliding window
						//of 80 years before and 20 years after present year
						var year = '' + new Date().getFullYear(),
							century = year.substring(0, 2) * 100,
							cutoff = Math.min(Number(year.substring(2, 4)) + 20, 99),
							num = (v < cutoff) ? century + v : century - 100 + v;
						result[0] = num;
					}else{
						//we expected 2 digits and got more...
						if(options.strict){
							return false;
						}
						//interpret literally, so '150' would be 150 A.D.
						//also tolerate '1950', if 'yyyy' input passed to 'yy' format
						result[0] = v;
					}
				}
				break;
			case 'M':
				if(l>2){
					var months = bundle['months-format-' + widthList[l-3]].concat();
					if(!options.strict){
						//Tolerate abbreviating period in month part
						//Case-insensitive comparison
						v = v.replace(".","").toLowerCase();
						months = dojo.map(months, function(s){ return s.replace(".","").toLowerCase(); } );
					}
					v = dojo.indexOf(months, v);
					if(v == -1){
//						console.log("dojo.date.locale.parse: Could not parse month name: '" + v + "'.");
						return false;
					}
				}else{
					v--;
				}
				result[1] = v;
				break;
			case 'E':
			case 'e':
				var days = bundle['days-format-' + widthList[l-3]].concat();
				if(!options.strict){
					//Case-insensitive comparison
					v = v.toLowerCase();
					days = dojo.map(days, function(d){return d.toLowerCase();});
				}
				v = dojo.indexOf(days, v);
				if(v == -1){
//					console.log("dojo.date.locale.parse: Could not parse weekday name: '" + v + "'.");
					return false;
				}

				//TODO: not sure what to actually do with this input,
				//in terms of setting something on the Date obj...?
				//without more context, can't affect the actual date
				//TODO: just validate?
				break;
			case 'D':
				result[1] = 0;
				// fallthrough...
			case 'd':
				result[2] = v;
				break;
			case 'a': //am/pm
				var am = options.am || bundle.am;
				var pm = options.pm || bundle.pm;
				if(!options.strict){
					var period = /\./g;
					v = v.replace(period,'').toLowerCase();
					am = am.replace(period,'').toLowerCase();
					pm = pm.replace(period,'').toLowerCase();
				}
				if(options.strict && v != am && v != pm){
//					console.log("dojo.date.locale.parse: Could not parse am/pm part.");
					return false;
				}

				// we might not have seen the hours field yet, so store the state and apply hour change later
				amPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';
				break;
			case 'K': //hour (1-24)
				if(v == 24){ v = 0; }
				// fallthrough...
			case 'h': //hour (1-12)
			case 'H': //hour (0-23)
			case 'k': //hour (0-11)
				//TODO: strict bounds checking, padding
				if(v > 23){
//					console.log("dojo.date.locale.parse: Illegal hours value");
					return false;
				}

				//in the 12-hour case, adjusting for am/pm requires the 'a' part
				//which could come before or after the hour, so we will adjust later
				result[3] = v;
				break;
			case 'm': //minutes
				result[4] = v;
				break;
			case 's': //seconds
				result[5] = v;
				break;
			case 'S': //milliseconds
				result[6] = v;
//				break;
//			case 'w':
//TODO				var firstDay = 0;
//			default:
//TODO: throw?
//				console.log("dojo.date.locale.parse: unsupported pattern char=" + token.charAt(0));
		}
		return true;
	});

	var hours = +result[3];
	if(amPm === 'p' && hours < 12){
		result[3] = hours + 12; //e.g., 3pm -> 15
	}else if(amPm === 'a' && hours == 12){
		result[3] = 0; //12am -> 0
	}

	//TODO: implement a getWeekday() method in order to test 
	//validity of input strings containing 'EEE' or 'EEEE'...

	var dateObject = new Date(result[0], result[1], result[2], result[3], result[4], result[5], result[6]); // Date
	if(options.strict){
		dateObject.setFullYear(result[0]);
	}

	// Check for overflow.  The Date() constructor normalizes things like April 32nd...
	//TODO: why isn't this done for times as well?
	var allTokens = tokens.join(""),
		dateToken = allTokens.indexOf('d') != -1,
		monthToken = allTokens.indexOf('M') != -1;

	if(!valid ||
		(monthToken && dateObject.getMonth() > result[1]) ||
		(dateToken && dateObject.getDate() > result[2])){
		return null;
	}

	// Check for underflow, due to DST shifts.  See #9366
	// This assumes a 1 hour dst shift correction at midnight
	// We could compare the timezone offset after the shift and add the difference instead.
	if((monthToken && dateObject.getMonth() < result[1]) ||
		(dateToken && dateObject.getDate() < result[2])){
		dateObject = dojo.date.add(dateObject, "hour", 1);
	}

	return dateObject; // Date
};

function _processPattern(pattern, applyPattern, applyLiteral, applyAll){
	//summary: Process a pattern with literals in it

	// Break up on single quotes, treat every other one as a literal, except '' which becomes '
	var identity = function(x){return x;};
	applyPattern = applyPattern || identity;
	applyLiteral = applyLiteral || identity;
	applyAll = applyAll || identity;

	//split on single quotes (which escape literals in date format strings) 
	//but preserve escaped single quotes (e.g., o''clock)
	var chunks = pattern.match(/(''|[^'])+/g),
		literal = pattern.charAt(0) == "'";

	dojo.forEach(chunks, function(chunk, i){
		if(!chunk){
			chunks[i]='';
		}else{
			chunks[i]=(literal ? applyLiteral : applyPattern)(chunk);
			literal = !literal;
		}
	});
	return applyAll(chunks.join(''));
}

function _buildDateTimeRE(tokens, bundle, options, pattern){
	pattern = dojo.regexp.escapeString(pattern);
	if(!options.strict){ pattern = pattern.replace(" a", " ?a"); } // kludge to tolerate no space before am/pm
	return pattern.replace(/([a-z])\1*/ig, function(match){
		// Build a simple regexp.  Avoid captures, which would ruin the tokens list
		var s,
			c = match.charAt(0),
			l = match.length,
			p2 = '', p3 = '';
		if(options.strict){
			if(l > 1){ p2 = '0' + '{'+(l-1)+'}'; }
			if(l > 2){ p3 = '0' + '{'+(l-2)+'}'; }
		}else{
			p2 = '0?'; p3 = '0{0,2}';
		}
		switch(c){
			case 'y':
				s = '\\d{2,4}';
				break;
			case 'M':
				s = (l>2) ? '\\S+?' : p2+'[1-9]|1[0-2]';
				break;
			case 'D':
				s = p2+'[1-9]|'+p3+'[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6]';
				break;
			case 'd':
				s = '[12]\\d|'+p2+'[1-9]|3[01]';
				break;
			case 'w':
				s = p2+'[1-9]|[1-4][0-9]|5[0-3]';
				break;
		    case 'E':
				s = '\\S+';
				break;
			case 'h': //hour (1-12)
				s = p2+'[1-9]|1[0-2]';
				break;
			case 'k': //hour (0-11)
				s = p2+'\\d|1[01]';
				break;
			case 'H': //hour (0-23)
				s = p2+'\\d|1\\d|2[0-3]';
				break;
			case 'K': //hour (1-24)
				s = p2+'[1-9]|1\\d|2[0-4]';
				break;
			case 'm':
			case 's':
				s = '[0-5]\\d';
				break;
			case 'S':
				s = '\\d{'+l+'}';
				break;
			case 'a':
				var am = options.am || bundle.am || 'AM';
				var pm = options.pm || bundle.pm || 'PM';
				if(options.strict){
					s = am + '|' + pm;
				}else{
					s = am + '|' + pm;
					if(am != am.toLowerCase()){ s += '|' + am.toLowerCase(); }
					if(pm != pm.toLowerCase()){ s += '|' + pm.toLowerCase(); }
					if(s.indexOf('.') != -1){ s += '|' + s.replace(/\./g, ""); }
				}
				s = s.replace(/\./g, "\\.");
				break;
			default:
			// case 'v':
			// case 'z':
			// case 'Z':
				s = ".*";
//				console.log("parse of date format, pattern=" + pattern);
		}

		if(tokens){ tokens.push(match); }

		return "(" + s + ")"; // add capture
	}).replace(/[\xa0 ]/g, "[\\s\\xa0]"); // normalize whitespace.  Need explicit handling of \xa0 for IE.
}
})();

(function(){
var _customFormats = [];
dojo.date.locale.addCustomFormats = function(/*String*/packageName, /*String*/bundleName){
	// summary:
	//		Add a reference to a bundle containing localized custom formats to be
	//		used by date/time formatting and parsing routines.
	//
	// description:
	//		The user may add custom localized formats where the bundle has properties following the
	//		same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	//		The pattern string should match the format used by the CLDR.
	//		See dojo.date.locale.format() for details.
	//		The resources must be loaded by dojo.requireLocalization() prior to use

	_customFormats.push({pkg:packageName,name:bundleName});
};

dojo.date.locale._getGregorianBundle = function(/*String*/locale){
	var gregorian = {};
	dojo.forEach(_customFormats, function(desc){
		var bundle = dojo.i18n.getLocalization(desc.pkg, desc.name, locale);
		gregorian = dojo.mixin(gregorian, bundle);
	}, this);
	return gregorian; /*Object*/
};
})();

dojo.date.locale.addCustomFormats("dojo.cldr","gregorian");

dojo.date.locale.getNames = function(/*String*/item, /*String*/type, /*String?*/context, /*String?*/locale){
	// summary:
	//		Used to get localized strings from dojo.cldr for day or month names.
	//
	// item:
	//	'months' || 'days'
	// type:
	//	'wide' || 'narrow' || 'abbr' (e.g. "Monday", "Mon", or "M" respectively, in English)
	// context:
	//	'standAlone' || 'format' (default)
	// locale:
	//	override locale used to find the names

	var label,
		lookup = dojo.date.locale._getGregorianBundle(locale),
		props = [item, context, type];
	if(context == 'standAlone'){
		var key = props.join('-');
		label = lookup[key];
		// Fall back to 'format' flavor of name
		if(label[0] == 1){ label = undefined; } // kludge, in the absense of real aliasing support in dojo.cldr
	}
	props[1] = 'format';

	// return by copy so changes won't be made accidentally to the in-memory model
	return (label || lookup[props.join('-')]).concat(); /*Array*/
};

dojo.date.locale.isWeekend = function(/*Date?*/dateObject, /*String?*/locale){
	// summary:
	//	Determines if the date falls on a weekend, according to local custom.

	var weekend = dojo.cldr.supplemental.getWeekend(locale),
		day = (dateObject || new Date()).getDay();
	if(weekend.end < weekend.start){
		weekend.end += 7;
		if(day < weekend.start){ day += 7; }
	}
	return day >= weekend.start && day <= weekend.end; // Boolean
};

// These are used only by format and strftime.  Do they need to be public?  Which module should they go in?

dojo.date.locale._getDayOfYear = function(/*Date*/dateObject){
	// summary: gets the day of the year as represented by dateObject
	return dojo.date.difference(new Date(dateObject.getFullYear(), 0, 1, dateObject.getHours()), dateObject) + 1; // Number
};

dojo.date.locale._getWeekOfYear = function(/*Date*/dateObject, /*Number*/firstDayOfWeek){
	if(arguments.length == 1){ firstDayOfWeek = 0; } // Sunday

	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1).getDay(),
		adj = (firstDayOfYear - firstDayOfWeek + 7) % 7,
		week = Math.floor((dojo.date.locale._getDayOfYear(dateObject) + adj - 1) / 7);

	// if year starts on the specified day, start counting weeks at 1
	if(firstDayOfYear == firstDayOfWeek){ week++; }

	return week; // Number
};

}

if(!dojo._hasResource["dijit.Calendar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Calendar"] = true;
dojo.provide("dijit.Calendar");








dojo.declare(
	"dijit.Calendar",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		A simple GUI for choosing a date in the context of a monthly calendar.
		//
		// description:
		//		A simple GUI for choosing a date in the context of a monthly calendar.
		//		This widget can't be used in a form because it doesn't serialize the date to an
		//		`<input>` field.  For a form element, use dijit.form.DateTextBox instead.
		//
		//		Note that the parser takes all dates attributes passed in the
		//		[RFC 3339 format](http://www.faqs.org/rfcs/rfc3339.html), e.g. `2005-06-30T08:05:00-07:00`
		//		so that they are serializable and locale-independent.
		//
		// example:
		//	|	var calendar = new dijit.Calendar({}, dojo.byId("calendarNode"));
		//
		// example:
		//	|	<div dojoType="dijit.Calendar"></div>

		templateString: dojo.cache("dijit", "templates/Calendar.html", "<table cellspacing=\"0\" cellpadding=\"0\" class=\"dijitCalendarContainer\" role=\"grid\" dojoAttachEvent=\"onkeypress: _onKeyPress\">\r\n\t<thead>\r\n\t\t<tr class=\"dijitReset dijitCalendarMonthContainer\" valign=\"top\">\r\n\t\t\t<th class='dijitReset' dojoAttachPoint=\"decrementMonth\">\r\n\t\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarDecrease\" waiRole=\"presentation\">\r\n\t\t\t\t<span dojoAttachPoint=\"decreaseArrowNode\" class=\"dijitA11ySideArrow\">-</span>\r\n\t\t\t</th>\r\n\t\t\t<th class='dijitReset' colspan=\"5\">\r\n\t\t\t\t<div class=\"dijitVisible\">\r\n\t\t\t\t\t<div class=\"dijitPopup dijitMenu dijitMenuPassive dijitHidden\" dojoAttachPoint=\"monthDropDown\" dojoAttachEvent=\"onmouseup: _onMonthSelect, onmouseover: _onMenuHover, onmouseout: _onMenuHover\">\r\n\t\t\t\t\t\t<div class=\"dijitCalendarMonthLabelTemplate dijitCalendarMonthLabel\"></div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div dojoAttachPoint=\"monthLabelSpacer\" class=\"dijitSpacer\"></div>\r\n\t\t\t\t<div dojoAttachPoint=\"monthLabelNode\" class=\"dijitCalendarMonthLabel dijitInline dijitVisible\" dojoAttachEvent=\"onmousedown: _onMonthToggle\"></div>\r\n\t\t\t</th>\r\n\t\t\t<th class='dijitReset' dojoAttachPoint=\"incrementMonth\">\r\n\t\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarIncrease\" waiRole=\"presentation\">\r\n\t\t\t\t<span dojoAttachPoint=\"increaseArrowNode\" class=\"dijitA11ySideArrow\">+</span>\r\n\t\t\t</th>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<th class=\"dijitReset dijitCalendarDayLabelTemplate\" role=\"columnheader\"><span class=\"dijitCalendarDayLabel\"></span></th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody dojoAttachEvent=\"onclick: _onDayClick, onmouseover: _onDayMouseOver, onmouseout: _onDayMouseOut\" class=\"dijitReset dijitCalendarBodyContainer\">\r\n\t\t<tr class=\"dijitReset dijitCalendarWeekTemplate\" role=\"row\">\r\n\t\t\t<td class=\"dijitReset dijitCalendarDateTemplate\" role=\"gridcell\"><span class=\"dijitCalendarDateLabel\"></span></td>\r\n\t\t</tr>\r\n\t</tbody>\r\n\t<tfoot class=\"dijitReset dijitCalendarYearContainer\">\r\n\t\t<tr>\r\n\t\t\t<td class='dijitReset' valign=\"top\" colspan=\"7\">\r\n\t\t\t\t<h3 class=\"dijitCalendarYearLabel\">\r\n\t\t\t\t\t<span dojoAttachPoint=\"previousYearLabelNode\" class=\"dijitInline dijitCalendarPreviousYear\"></span>\r\n\t\t\t\t\t<span dojoAttachPoint=\"currentYearLabelNode\" class=\"dijitInline dijitCalendarSelectedYear\"></span>\r\n\t\t\t\t\t<span dojoAttachPoint=\"nextYearLabelNode\" class=\"dijitInline dijitCalendarNextYear\"></span>\r\n\t\t\t\t</h3>\r\n\t\t\t</td>\r\n\t\t</tr>\r\n\t</tfoot>\r\n</table>\r\n"),

		// value: Date
		//		The currently selected Date
		value: new Date(),

		// datePackage: String
		//		JavaScript namespace to find Calendar routines.  Uses Gregorian Calendar routines
		//		at dojo.date by default.
		datePackage: "dojo.date",

		// dayWidth: String
		//		How to represent the days of the week in the calendar header. See dojo.date.locale
		dayWidth: "narrow",

		// tabIndex: Integer
		//		Order fields are traversed when user hits the tab key
		tabIndex: "0",

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			tabIndex: "domNode"
 		}),

		setValue: function(/*Date*/ value){
			// summary:
			//      Deprecated.   Used attr('value', ...) instead.
			// tags:
			//      deprecated
			dojo.deprecated("dijit.Calendar:setValue() is deprecated.  Use attr('value', ...) instead.", "", "2.0");
			this.attr('value', value);
		},

		_getValueAttr: function(){
			// summary:
			//		Support getter attr('value')
			var value = new this.dateClassObj(this.value);
			value.setHours(0, 0, 0, 0); // return midnight, local time for back-compat

			// If daylight savings pushes midnight to the previous date, fix the Date
			// object to point at 1am so it will represent the correct day. See #9366
			if(value.getDate() < this.value.getDate()){
				value = this.dateFuncObj.add(value, "hour", 1);
			}
			return value;
		},

		_setValueAttr: function(/*Date*/ value){
			// summary:
			//		Support setter attr("value", ...)
			// description:
			// 		Set the current date and update the UI.  If the date is disabled, the value will
			//		not change, but the display will change to the corresponding month.
			// tags:
			//      protected
			if(!this.value || this.dateFuncObj.compare(value, this.value)){
				value = new this.dateClassObj(value);
				value.setHours(1); // to avoid issues when DST shift occurs at midnight, see #8521, #9366
				this.displayMonth = new this.dateClassObj(value);
				if(!this.isDisabledDate(value, this.lang)){
					this.value = value;
					this.onChange(this.attr('value'));
				}
				dojo.attr(this.domNode, "aria-label",
					this.dateLocaleModule.format(value,
						{selector:"date", formatLength:"full"}));
				this._populateGrid();
			}
		},

		_setText: function(node, text){
			// summary:
			//		This just sets the content of node to the specified text.
			//		Can't do "node.innerHTML=text" because of an IE bug w/tables, see #3434.
			// tags:
			//      private
			while(node.firstChild){
				node.removeChild(node.firstChild);
			}
			node.appendChild(dojo.doc.createTextNode(text));
		},

		_populateGrid: function(){
			// summary:
			//      Fills in the calendar grid with each day (1-31)
			// tags:
			//      private
			var month = this.displayMonth;
			month.setDate(1);
			var firstDay = month.getDay(),
				daysInMonth = this.dateFuncObj.getDaysInMonth(month),
				daysInPreviousMonth = this.dateFuncObj.getDaysInMonth(this.dateFuncObj.add(month, "month", -1)),
				today = new this.dateClassObj(),
				dayOffset = dojo.cldr.supplemental.getFirstDayOfWeek(this.lang);
			if(dayOffset > firstDay){ dayOffset -= 7; }

			// Iterate through dates in the calendar and fill in date numbers and style info
			dojo.query(".dijitCalendarDateTemplate", this.domNode).forEach(function(template, i){
				i += dayOffset;
				var date = new this.dateClassObj(month),
					number, clazz = "dijitCalendar", adj = 0;

				if(i < firstDay){
					number = daysInPreviousMonth - firstDay + i + 1;
					adj = -1;
					clazz += "Previous";
				}else if(i >= (firstDay + daysInMonth)){
					number = i - firstDay - daysInMonth + 1;
					adj = 1;
					clazz += "Next";
				}else{
					number = i - firstDay + 1;
					clazz += "Current";
				}

				if(adj){
					date = this.dateFuncObj.add(date, "month", adj);
				}
				date.setDate(number);

				if(!this.dateFuncObj.compare(date, today, "date")){
					clazz = "dijitCalendarCurrentDate " + clazz;
				}

				if(this._isSelectedDate(date, this.lang)){
					clazz = "dijitCalendarSelectedDate " + clazz;
				}

				if(this.isDisabledDate(date, this.lang)){
					clazz = "dijitCalendarDisabledDate " + clazz;
				}

				var clazz2 = this.getClassForDate(date, this.lang);
				if(clazz2){
					clazz = clazz2 + " " + clazz;
				}

				template.className = clazz + "Month dijitCalendarDateTemplate";
				template.dijitDateValue = date.valueOf();
				var label = dojo.query(".dijitCalendarDateLabel", template)[0],
					text = date.getDateLocalized ? date.getDateLocalized(this.lang) : date.getDate();
				this._setText(label, text);
			}, this);

			// Fill in localized month name
			var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang);
			this._setText(this.monthLabelNode, monthNames[month.getMonth()]);

			// Fill in localized prev/current/next years
			var y = month.getFullYear() - 1;
			var d = new this.dateClassObj();
			dojo.forEach(["previous", "current", "next"], function(name){
				d.setFullYear(y++);
				this._setText(this[name+"YearLabelNode"],
					this.dateLocaleModule.format(d, {selector:'year', locale:this.lang}));
			}, this);

			// Set up repeating mouse behavior
			var _this = this;
			var typematic = function(nodeProp, dateProp, adj){
//FIXME: leaks (collects) listeners if populateGrid is called multiple times.  Do this once?
				_this._connects.push(
					dijit.typematic.addMouseListener(_this[nodeProp], _this, function(count){
						if(count >= 0){ _this._adjustDisplay(dateProp, adj); }
					}, 0.8, 500)
				);
			};
			typematic("incrementMonth", "month", 1);
			typematic("decrementMonth", "month", -1);
			typematic("nextYearLabelNode", "year", 1);
			typematic("previousYearLabelNode", "year", -1);
		},

		goToToday: function(){
			// summary:
			//      Sets calendar's value to today's date
			this.attr('value', new this.dateClassObj());
		},

		constructor: function(/*Object*/args){
			var dateClass = (args.datePackage && (args.datePackage != "dojo.date"))? args.datePackage + ".Date" : "Date";
			this.dateClassObj = dojo.getObject(dateClass, false);
			this.datePackage = args.datePackage || this.datePackage;
			this.dateFuncObj = dojo.getObject(this.datePackage, false);
			this.dateLocaleModule = dojo.getObject(this.datePackage + ".locale", false);
		},

		postMixInProperties: function(){
			// parser.instantiate sometimes passes in NaN for IE.  Use default value in prototype instead.
			if(isNaN(this.value)){ delete this.value; }
			this.inherited(arguments);
		},

		postCreate: function(){
			this.inherited(arguments);
			dojo.setSelectable(this.domNode, false);

			var cloneClass = dojo.hitch(this, function(clazz, n){
				var template = dojo.query(clazz, this.domNode)[0];
	 			for(var i=0; i<n; i++){
					template.parentNode.appendChild(template.cloneNode(true));
				}
			});

			// clone the day label and calendar day templates 6 times to make 7 columns
			cloneClass(".dijitCalendarDayLabelTemplate", 6);
			cloneClass(".dijitCalendarDateTemplate", 6);

			// now make 6 week rows
			cloneClass(".dijitCalendarWeekTemplate", 5);

			// insert localized day names in the header
			var dayNames = this.dateLocaleModule.getNames('days', this.dayWidth, 'standAlone', this.lang);
			var dayOffset = dojo.cldr.supplemental.getFirstDayOfWeek(this.lang);
			dojo.query(".dijitCalendarDayLabel", this.domNode).forEach(function(label, i){
				this._setText(label, dayNames[(i + dayOffset) % 7]);
			}, this);

			// Fill in spacer/month dropdown element with all the month names (invisible) so that the maximum width will affect layout
			var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang);
			cloneClass(".dijitCalendarMonthLabelTemplate", monthNames.length-1);
			dojo.query(".dijitCalendarMonthLabelTemplate", this.domNode).forEach(function(node, i){
				dojo.attr(node, "month", i);
				this._setText(node, monthNames[i]);
				dojo.place(node.cloneNode(true), this.monthLabelSpacer);
			}, this);

			var value = this.value;
			this.value = null;
			this.attr('value', new this.dateClassObj(value));
		},

		_onMenuHover: function(e){
			dojo.stopEvent(e);
			dojo.toggleClass(e.target, "dijitMenuItemHover");
		},

		_adjustDisplay: function(/*String*/ part, /*int*/ amount){
			// summary:
			//      Moves calendar forwards or backwards by months or years
			// part:
			//      "month" or "year"
			// amount:
			//      Number of months or years
			// tags:
			//      private
			this.displayMonth = this.dateFuncObj.add(this.displayMonth, part, amount);
			this._populateGrid();
		},

		_onMonthToggle: function(/*Event*/ evt){
			// summary:
			//      Handler for when user triggers or dismisses the month list
			// tags:
			//      protected
			dojo.stopEvent(evt);

			if(evt.type == "mousedown"){
				var coords = dojo.position(this.monthLabelNode);
//				coords.y -= dojo.position(this.domNode, true).y;
				// Size the dropdown's width to match the label in the widget
				// so that they are horizontally aligned
				var dim = {
					width: coords.w + "px",
					top: -this.displayMonth.getMonth() * coords.h + "px"
				};
				if((dojo.isIE && dojo.isQuirks) || dojo.isIE < 7){
					dim.left = -coords.w/2 + "px";
				}
				dojo.style(this.monthDropDown, dim);
				this._popupHandler = this.connect(document, "onmouseup", "_onMonthToggle");
			}else{
				this.disconnect(this._popupHandler);
				delete this._popupHandler;
			}

			dojo.toggleClass(this.monthDropDown, "dijitHidden");
			dojo.toggleClass(this.monthLabelNode, "dijitVisible");
		},

		_onMonthSelect: function(/*Event*/ evt){
			// summary:
			//      Handler for when user selects a month from a list
			// tags:
			//      protected
			this._onMonthToggle(evt);
			this.displayMonth.setMonth(dojo.attr(evt.target, "month"));
			this._populateGrid();
		},

		_onDayClick: function(/*Event*/ evt){
			// summary:
			//      Handler for day clicks, selects the date if appropriate
			// tags:
			//      protected
			dojo.stopEvent(evt);
			for(var node = evt.target; node && !node.dijitDateValue; node = node.parentNode);
			if(node && !dojo.hasClass(node, "dijitCalendarDisabledDate")){
				this.attr('value', node.dijitDateValue);
				this.onValueSelected(this.attr('value'));
			}
		},

		_onDayMouseOver: function(/*Event*/ evt){
			// summary:
			//      Handler for mouse over events on days, sets up hovered style
			// tags:
			//      protected
			var node = evt.target;
			if(node && (node.dijitDateValue || node == this.previousYearLabelNode || node == this.nextYearLabelNode) ){
				dojo.addClass(node, "dijitCalendarHoveredDate");
				this._currentNode = node;
			}
		},

		_onDayMouseOut: function(/*Event*/ evt){
			// summary:
			//      Handler for mouse out events on days, clears hovered style
			// tags:
			//      protected
			if(!this._currentNode){ return; }
			for(var node = evt.relatedTarget; node;){
				if(node == this._currentNode){ return; }
				try{
					node = node.parentNode;
				}catch(x){
					node = null;
				}
			}
			dojo.removeClass(this._currentNode, "dijitCalendarHoveredDate");
			this._currentNode = null;
		},

//TODO: use typematic
//TODO: skip disabled dates without ending up in a loop
//TODO: could optimize by avoiding populate grid when month does not change
		_onKeyPress: function(/*Event*/evt){
			// summary:
			//		Provides keyboard navigation of calendar
			// tags:
			//		protected
			var dk = dojo.keys,
				increment = -1,
				interval,
				newValue = this.value;
			switch(evt.keyCode){
				case dk.RIGHT_ARROW:
					increment = 1;
					//fallthrough...
				case dk.LEFT_ARROW:
					interval = "day";
					if(!this.isLeftToRight()){ increment *= -1; }
					break;
				case dk.DOWN_ARROW:
					increment = 1;
					//fallthrough...
				case dk.UP_ARROW:
					interval = "week";
					break;
				case dk.PAGE_DOWN:
					increment = 1;
					//fallthrough...
				case dk.PAGE_UP:
					interval = evt.ctrlKey ? "year" : "month";
					break;
				case dk.END:
					// go to the next month
					newValue = this.dateFuncObj.add(newValue, "month", 1);
					// subtract a day from the result when we're done
					interval = "day";
					//fallthrough...
				case dk.HOME:
					newValue = new Date(newValue).setDate(1);
					break;
				case dk.ENTER:
					this.onValueSelected(this.attr('value'));
					break;
				case dk.ESCAPE:
					//TODO
				default:
					return;
			}
			dojo.stopEvent(evt);

			if(interval){
				newValue = this.dateFuncObj.add(newValue, interval, increment);
			}

			this.attr("value", newValue);
		},

		onValueSelected: function(/*Date*/ date){
			// summary:
			//		Notification that a date cell was selected.  It may be the same as the previous value.
			// description:
			//      Used by `dijit.form._DateTimeTextBox` (and thus `dijit.form.DateTextBox`)
			//      to get notification when the user has clicked a date.
			// tags:
			//      protected
		},

		onChange: function(/*Date*/ date){
			// summary:
			//		Called only when the selected date has changed
		},

		_isSelectedDate: function(/*Date*/ dateObject, /*String?*/ locale){
			// summary:
			//		Extension point so developers can subclass Calendar to
			//		support multiple (concurrently) selected dates
			// tags:
			//		protected extension
			return !this.dateFuncObj.compare(dateObject, this.value, "date")
		},

		isDisabledDate: function(/*Date*/ dateObject, /*String?*/ locale){
			// summary:
			//		May be overridden to disable certain dates in the calendar e.g. `isDisabledDate=dojo.date.locale.isWeekend`
			// tags:
			//      extension
/*=====
			return false; // Boolean
=====*/
		},

		getClassForDate: function(/*Date*/ dateObject, /*String?*/ locale){
			// summary:
			//		May be overridden to return CSS classes to associate with the date entry for the given dateObject,
			//		for example to indicate a holiday in specified locale.
			// tags:
			//      extension

/*=====
			return ""; // String
=====*/
		}
	}
);

}

if(!dojo._hasResource["dijit.form._DateTimeTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._DateTimeTextBox"] = true;
dojo.provide("dijit.form._DateTimeTextBox");






/*=====
dojo.declare(
	"dijit.form._DateTimeTextBox.__Constraints",
	[dijit.form.RangeBoundTextBox.__Constraints, dojo.date.locale.__FormatOptions], {
	// summary:
	//		Specifies both the rules on valid/invalid values (first/last date/time allowed),
	//		and also formatting options for how the date/time is displayed.
	// example:
	//		To restrict to dates within 2004, displayed in a long format like "December 25, 2005":
	//	|		{min:'2004-01-01',max:'2004-12-31', formatLength:'long'}
});
=====*/

dojo.declare(
	"dijit.form._DateTimeTextBox",
	dijit.form.RangeBoundTextBox,
	{
		// summary:
		//		Base class for validating, serializable, range-bound date or time text box.

		// constraints: dijit.form._DateTimeTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including starting/ending dates/times allowed) as well as
		//		formatting options like whether the date is displayed in long (ex: December 25, 2005)
		//		or short (ex: 12/25/2005) format.   See `dijit.form._DateTimeTextBox.__Constraints` for details.
		/*=====
		constraints: {},
		======*/

		// Override ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale  (plus formatting options too?)
		regExpGen: dojo.date.locale.regexp,

		// datePackage: String
		//	JavaScript namespace to find calendar routines.  Uses Gregorian calendar routines
		//	at dojo.date, by default.
		datePackage: "dojo.date",

		// Override _FormWidget.compare() to work for dates/times
		compare: dojo.date.compare,

		format: function(/*Date*/ value, /*dojo.date.locale.__FormatOptions*/ constraints){
			// summary:
			//		Formats the value as a Date, according to specified locale (second argument)
			// tags:
			//		protected
			if(!value){ return ''; }
			return this.dateLocaleModule.format(value, constraints);
		},

		parse: function(/*String*/ value, /*dojo.date.locale.__FormatOptions*/ constraints){
			// summary:
			//		Parses as string as a Date, according to constraints
			// tags:
			//		protected

			return this.dateLocaleModule.parse(value, constraints) || (this._isEmpty(value) ? null : undefined);	 // Date
		},

		// Overrides ValidationTextBox.serialize() to serialize a date in canonical ISO format.
		serialize: function(/*anything*/val, /*Object?*/options){
			if(val.toGregorian){
				val = val.toGregorian();
			}
			return dojo.date.stamp.toISOString(val, options);
		},

		// value: Date
		//		The value of this widget as a JavaScript Date object.  Use attr("value") / attr("value", val) to manipulate.
		//		When passed to the parser in markup, must be specified according to `dojo.date.stamp.fromISOString`
		value: new Date(""),	// value.toString()="NaN"
		_blankValue: null,	// used by filter() when the textbox is blank

		//	popupClass: [protected extension] String
		//		Name of the popup widget class used to select a date/time.
		//		Subclasses should specify this.
		popupClass: "", // default is no popup = text only


		// _selector: [protected extension] String
		//		Specifies constraints.selector passed to dojo.date functions, should be either
		//		"date" or "time".
		//		Subclass must specify this.
		_selector: "",

		constructor: function(/*Object*/args){
			var dateClass = args.datePackage ? args.datePackage + ".Date" : "Date";
			this.dateClassObj = dojo.getObject(dateClass, false);
			this.value = new this.dateClassObj("");

			this.datePackage = args.datePackage || this.datePackage;
			this.dateLocaleModule = dojo.getObject(this.datePackage + ".locale", false);
			this.regExpGen = this.dateLocaleModule.regexp;
		},

		postMixInProperties: function(){
			this.inherited(arguments);

			if(!this.value || this.value.toString() == dijit.form._DateTimeTextBox.prototype.value.toString()){
				this.value = null;
			}
			var constraints = this.constraints;
			constraints.selector = this._selector;
			constraints.fullYear = true; // see #5465 - always format with 4-digit years
			var fromISO = dojo.date.stamp.fromISOString;
			if(typeof constraints.min == "string"){ constraints.min = fromISO(constraints.min); }
 			if(typeof constraints.max == "string"){ constraints.max = fromISO(constraints.max); }
		},

		_onFocus: function(/*Event*/ evt){
			// summary:
			//		open the popup
			this._open();
			this.inherited(arguments);
		},

		_setValueAttr: function(/*Date*/ value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Sets the date on this textbox.  Note that `value` must be like a Javascript Date object.
			if(value instanceof Date && !(this.dateClassObj instanceof Date)){
				value = new this.dateClassObj(value);
			}

			this.inherited(arguments);
			if(this._picker){
				// #3948: fix blank date on popup only
				if(!value){value = new this.dateClassObj();}
				this._picker.attr('value', value);
			}
		},

		_open: function(){
			// summary:
			//		opens the TimePicker, and sets the onValueSelected value

			if(this.disabled || this.readOnly || !this.popupClass){return;}

			var textBox = this;

			if(!this._picker){
				var PopupProto = dojo.getObject(this.popupClass, false);
				this._picker = new PopupProto({
					onValueSelected: function(value){
						if(textBox._tabbingAway){
							delete textBox._tabbingAway;
						}else{
							textBox.focus(); // focus the textbox before the popup closes to avoid reopening the popup
						}
						setTimeout(dojo.hitch(textBox, "_close"), 1); // allow focus time to take

						// this will cause InlineEditBox and other handlers to do stuff so make sure it's last
						dijit.form._DateTimeTextBox.superclass._setValueAttr.call(textBox, value, true);
					},
					id: this.id + "_popup",
					lang: textBox.lang,
					constraints: textBox.constraints,

					datePackage: textBox.datePackage,

					isDisabledDate: function(/*Date*/ date){
						// summary:
						// 	disables dates outside of the min/max of the _DateTimeTextBox
						var compare = dojo.date.compare;
						var constraints = textBox.constraints;
						return constraints && (constraints.min && (compare(constraints.min, date, textBox._selector) > 0) ||
							(constraints.max && compare(constraints.max, date, textBox._selector) < 0));
					}
				});
				this._picker.attr('value', this.attr('value') || new this.dateClassObj());
			}
			if(!this._opened){
				// Open drop down.  Align left sides of input box and drop down, even in RTL mode,
				// otherwise positioning thrown off when the drop down width is changed in marginBox call below (#10676)
				dijit.popup.open({
					parent: this,
					popup: this._picker,
					orient: {'BL':'TL', 'TL':'BL'},
					around: this.domNode,
					onCancel: dojo.hitch(this, this._close),
					onClose: function(){ textBox._opened=false; }
				});
				this._opened=true;
			}

			dojo.marginBox(this._picker.domNode,{ w:this.domNode.offsetWidth });
		},

		_close: function(){
			if(this._opened){
				dijit.popup.close(this._picker);
				this._opened=false;
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's dropdown
			this._close();
			if(this._picker){
				// teardown so that constraints will be rebuilt next time (redundant reference: #6002)
				this._picker.destroy();
				delete this._picker;
			}
			this.inherited(arguments);
			// don't focus on <input>.  the user has explicitly focused on something else.
		},

		_getDisplayedValueAttr: function(){
			return this.textbox.value;
		},

		_setDisplayedValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange){
			this._setValueAttr(this.parse(value, this.constraints), priorityChange, value);
		},

		destroy: function(){
			if(this._picker){
				this._picker.destroy();
				delete this._picker;
			}
			this.inherited(arguments);
		},

		postCreate: function(){
			this.inherited(arguments);
			this.connect(this.focusNode, 'onkeypress', this._onKeyPress);
			this.connect(this.focusNode, 'onclick', this._open);
		},

		_onKeyPress: function(/*Event*/ e){
			// summary:
			//		Handler for keypress events

			var p = this._picker, dk = dojo.keys;
			// Handle the key in the picker, if it has a handler.  If the handler
			// returns false, then don't handle any other keys.
			if(p && this._opened && p.handleKey){
				if(p.handleKey(e) === false){ return; }
			}
			if(this._opened && e.charOrCode == dk.ESCAPE && !(e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)){
				this._close();
				dojo.stopEvent(e);
			}else if(!this._opened && e.charOrCode == dk.DOWN_ARROW){
				this._open();
				dojo.stopEvent(e);
			}else if(e.charOrCode === dk.TAB){
				this._tabbingAway = true;
			}else if(this._opened && (e.keyChar || e.charOrCode === dk.BACKSPACE || e.charOrCode == dk.DELETE)){
				// Replace the element - but do it after a delay to allow for
				// filtering to occur
				setTimeout(dojo.hitch(this, function(){
					dijit.placeOnScreenAroundElement(p.domNode.parentNode, this.domNode, {'BL':'TL', 'TL':'BL'}, p.orient ? dojo.hitch(p, "orient") : null);
				}), 1);
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.form.DateTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.DateTextBox"] = true;
dojo.provide("dijit.form.DateTextBox");




dojo.declare(
	"dijit.form.DateTextBox",
	dijit.form._DateTimeTextBox,
	{
		// summary:
		//		A validating, serializable, range-bound date text box with a drop down calendar
		//
		//		Example:
		// |	new dijit.form.DateTextBox({value: new Date(2009, 0, 20)})
		//
		//		Example:
		// |	<input dojotype='dijit.form.DateTextBox' value='2009-01-20'>

		baseClass: "dijitTextBox dijitDateTextBox",
		popupClass: "dijit.Calendar",
		_selector: "date",

		// value: Date
		//		The value of this widget as a JavaScript Date object, with only year/month/day specified.
		//		If specified in markup, use the format specified in `dojo.date.stamp.fromISOString`
		value: new Date("")	// value.toString()="NaN"
	}
);

}

if(!dojo._hasResource["dijit.form.CheckBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.CheckBox"] = true;
dojo.provide("dijit.form.CheckBox");



dojo.declare(
	"dijit.form.CheckBox",
	dijit.form.ToggleButton,
	{
		// summary:
		// 		Same as an HTML checkbox, but with fancy styling.
		//
		// description:
		// User interacts with real html inputs.
		// On onclick (which occurs by mouse click, space-bar, or
		// using the arrow keys to switch the selected radio button),
		// we update the state of the checkbox/radio.
		//
		// There are two modes:
		//   1. High contrast mode
		//   2. Normal mode
		// In case 1, the regular html inputs are shown and used by the user.
		// In case 2, the regular html inputs are invisible but still used by
		// the user. They are turned quasi-invisible and overlay the background-image.

		templateString: dojo.cache("dijit.form", "templates/CheckBox.html", "<div class=\"dijitReset dijitInline\" waiRole=\"presentation\"\r\n\t><input\r\n\t \t${nameAttrSetting} type=\"${type}\" ${checkedAttrSetting}\r\n\t\tclass=\"dijitReset dijitCheckBoxInput\"\r\n\t\tdojoAttachPoint=\"focusNode\"\r\n\t \tdojoAttachEvent=\"onmouseover:_onMouse,onmouseout:_onMouse,onclick:_onClick\"\r\n/></div>\r\n"),

		baseClass: "dijitCheckBox",

		// type: [private] String
		//		type attribute on <input> node.
		//		Overrides `dijit.form.Button.type`.   Users should not change this value.
		type: "checkbox",

		// value: String
		//		As an initialization parameter, equivalent to value field on normal checkbox
		//		(if checked, the value is passed as the value when form is submitted).
		//
		//		However, attr('value') will return either the string or false depending on
		//		whether or not the checkbox is checked.
		//
		//		attr('value', string) will check the checkbox and change the value to the
		//		specified string
		//
		//		attr('value', boolean) will change the checked state.
		value: "on",

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,

		attributeMap: dojo.delegate(dijit.form.ToggleButton.prototype.attributeMap, {
			readOnly: "focusNode"
		}),

		_setReadOnlyAttr: function(/*Boolean*/ value){
			this.readOnly = value;
			dojo.attr(this.focusNode, 'readOnly', value);
			dijit.setWaiState(this.focusNode, "readonly", value);
			this._setStateClass();
		},

		_setValueAttr: function(/*String or Boolean*/ newValue){
			// summary:
			//		Handler for value= attribute to constructor, and also calls to
			//		attr('value', val).
			// description:
			//		During initialization, just saves as attribute to the <input type=checkbox>.
			//
			//		After initialization,
			//		when passed a boolean, controls whether or not the CheckBox is checked.
			//		If passed a string, changes the value attribute of the CheckBox (the one
			//		specified as "value" when the CheckBox was constructed (ex: <input
			//		dojoType="dijit.CheckBox" value="chicken">)
			if(typeof newValue == "string"){
				this.value = newValue;
				dojo.attr(this.focusNode, 'value', newValue);
				newValue = true;
			}
			if(this._created){
				this.attr('checked', newValue);
			}
		},
		_getValueAttr: function(){
			// summary:
			//		Hook so attr('value') works.
			// description:
			//		If the CheckBox is checked, returns the value attribute.
			//		Otherwise returns false.
			return (this.checked ? this.value : false);
		},

		postMixInProperties: function(){
			if(this.value == ""){
				this.value = "on";
			}

			// Need to set initial checked state as part of template, so that form submit works.
			// dojo.attr(node, "checked", bool) doesn't work on IEuntil node has been attached
			// to <body>, see #8666
			this.checkedAttrSetting = this.checked ? "checked" : "";

			this.inherited(arguments);
		},

		 _fillContent: function(/*DomNode*/ source){
			// Override Button::_fillContent() since it doesn't make sense for CheckBox,
			// since CheckBox doesn't even have a container
		},

		reset: function(){
			// Override ToggleButton.reset()

			this._hasBeenBlurred = false;

			this.attr('checked', this.params.checked || false);

			// Handle unlikely event that the <input type=checkbox> value attribute has changed
			this.value = this.params.value || "on";
			dojo.attr(this.focusNode, 'value', this.value);
		},

		_onFocus: function(){
			if(this.id){
				dojo.query("label[for='"+this.id+"']").addClass("dijitFocusedLabel");
			}
		},

		_onBlur: function(){
			if(this.id){
				dojo.query("label[for='"+this.id+"']").removeClass("dijitFocusedLabel");
			}
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to handle click actions - need to check
			//		readOnly, since button no longer does that check.
			if(this.readOnly){
				return false;
			}
			return this.inherited(arguments);
		}
	}
);

dojo.declare(
	"dijit.form.RadioButton",
	dijit.form.CheckBox,
	{
		// summary:
		// 		Same as an HTML radio, but with fancy styling.

		type: "radio",
		baseClass: "dijitRadio",

		_setCheckedAttr: function(/*Boolean*/ value){
			// If I am being checked then have to deselect currently checked radio button
			this.inherited(arguments);
			if(!this._created){ return; }
			if(value){
				var _this = this;
				// search for radio buttons with the same name that need to be unchecked
				dojo.query("INPUT[type=radio]", this.focusNode.form || dojo.doc).forEach( // can't use name= since dojo.query doesn't support [] in the name
					function(inputNode){
						if(inputNode.name == _this.name && inputNode != _this.focusNode && inputNode.form == _this.focusNode.form){
							var widget = dijit.getEnclosingWidget(inputNode);
							if(widget && widget.checked){
								widget.attr('checked', false);
							}
						}
					}
				);
			}
		},

		_clicked: function(/*Event*/ e){
			if(!this.checked){
				this.attr('checked', true);
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.form.DropDownButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.DropDownButton"] = true;
dojo.provide("dijit.form.DropDownButton");



}

if(!dojo._hasResource["dojo.dnd.common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.common"] = true;
dojo.provide("dojo.dnd.common");

dojo.dnd.getCopyKeyState = dojo.isCopyKeyPressed;

dojo.dnd._uniqueId = 0;
dojo.dnd.getUniqueId = function(){
	// summary:
	//		returns a unique string for use with any DOM element
	var id;
	do{
		id = dojo._scopeName + "Unique" + (++dojo.dnd._uniqueId);
	}while(dojo.byId(id));
	return id;
};

dojo.dnd._empty = {};

dojo.dnd.isFormElement = function(/*Event*/ e){
	// summary:
	//		returns true if user clicked on a form element
	var t = e.target;
	if(t.nodeType == 3 /*TEXT_NODE*/){
		t = t.parentNode;
	}
	return " button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;	// Boolean
};

}

if(!dojo._hasResource["dojo.dnd.autoscroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.autoscroll"] = true;
dojo.provide("dojo.dnd.autoscroll");

dojo.dnd.getViewport = function(){
	// summary:
	//		Returns a viewport size (visible part of the window)

	// TODO: remove this when getViewport() moved to dojo core, see #7028

	// FIXME: need more docs!!
	var d = dojo.doc, dd = d.documentElement, w = window, b = dojo.body();
	if(dojo.isMozilla){
		return {w: dd.clientWidth, h: w.innerHeight};	// Object
	}else if(!dojo.isOpera && w.innerWidth){
		return {w: w.innerWidth, h: w.innerHeight};		// Object
	}else if (!dojo.isOpera && dd && dd.clientWidth){
		return {w: dd.clientWidth, h: dd.clientHeight};	// Object
	}else if (b.clientWidth){
		return {w: b.clientWidth, h: b.clientHeight};	// Object
	}
	return null;	// Object
};

dojo.dnd.V_TRIGGER_AUTOSCROLL = 32;
dojo.dnd.H_TRIGGER_AUTOSCROLL = 32;

dojo.dnd.V_AUTOSCROLL_VALUE = 16;
dojo.dnd.H_AUTOSCROLL_VALUE = 16;

dojo.dnd.autoScroll = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the window, if
	//		necesary
	// e: Event
	//		onmousemove event

	// FIXME: needs more docs!
	var v = dojo.dnd.getViewport(), dx = 0, dy = 0;
	if(e.clientX < dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = -dojo.dnd.H_AUTOSCROLL_VALUE;
	}else if(e.clientX > v.w - dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = dojo.dnd.H_AUTOSCROLL_VALUE;
	}
	if(e.clientY < dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = -dojo.dnd.V_AUTOSCROLL_VALUE;
	}else if(e.clientY > v.h - dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = dojo.dnd.V_AUTOSCROLL_VALUE;
	}
	window.scrollBy(dx, dy);
};

dojo.dnd._validNodes = {"div": 1, "p": 1, "td": 1};
dojo.dnd._validOverflow = {"auto": 1, "scroll": 1};

dojo.dnd.autoScrollNodes = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the first avaialble
	//		Dom element, it falls back to dojo.dnd.autoScroll()
	// e: Event
	//		onmousemove event

	// FIXME: needs more docs!
	for(var n = e.target; n;){
		if(n.nodeType == 1 && (n.tagName.toLowerCase() in dojo.dnd._validNodes)){
			var s = dojo.getComputedStyle(n);
			if(s.overflow.toLowerCase() in dojo.dnd._validOverflow){
				var b = dojo._getContentBox(n, s), t = dojo.position(n, true);
				//console.log(b.l, b.t, t.x, t.y, n.scrollLeft, n.scrollTop);
				var w = Math.min(dojo.dnd.H_TRIGGER_AUTOSCROLL, b.w / 2), 
					h = Math.min(dojo.dnd.V_TRIGGER_AUTOSCROLL, b.h / 2),
					rx = e.pageX - t.x, ry = e.pageY - t.y, dx = 0, dy = 0;
				if(dojo.isWebKit || dojo.isOpera){
					// FIXME: this code should not be here, it should be taken into account 
					// either by the event fixing code, or the dojo.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					rx += dojo.body().scrollLeft, ry += dojo.body().scrollTop;
				}
				if(rx > 0 && rx < b.w){
					if(rx < w){
						dx = -w;
					}else if(rx > b.w - w){
						dx = w;
					}
				}
				//console.log("ry =", ry, "b.h =", b.h, "h =", h);
				if(ry > 0 && ry < b.h){
					if(ry < h){
						dy = -h;
					}else if(ry > b.h - h){
						dy = h;
					}
				}
				var oldLeft = n.scrollLeft, oldTop = n.scrollTop;
				n.scrollLeft = n.scrollLeft + dx;
				n.scrollTop  = n.scrollTop  + dy;
				if(oldLeft != n.scrollLeft || oldTop != n.scrollTop){ return; }
			}
		}
		try{
			n = n.parentNode;
		}catch(x){
			n = null;
		}
	}
	dojo.dnd.autoScroll(e);
};

}

if(!dojo._hasResource["dojo.dnd.Mover"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Mover"] = true;
dojo.provide("dojo.dnd.Mover");




dojo.declare("dojo.dnd.Mover", null, {
	constructor: function(node, e, host){
		// summary:
		//		an object, which makes a node follow the mouse. 
		//		Used as a default mover, and as a base class for custom movers.
		// node: Node
		//		a node (or node's id) to be moved
		// e: Event
		//		a mouse event, which started the move;
		//		only pageX and pageY properties are used
		// host: Object?
		//		object which implements the functionality of the move,
		//	 	and defines proper events (onMoveStart and onMoveStop)
		this.node = dojo.byId(node);
		this.marginBox = {l: e.pageX, t: e.pageY};
		this.mouseButton = e.button;
		var h = this.host = host, d = node.ownerDocument, 
			firstEvent = dojo.connect(d, "onmousemove", this, "onFirstMove");
		this.events = [
			dojo.connect(d, "onmousemove", this, "onMouseMove"),
			dojo.connect(d, "onmouseup",   this, "onMouseUp"),
			// cancel text selection and text dragging
			dojo.connect(d, "ondragstart",   dojo.stopEvent),
			dojo.connect(d.body, "onselectstart", dojo.stopEvent),
			firstEvent
		];
		// notify that the move has started
		if(h && h.onMoveStart){
			h.onMoveStart(this);
		}
	},
	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		dojo.dnd.autoScroll(e);
		var m = this.marginBox;
		this.host.onMove(this, {l: m.l + e.pageX, t: m.t + e.pageY});
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		if(dojo.isWebKit && dojo.isMac && this.mouseButton == 2 ? 
				e.button == 0 : this.mouseButton == e.button){
			this.destroy();
		}
		dojo.stopEvent(e);
	},
	// utilities
	onFirstMove: function(){
		// summary:
		//		makes the node absolute; it is meant to be called only once. 
		// 		relative and absolutely positioned nodes are assumed to use pixel units
		var s = this.node.style, l, t, h = this.host;
		switch(s.position){
			case "relative":
			case "absolute":
				// assume that left and top values are in pixels already
				l = Math.round(parseFloat(s.left));
				t = Math.round(parseFloat(s.top));
				break;
			default:
				s.position = "absolute";	// enforcing the absolute mode
				var m = dojo.marginBox(this.node);
				// event.pageX/pageY (which we used to generate the initial
				// margin box) includes padding and margin set on the body.
				// However, setting the node's position to absolute and then
				// doing dojo.marginBox on it *doesn't* take that additional
				// space into account - so we need to subtract the combined
				// padding and margin.  We use getComputedStyle and
				// _getMarginBox/_getContentBox to avoid the extra lookup of
				// the computed style. 
				var b = dojo.doc.body;
				var bs = dojo.getComputedStyle(b);
				var bm = dojo._getMarginBox(b, bs);
				var bc = dojo._getContentBox(b, bs);
				l = m.l - (bc.l - bm.l);
				t = m.t - (bc.t - bm.t);
				break;
		}
		this.marginBox.l = l - this.marginBox.l;
		this.marginBox.t = t - this.marginBox.t;
		if(h && h.onFirstMove){
			h.onFirstMove(this);
		}
		dojo.disconnect(this.events.pop());
	},
	destroy: function(){
		// summary:
		//		stops the move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		// undo global settings
		var h = this.host;
		if(h && h.onMoveStop){
			h.onMoveStop(this);
		}
		// destroy objects
		this.events = this.node = this.host = null;
	}
});

}

if(!dojo._hasResource["dojo.dnd.Moveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Moveable"] = true;
dojo.provide("dojo.dnd.Moveable");



/*=====
dojo.declare("dojo.dnd.__MoveableArgs", [], {
	// handle: Node||String
	//		A node (or node's id), which is used as a mouse handle.
	//		If omitted, the node itself is used as a handle.
	handle: null,

	// delay: Number
	//		delay move by this number of pixels
	delay: 0,

	// skip: Boolean
	//		skip move of form elements
	skip: false,

	// mover: Object
	//		a constructor of custom Mover
	mover: dojo.dnd.Mover
});
=====*/

dojo.declare("dojo.dnd.Moveable", null, {
	// object attributes (for markup)
	handle: "",
	delay: 0,
	skip: false,
	
	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.__MoveableArgs?
		//		optional parameters
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.handle = params.handle ? dojo.byId(params.handle) : null;
		if(!this.handle){ this.handle = this.node; }
		this.delay = params.delay > 0 ? params.delay : 0;
		this.skip  = params.skip;
		this.mover = params.mover ? params.mover : dojo.dnd.Mover;
		this.events = [
			dojo.connect(this.handle, "onmousedown", this, "onMouseDown"),
			// cancel text selection and text dragging
			dojo.connect(this.handle, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.handle, "onselectstart", this, "onSelectStart")
		];
	},

	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.Moveable(node, params);
	},

	// methods
	destroy: function(){
		// summary:
		//		stops watching for possible move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.events = this.node = this.handle = null;
	},
	
	// mouse event processors
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown, creates a Mover for the node
		// e: Event
		//		mouse event
		if(this.skip && dojo.dnd.isFormElement(e)){ return; }
		if(this.delay){
			this.events.push(
				dojo.connect(this.handle, "onmousemove", this, "onMouseMove"),
				dojo.connect(this.handle, "onmouseup", this, "onMouseUp")
			);
			this._lastX = e.pageX;
			this._lastY = e.pageY;
		}else{
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove, used only for delayed drags
		// e: Event
		//		mouse event
		if(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay){
			this.onMouseUp(e);
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup, used only for delayed drags
		// e: Event
		//		mouse event
		for(var i = 0; i < 2; ++i){
			dojo.disconnect(this.events.pop());
		}
		dojo.stopEvent(e);
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skip || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},
	
	// local events
	onDragDetected: function(/* Event */ e){
		// summary:
		//		called when the drag is detected;
		//		responsible for creation of the mover
		new this.mover(this.node, e, this);
	},
	onMoveStart: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called before every move operation
		dojo.publish("/dnd/move/start", [mover]);
		dojo.addClass(dojo.body(), "dojoMove"); 
		dojo.addClass(this.node, "dojoMoveItem"); 
	},
	onMoveStop: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called after every move operation
		dojo.publish("/dnd/move/stop", [mover]);
		dojo.removeClass(dojo.body(), "dojoMove");
		dojo.removeClass(this.node, "dojoMoveItem");
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called during the very first move notification;
		//		can be used to initialize coordinates, can be overwritten.
		
		// default implementation does nothing
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called during every move notification;
		//		should actually move the node; can be overwritten.
		this.onMoving(mover, leftTop);
		var s = mover.node.style;
		s.left = leftTop.l + "px";
		s.top  = leftTop.t + "px";
		this.onMoved(mover, leftTop);
	},
	onMoving: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called before every incremental move; can be overwritten.
		
		// default implementation does nothing
	},
	onMoved: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called after every incremental move; can be overwritten.
		
		// default implementation does nothing
	}
});

}

if(!dojo._hasResource["dojo.dnd.move"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.move"] = true;
dojo.provide("dojo.dnd.move");




/*=====
dojo.declare("dojo.dnd.move.__constrainedMoveableArgs", [dojo.dnd.__MoveableArgs], {
	// constraints: Function
	//		Calculates a constraint box.
	//		It is called in a context of the moveable object.
	constraints: function(){},

	// within: Boolean
	//		restrict move within boundaries.
	within: false
});
=====*/

dojo.declare("dojo.dnd.move.constrainedMoveable", dojo.dnd.Moveable, {
	// object attributes (for markup)
	constraints: function(){},
	within: false,
	
	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.constrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary:
		//		an object that makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.move.__constrainedMoveableArgs?
		//		an optional object with additional parameters;
		//		the rest is passed to the base class
		if(!params){ params = {}; }
		this.constraints = params.constraints;
		this.within = params.within;
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called during the very first move notification;
		//		can be used to initialize coordinates, can be overwritten.
		var c = this.constraintBox = this.constraints.call(this, mover);
		c.r = c.l + c.w;
		c.b = c.t + c.h;
		if(this.within){
			var mb = dojo.marginBox(mover.node);
			c.r -= mb.w;
			c.b -= mb.h;
		}
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called during every move notification;
		//		should actually move the node; can be overwritten.
		var c = this.constraintBox, s = mover.node.style;
		s.left = (leftTop.l < c.l ? c.l : c.r < leftTop.l ? c.r : leftTop.l) + "px";
		s.top  = (leftTop.t < c.t ? c.t : c.b < leftTop.t ? c.b : leftTop.t) + "px";
	}
});

/*=====
dojo.declare("dojo.dnd.move.__boxConstrainedMoveableArgs", [dojo.dnd.move.__constrainedMoveableArgs], {
	// box: Object
	//		a constraint box
	box: {}
});
=====*/

dojo.declare("dojo.dnd.move.boxConstrainedMoveable", dojo.dnd.move.constrainedMoveable, {
	// box:
	//		object attributes (for markup)
	box: {},
	
	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.boxConstrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.move.__boxConstrainedMoveableArgs?
		//		an optional object with parameters
		var box = params && params.box;
		this.constraints = function(){ return box; };
	}
});

/*=====
dojo.declare("dojo.dnd.move.__parentConstrainedMoveableArgs", [dojo.dnd.move.__constrainedMoveableArgs], {
	// area: String
	//		A parent's area to restrict the move.
	//		Can be "margin", "border", "padding", or "content".
	area: ""
});
=====*/

dojo.declare("dojo.dnd.move.parentConstrainedMoveable", dojo.dnd.move.constrainedMoveable, {
	// area:
	//		object attributes (for markup)
	area: "content",

	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.parentConstrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.move.__parentConstrainedMoveableArgs?
		//		an optional object with parameters
		var area = params && params.area;
		this.constraints = function(){
			var n = this.node.parentNode, 
				s = dojo.getComputedStyle(n), 
				mb = dojo._getMarginBox(n, s);
			if(area == "margin"){
				return mb;	// Object
			}
			var t = dojo._getMarginExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			if(area == "border"){
				return mb;	// Object
			}
			t = dojo._getBorderExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			if(area == "padding"){
				return mb;	// Object
			}
			t = dojo._getPadExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			return mb;	// Object
		};
	}
});

// WARNING: below are obsolete objects, instead of custom movers use custom moveables (above)

dojo.dnd.move.constrainedMover = function(fun, within){
	// summary:
	//		returns a constrained version of dojo.dnd.Mover
	// description:
	//		this function produces n object, which will put a constraint on 
	//		the margin box of dragged object in absolute coordinates
	// fun: Function
	//		called on drag, and returns a constraint box
	// within: Boolean
	//		if true, constraints the whole dragged object withtin the rectangle, 
	//		otherwise the constraint is applied to the left-top corner

	dojo.deprecated("dojo.dnd.move.constrainedMover, use dojo.dnd.move.constrainedMoveable instead");
	var mover = function(node, e, notifier){
		dojo.dnd.Mover.call(this, node, e, notifier);
	};
	dojo.extend(mover, dojo.dnd.Mover.prototype);
	dojo.extend(mover, {
		onMouseMove: function(e){
			// summary: event processor for onmousemove
			// e: Event: mouse event
			dojo.dnd.autoScroll(e);
			var m = this.marginBox, c = this.constraintBox,
				l = m.l + e.pageX, t = m.t + e.pageY;
			l = l < c.l ? c.l : c.r < l ? c.r : l;
			t = t < c.t ? c.t : c.b < t ? c.b : t;
			this.host.onMove(this, {l: l, t: t});
		},
		onFirstMove: function(){
			// summary: called once to initialize things; it is meant to be called only once
			dojo.dnd.Mover.prototype.onFirstMove.call(this);
			var c = this.constraintBox = fun.call(this);
			c.r = c.l + c.w;
			c.b = c.t + c.h;
			if(within){
				var mb = dojo.marginBox(this.node);
				c.r -= mb.w;
				c.b -= mb.h;
			}
		}
	});
	return mover;	// Object
};

dojo.dnd.move.boxConstrainedMover = function(box, within){
	// summary:
	//		a specialization of dojo.dnd.constrainedMover, which constrains to the specified box
	// box: Object
	//		a constraint box (l, t, w, h)
	// within: Boolean
	//		if true, constraints the whole dragged object withtin the rectangle, 
	//		otherwise the constraint is applied to the left-top corner

	dojo.deprecated("dojo.dnd.move.boxConstrainedMover, use dojo.dnd.move.boxConstrainedMoveable instead");
	return dojo.dnd.move.constrainedMover(function(){ return box; }, within);	// Object
};

dojo.dnd.move.parentConstrainedMover = function(area, within){
	// summary:
	//		a specialization of dojo.dnd.constrainedMover, which constrains to the parent node
	// area: String
	//		"margin" to constrain within the parent's margin box, "border" for the border box,
	//		"padding" for the padding box, and "content" for the content box; "content" is the default value.
	// within: Boolean
	//		if true, constraints the whole dragged object within the rectangle, 
	//		otherwise the constraint is applied to the left-top corner

	dojo.deprecated("dojo.dnd.move.parentConstrainedMover, use dojo.dnd.move.parentConstrainedMoveable instead");
	var fun = function(){
		var n = this.node.parentNode, 
			s = dojo.getComputedStyle(n), 
			mb = dojo._getMarginBox(n, s);
		if(area == "margin"){
			return mb;	// Object
		}
		var t = dojo._getMarginExtents(n, s);
		mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
		if(area == "border"){
			return mb;	// Object
		}
		t = dojo._getBorderExtents(n, s);
		mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
		if(area == "padding"){
			return mb;	// Object
		}
		t = dojo._getPadExtents(n, s);
		mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
		return mb;	// Object
	};
	return dojo.dnd.move.constrainedMover(fun, within);	// Object
};

// patching functions one level up for compatibility

dojo.dnd.constrainedMover = dojo.dnd.move.constrainedMover;
dojo.dnd.boxConstrainedMover = dojo.dnd.move.boxConstrainedMover;
dojo.dnd.parentConstrainedMover = dojo.dnd.move.parentConstrainedMover;

}

if(!dojo._hasResource["dojo.dnd.TimedMoveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.TimedMoveable"] = true;
dojo.provide("dojo.dnd.TimedMoveable");



/*=====
dojo.declare("dojo.dnd.__TimedMoveableArgs", [dojo.dnd.__MoveableArgs], {
	// timeout: Number
	//		delay move by this number of ms,
	//		accumulating position changes during the timeout
	timeout: 0
});
=====*/

(function(){
	// precalculate long expressions
	var oldOnMove = dojo.dnd.Moveable.prototype.onMove;
		
	dojo.declare("dojo.dnd.TimedMoveable", dojo.dnd.Moveable, {
		// summary:
		//		A specialized version of Moveable to support an FPS throttling.
		//		This class puts an upper restriction on FPS, which may reduce 
		//		the CPU load. The additional parameter "timeout" regulates
		//		the delay before actually moving the moveable object.
		
		// object attributes (for markup)
		timeout: 40,	// in ms, 40ms corresponds to 25 fps
	
		constructor: function(node, params){
			// summary:
			//		an object that makes a node moveable with a timer
			// node: Node||String
			//		a node (or node's id) to be moved
			// params: dojo.dnd.__TimedMoveableArgs
			//		object with additional parameters.
			
			// sanitize parameters
			if(!params){ params = {}; }
			if(params.timeout && typeof params.timeout == "number" && params.timeout >= 0){
				this.timeout = params.timeout;
			}
		},
	
		// markup methods
		markupFactory: function(params, node){
			return new dojo.dnd.TimedMoveable(node, params);
		},
	
		onMoveStop: function(/* dojo.dnd.Mover */ mover){
			if(mover._timer){
				// stop timer
				clearTimeout(mover._timer)
				// reflect the last received position
				oldOnMove.call(this, mover, mover._leftTop)
			}
			dojo.dnd.Moveable.prototype.onMoveStop.apply(this, arguments);
		},
		onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
			mover._leftTop = leftTop;
			if(!mover._timer){
				var _t = this;	// to avoid using dojo.hitch()
				mover._timer = setTimeout(function(){
					// we don't have any pending requests
					mover._timer = null;
					// reflect the last received position
					oldOnMove.call(_t, mover, mover._leftTop);
				}, this.timeout);
			}
		}
	});
})();

}

if(!dojo._hasResource["dojo.fx.Toggler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx.Toggler"] = true;
dojo.provide("dojo.fx.Toggler");

dojo.declare("dojo.fx.Toggler", null, {
	// summary:
	//		A simple `dojo.Animation` toggler API.
	//
	// description:
	//		class constructor for an animation toggler. It accepts a packed
	//		set of arguments about what type of animation to use in each
	//		direction, duration, etc. All available members are mixed into 
	//		these animations from the constructor (for example, `node`, 
	//		`showDuration`, `hideDuration`). 
	//
	// example:
	//	|	var t = new dojo.fx.Toggler({
	//	|		node: "nodeId",
	//	|		showDuration: 500,
	//	|		// hideDuration will default to "200"
	//	|		showFunc: dojo.fx.wipeIn, 
	//	|		// hideFunc will default to "fadeOut"
	//	|	});
	//	|	t.show(100); // delay showing for 100ms
	//	|	// ...time passes...
	//	|	t.hide();

	// node: DomNode
	//		the node to target for the showing and hiding animations
	node: null,

	// showFunc: Function
	//		The function that returns the `dojo.Animation` to show the node
	showFunc: dojo.fadeIn,

	// hideFunc: Function	
	//		The function that returns the `dojo.Animation` to hide the node
	hideFunc: dojo.fadeOut,

	// showDuration:
	//		Time in milliseconds to run the show Animation
	showDuration: 200,

	// hideDuration:
	//		Time in milliseconds to run the hide Animation
	hideDuration: 200,

	// FIXME: need a policy for where the toggler should "be" the next
	// time show/hide are called if we're stopped somewhere in the
	// middle.
	// FIXME: also would be nice to specify individual showArgs/hideArgs mixed into
	// each animation individually. 
	// FIXME: also would be nice to have events from the animations exposed/bridged

	/*=====
	_showArgs: null,
	_showAnim: null,

	_hideArgs: null,
	_hideAnim: null,

	_isShowing: false,
	_isHiding: false,
	=====*/

	constructor: function(args){
		var _t = this;

		dojo.mixin(_t, args);
		_t.node = args.node;
		_t._showArgs = dojo.mixin({}, args);
		_t._showArgs.node = _t.node;
		_t._showArgs.duration = _t.showDuration;
		_t.showAnim = _t.showFunc(_t._showArgs);

		_t._hideArgs = dojo.mixin({}, args);
		_t._hideArgs.node = _t.node;
		_t._hideArgs.duration = _t.hideDuration;
		_t.hideAnim = _t.hideFunc(_t._hideArgs);

		dojo.connect(_t.showAnim, "beforeBegin", dojo.hitch(_t.hideAnim, "stop", true));
		dojo.connect(_t.hideAnim, "beforeBegin", dojo.hitch(_t.showAnim, "stop", true));
	},

	show: function(delay){
		// summary: Toggle the node to showing
		// delay: Integer?
		//		Ammount of time to stall playing the show animation
		return this.showAnim.play(delay || 0);
	},

	hide: function(delay){
		// summary: Toggle the node to hidden
		// delay: Integer?
		//		Ammount of time to stall playing the hide animation
		return this.hideAnim.play(delay || 0);
	}
});

}

if(!dojo._hasResource["dojo.fx"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx"] = true;
dojo.provide("dojo.fx");
 // FIXME: remove this back-compat require in 2.0 
/*=====
dojo.fx = {
	// summary: Effects library on top of Base animations
};
=====*/
(function(){
	
	var d = dojo, 
		_baseObj = {
			_fire: function(evt, args){
				if(this[evt]){
					this[evt].apply(this, args||[]);
				}
				return this;
			}
		};

	var _chain = function(animations){
		this._index = -1;
		this._animations = animations||[];
		this._current = this._onAnimateCtx = this._onEndCtx = null;

		this.duration = 0;
		d.forEach(this._animations, function(a){
			this.duration += a.duration;
			if(a.delay){ this.duration += a.delay; }
		}, this);
	};
	d.extend(_chain, {
		_onAnimate: function(){
			this._fire("onAnimate", arguments);
		},
		_onEnd: function(){
			d.disconnect(this._onAnimateCtx);
			d.disconnect(this._onEndCtx);
			this._onAnimateCtx = this._onEndCtx = null;
			if(this._index + 1 == this._animations.length){
				this._fire("onEnd");
			}else{
				// switch animations
				this._current = this._animations[++this._index];
				this._onAnimateCtx = d.connect(this._current, "onAnimate", this, "_onAnimate");
				this._onEndCtx = d.connect(this._current, "onEnd", this, "_onEnd");
				this._current.play(0, true);
			}
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			if(!this._current){ this._current = this._animations[this._index = 0]; }
			if(!gotoStart && this._current.status() == "playing"){ return this; }
			var beforeBegin = d.connect(this._current, "beforeBegin", this, function(){
					this._fire("beforeBegin");
				}),
				onBegin = d.connect(this._current, "onBegin", this, function(arg){
					this._fire("onBegin", arguments);
				}),
				onPlay = d.connect(this._current, "onPlay", this, function(arg){
					this._fire("onPlay", arguments);
					d.disconnect(beforeBegin);
					d.disconnect(onBegin);
					d.disconnect(onPlay);
				});
			if(this._onAnimateCtx){
				d.disconnect(this._onAnimateCtx);
			}
			this._onAnimateCtx = d.connect(this._current, "onAnimate", this, "_onAnimate");
			if(this._onEndCtx){
				d.disconnect(this._onEndCtx);
			}
			this._onEndCtx = d.connect(this._current, "onEnd", this, "_onEnd");
			this._current.play.apply(this._current, arguments);
			return this;
		},
		pause: function(){
			if(this._current){
				var e = d.connect(this._current, "onPause", this, function(arg){
						this._fire("onPause", arguments);
						d.disconnect(e);
					});
				this._current.pause();
			}
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			this.pause();
			var offset = this.duration * percent;
			this._current = null;
			d.some(this._animations, function(a){
				if(a.duration <= offset){
					this._current = a;
					return true;
				}
				offset -= a.duration;
				return false;
			});
			if(this._current){
				this._current.gotoPercent(offset / this._current.duration, andPlay);
			}
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			if(this._current){
				if(gotoEnd){
					for(; this._index + 1 < this._animations.length; ++this._index){
						this._animations[this._index].stop(true);
					}
					this._current = this._animations[this._index];
				}
				var e = d.connect(this._current, "onStop", this, function(arg){
						this._fire("onStop", arguments);
						d.disconnect(e);
					});
				this._current.stop();
			}
			return this;
		},
		status: function(){
			return this._current ? this._current.status() : "stopped";
		},
		destroy: function(){
			if(this._onAnimateCtx){ d.disconnect(this._onAnimateCtx); }
			if(this._onEndCtx){ d.disconnect(this._onEndCtx); }
		}
	});
	d.extend(_chain, _baseObj);

	dojo.fx.chain = function(/*dojo.Animation[]*/ animations){
		// summary: 
		//		Chain a list of `dojo.Animation`s to run in sequence
		//
		// description:
		//		Return a `dojo.Animation` which will play all passed
		//		`dojo.Animation` instances in sequence, firing its own
		//		synthesized events simulating a single animation. (eg:
		//		onEnd of this animation means the end of the chain, 
		//		not the individual animations within)
		//
		// example:
		//	Once `node` is faded out, fade in `otherNode`
		//	|	dojo.fx.chain([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		return new _chain(animations) // dojo.Animation
	};

	var _combine = function(animations){
		this._animations = animations||[];
		this._connects = [];
		this._finished = 0;

		this.duration = 0;
		d.forEach(animations, function(a){
			var duration = a.duration;
			if(a.delay){ duration += a.delay; }
			if(this.duration < duration){ this.duration = duration; }
			this._connects.push(d.connect(a, "onEnd", this, "_onEnd"));
		}, this);
		
		this._pseudoAnimation = new d.Animation({curve: [0, 1], duration: this.duration});
		var self = this;
		d.forEach(["beforeBegin", "onBegin", "onPlay", "onAnimate", "onPause", "onStop", "onEnd"], 
			function(evt){
				self._connects.push(d.connect(self._pseudoAnimation, evt,
					function(){ self._fire(evt, arguments); }
				));
			}
		);
	};
	d.extend(_combine, {
		_doAction: function(action, args){
			d.forEach(this._animations, function(a){
				a[action].apply(a, args);
			});
			return this;
		},
		_onEnd: function(){
			if(++this._finished > this._animations.length){
				this._fire("onEnd");
			}
		},
		_call: function(action, args){
			var t = this._pseudoAnimation;
			t[action].apply(t, args);
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			this._finished = 0;
			this._doAction("play", arguments);
			this._call("play", arguments);
			return this;
		},
		pause: function(){
			this._doAction("pause", arguments);
			this._call("pause", arguments);
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			var ms = this.duration * percent;
			d.forEach(this._animations, function(a){
				a.gotoPercent(a.duration < ms ? 1 : (ms / a.duration), andPlay);
			});
			this._call("gotoPercent", arguments);
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			this._doAction("stop", arguments);
			this._call("stop", arguments);
			return this;
		},
		status: function(){
			return this._pseudoAnimation.status();
		},
		destroy: function(){
			d.forEach(this._connects, dojo.disconnect);
		}
	});
	d.extend(_combine, _baseObj);

	dojo.fx.combine = function(/*dojo.Animation[]*/ animations){
		// summary: 
		//		Combine a list of `dojo.Animation`s to run in parallel
		//
		// description:
		//		Combine an array of `dojo.Animation`s to run in parallel, 
		//		providing a new `dojo.Animation` instance encompasing each
		//		animation, firing standard animation events.
		//
		// example:
		//	Fade out `node` while fading in `otherNode` simultaneously
		//	|	dojo.fx.combine([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		// example:
		//	When the longest animation ends, execute a function:
		//	|	var anim = dojo.fx.combine([
		//	|		dojo.fadeIn({ node: n, duration:700 }),
		//	|		dojo.fadeOut({ node: otherNode, duration: 300 })
		//	|	]);
		//	|	dojo.connect(anim, "onEnd", function(){
		//	|		// overall animation is done.
		//	|	});
		//	|	anim.play(); // play the animation
		//
		return new _combine(animations); // dojo.Animation
	};

	dojo.fx.wipeIn = function(/*Object*/ args){
		// summary:
		//		Expand a node to it's natural height.
		//
		// description:
		//		Returns an animation that will expand the
		//		node defined in 'args' object from it's current height to
		//		it's natural height (with no scrollbar).
		//		Node must have no margin/border/padding.
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		//
		// example:
		//	|	dojo.fx.wipeIn({
		//	|		node:"someId"
		//	|	}).play()
		var node = args.node = d.byId(args.node), s = node.style, o;

		var anim = d.animateProperty(d.mixin({
			properties: {
				height: {
					// wrapped in functions so we wait till the last second to query (in case value has changed)
					start: function(){
						// start at current [computed] height, but use 1px rather than 0
						// because 0 causes IE to display the whole panel
						o = s.overflow;
						s.overflow = "hidden";
						if(s.visibility == "hidden" || s.display == "none"){
							s.height = "1px";
							s.display = "";
							s.visibility = "";
							return 1;
						}else{
							var height = d.style(node, "height");
							return Math.max(height, 1);
						}
					},
					end: function(){
						return node.scrollHeight;
					}
				}
			}
		}, args));

		d.connect(anim, "onEnd", function(){ 
			s.height = "auto";
			s.overflow = o;
		});

		return anim; // dojo.Animation
	}

	dojo.fx.wipeOut = function(/*Object*/ args){
		// summary:
		//		Shrink a node to nothing and hide it. 
		//
		// description:
		//		Returns an animation that will shrink node defined in "args"
		//		from it's current height to 1px, and then hide it.
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		// 
		// example:
		//	|	dojo.fx.wipeOut({ node:"someId" }).play()
		
		var node = args.node = d.byId(args.node), s = node.style, o;
		
		var anim = d.animateProperty(d.mixin({
			properties: {
				height: {
					end: 1 // 0 causes IE to display the whole panel
				}
			}
		}, args));

		d.connect(anim, "beforeBegin", function(){
			o = s.overflow;
			s.overflow = "hidden";
			s.display = "";
		});
		d.connect(anim, "onEnd", function(){
			s.overflow = o;
			s.height = "auto";
			s.display = "none";
		});

		return anim; // dojo.Animation
	}

	dojo.fx.slideTo = function(/*Object*/ args){
		// summary:
		//		Slide a node to a new top/left position
		//
		// description:
		//		Returns an animation that will slide "node" 
		//		defined in args Object from its current position to
		//		the position defined by (args.left, args.top).
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on). Special args members
		//		are `top` and `left`, which indicate the new position to slide to.
		//
		// example:
		//	|	dojo.fx.slideTo({ node: node, left:"40", top:"50", units:"px" }).play()

		var node = args.node = d.byId(args.node), 
			top = null, left = null;

		var init = (function(n){
			return function(){
				var cs = d.getComputedStyle(n);
				var pos = cs.position;
				top = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);
				left = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);
				if(pos != 'absolute' && pos != 'relative'){
					var ret = d.position(n, true);
					top = ret.y;
					left = ret.x;
					n.style.position="absolute";
					n.style.top=top+"px";
					n.style.left=left+"px";
				}
			};
		})(node);
		init();

		var anim = d.animateProperty(d.mixin({
			properties: {
				top: args.top || 0,
				left: args.left || 0
			}
		}, args));
		d.connect(anim, "beforeBegin", anim, init);

		return anim; // dojo.Animation
	}

})();

}

if(!dojo._hasResource["dijit._DialogMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._DialogMixin"] = true;
dojo.provide("dijit._DialogMixin");

dojo.declare("dijit._DialogMixin", null,
	{
		// summary:
		//		This provides functions useful to Dialog and TooltipDialog

		attributeMap: dijit._Widget.prototype.attributeMap,

		execute: function(/*Object*/ formContents){
			// summary:
			//		Callback when the user hits the submit button.
			//		Override this method to handle Dialog execution.
			// description:
			//		After the user has pressed the submit button, the Dialog
			//		first calls onExecute() to notify the container to hide the
			//		dialog and restore focus to wherever it used to be.
			//
			//		*Then* this method is called.
			// type:
			//		callback
		},

		onCancel: function(){
			// summary:
			//	    Called when user has pressed the Dialog's cancel button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		onExecute: function(){
			// summary:
			//	    Called when user has pressed the dialog's OK button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		_onSubmit: function(){
			// summary:
			//		Callback when user hits submit button
			// type:
			//		protected
			this.onExecute();	// notify container that we are about to execute
			this.execute(this.attr('value'));
		},

		_getFocusItems: function(/*Node*/ dialogNode){
			// summary:
			//		Find focusable Items each time a dialog is opened,
			//		setting _firstFocusItem and _lastFocusItem
			// tags:
			//		protected

			var elems = dijit._getTabNavigable(dojo.byId(dialogNode));
			this._firstFocusItem = elems.lowest || elems.first || dialogNode;
			this._lastFocusItem = elems.last || elems.highest || this._firstFocusItem;
			if(dojo.isMoz && this._firstFocusItem.tagName.toLowerCase() == "input" &&
					dojo.getNodeProp(this._firstFocusItem, "type").toLowerCase() == "file"){
				// FF doesn't behave well when first element is input type=file, set first focusable to dialog container
				dojo.attr(dialogNode, "tabIndex", "0");
				this._firstFocusItem = dialogNode;
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.DialogUnderlay"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.DialogUnderlay"] = true;
dojo.provide("dijit.DialogUnderlay");




dojo.declare(
	"dijit.DialogUnderlay",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		The component that blocks the screen behind a `dijit.Dialog`
		//
		// description:
		// 		A component used to block input behind a `dijit.Dialog`. Only a single
		//		instance of this widget is created by `dijit.Dialog`, and saved as
		//		a reference to be shared between all Dialogs as `dijit._underlay`
		//
		//		The underlay itself can be styled based on and id:
		//	|	#myDialog_underlay { background-color:red; }
		//
		//		In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
		//		suffixed with _underlay.

		// Template has two divs; outer div is used for fade-in/fade-out, and also to hold background iframe.
		// Inner div has opacity specified in CSS file.
		templateString: "<div class='dijitDialogUnderlayWrapper'><div class='dijitDialogUnderlay' dojoAttachPoint='node'></div></div>",

		// Parameters on creation or updatable later

		// dialogId: String
		//		Id of the dialog.... DialogUnderlay's id is based on this id
		dialogId: "",

		// class: String
		//		This class name is used on the DialogUnderlay node, in addition to dijitDialogUnderlay
		"class": "",

		attributeMap: { id: "domNode" },

		_setDialogIdAttr: function(id){
			dojo.attr(this.node, "id", id + "_underlay");
		},

		_setClassAttr: function(clazz){
			this.node.className = "dijitDialogUnderlay " + clazz;
		},

		postCreate: function(){
			// summary:
			//		Append the underlay to the body
			dojo.body().appendChild(this.domNode);
		},

		layout: function(){
			// summary:
			//		Sets the background to the size of the viewport
			//
			// description:
			//		Sets the background to the size of the viewport (rather than the size
			//		of the document) since we need to cover the whole browser window, even
			//		if the document is only a few lines long.
			// tags:
			//		private

			var is = this.node.style,
				os = this.domNode.style;

			// hide the background temporarily, so that the background itself isn't
			// causing scrollbars to appear (might happen when user shrinks browser
			// window and then we are called to resize)
			os.display = "none";

			// then resize and show
			var viewport = dijit.getViewport();
			os.top = viewport.t + "px";
			os.left = viewport.l + "px";
			is.width = viewport.w + "px";
			is.height = viewport.h + "px";
			os.display = "block";
		},

		show: function(){
			// summary:
			//		Show the dialog underlay
			this.domNode.style.display = "block";
			this.layout();
			this.bgIframe = new dijit.BackgroundIframe(this.domNode);
		},

		hide: function(){
			// summary:
			//		Hides the dialog underlay
			this.bgIframe.destroy();
			this.domNode.style.display = "none";
		},

		uninitialize: function(){
			if(this.bgIframe){
				this.bgIframe.destroy();
			}
			this.inherited(arguments);
		}
	}
);

}

if(!dojo._hasResource["dijit._Contained"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Contained"] = true;
dojo.provide("dijit._Contained");

dojo.declare("dijit._Contained",
		null,
		{
			// summary:
			//		Mixin for widgets that are children of a container widget
			//
			// example:
			// | 	// make a basic custom widget that knows about it's parents
			// |	dojo.declare("my.customClass",[dijit._Widget,dijit._Contained],{});

			getParent: function(){
				// summary:
				//		Returns the parent widget of this widget, assuming the parent
				//		specifies isContainer
				var parent = dijit.getEnclosingWidget(this.domNode.parentNode);
				return parent && parent.isContainer ? parent : null;
			},

			_getSibling: function(/*String*/ which){
				// summary:
				//      Returns next or previous sibling
				// which:
				//      Either "next" or "previous"
				// tags:
				//      private
				var node = this.domNode;
				do{
					node = node[which+"Sibling"];
				}while(node && node.nodeType != 1);
				return node && dijit.byNode(node);	// dijit._Widget
			},

			getPreviousSibling: function(){
				// summary:
				//		Returns null if this is the first child of the parent,
				//		otherwise returns the next element sibling to the "left".

				return this._getSibling("previous"); // dijit._Widget
			},

			getNextSibling: function(){
				// summary:
				//		Returns null if this is the last child of the parent,
				//		otherwise returns the next element sibling to the "right".

				return this._getSibling("next"); // dijit._Widget
			},

			getIndexInParent: function(){
				// summary:
				//		Returns the index of this widget within its container parent.
				//		It returns -1 if the parent does not exist, or if the parent
				//		is not a dijit._Container

				var p = this.getParent();
				if(!p || !p.getIndexOfChild){
					return -1; // int
				}
				return p.getIndexOfChild(this); // int
			}
		}
	);


}

if(!dojo._hasResource["dijit.layout._LayoutWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout._LayoutWidget"] = true;
dojo.provide("dijit.layout._LayoutWidget");





dojo.declare("dijit.layout._LayoutWidget",
	[dijit._Widget, dijit._Container, dijit._Contained],
	{
		// summary:
		//		Base class for a _Container widget which is responsible for laying out its children.
		//		Widgets which mixin this code must define layout() to manage placement and sizing of the children.

		// baseClass: [protected extension] String
		//		This class name is applied to the widget's domNode
		//		and also may be used to generate names for sub nodes,
		//		for example dijitTabContainer-content.
		baseClass: "dijitLayoutContainer",

		// isLayoutContainer: [protected] Boolean
		//		Indicates that this widget is going to call resize() on its
		//		children widgets, setting their size, when they become visible.
		isLayoutContainer: true,

		postCreate: function(){
			dojo.addClass(this.domNode, "dijitContainer");
			dojo.addClass(this.domNode, this.baseClass);

			this.inherited(arguments);
		},

		startup: function(){
			// summary:
			//		Called after all the widgets have been instantiated and their
			//		dom nodes have been inserted somewhere under dojo.doc.body.
			//
			//		Widgets should override this method to do any initialization
			//		dependent on other widgets existing, and then call
			//		this superclass method to finish things off.
			//
			//		startup() in subclasses shouldn't do anything
			//		size related because the size of the widget hasn't been set yet.

			if(this._started){ return; }

			// Need to call inherited first - so that child widgets get started
			// up correctly
			this.inherited(arguments);

			// If I am a not being controlled by a parent layout widget...
			var parent = this.getParent && this.getParent()
			if(!(parent && parent.isLayoutContainer)){
				// Do recursive sizing and layout of all my descendants
				// (passing in no argument to resize means that it has to glean the size itself)
				this.resize();

				// Since my parent isn't a layout container, and my style *may be* width=height=100%
				// or something similar (either set directly or via a CSS class),
				// monitor when my size changes so that I can re-layout.
				// For browsers where I can't directly monitor when my size changes,
				// monitor when the viewport changes size, which *may* indicate a size change for me.
				this.connect(dojo.isIE ? this.domNode : dojo.global, 'onresize', function(){
					// Using function(){} closure to ensure no arguments to resize.
					this.resize();
				});
			}
		},

		resize: function(changeSize, resultSize){
			// summary:
			//		Call this to resize a widget, or after its size has changed.
			// description:
			//		Change size mode:
			//			When changeSize is specified, changes the marginBox of this widget
			//			and forces it to relayout its contents accordingly.
			//			changeSize may specify height, width, or both.
			//
			//			If resultSize is specified it indicates the size the widget will
			//			become after changeSize has been applied.
			//
			//		Notification mode:
			//			When changeSize is null, indicates that the caller has already changed
			//			the size of the widget, or perhaps it changed because the browser
			//			window was resized.  Tells widget to relayout its contents accordingly.
			//
			//			If resultSize is also specified it indicates the size the widget has
			//			become.
			//
			//		In either mode, this method also:
			//			1. Sets this._borderBox and this._contentBox to the new size of
			//				the widget.  Queries the current domNode size if necessary.
			//			2. Calls layout() to resize contents (and maybe adjust child widgets).
			//
			// changeSize: Object?
			//		Sets the widget to this margin-box size and position.
			//		May include any/all of the following properties:
			//	|	{w: int, h: int, l: int, t: int}
			//
			// resultSize: Object?
			//		The margin-box size of this widget after applying changeSize (if
			//		changeSize is specified).  If caller knows this size and
			//		passes it in, we don't need to query the browser to get the size.
			//	|	{w: int, h: int}

			var node = this.domNode;

			// set margin box size, unless it wasn't specified, in which case use current size
			if(changeSize){
				dojo.marginBox(node, changeSize);

				// set offset of the node
				if(changeSize.t){ node.style.top = changeSize.t + "px"; }
				if(changeSize.l){ node.style.left = changeSize.l + "px"; }
			}

			// If either height or width wasn't specified by the user, then query node for it.
			// But note that setting the margin box and then immediately querying dimensions may return
			// inaccurate results, so try not to depend on it.
			var mb = resultSize || {};
			dojo.mixin(mb, changeSize || {});	// changeSize overrides resultSize
			if( !("h" in mb) || !("w" in mb) ){
				mb = dojo.mixin(dojo.marginBox(node), mb);	// just use dojo.marginBox() to fill in missing values
			}

			// Compute and save the size of my border box and content box
			// (w/out calling dojo.contentBox() since that may fail if size was recently set)
			var cs = dojo.getComputedStyle(node);
			var me = dojo._getMarginExtents(node, cs);
			var be = dojo._getBorderExtents(node, cs);
			var bb = (this._borderBox = {
				w: mb.w - (me.w + be.w),
				h: mb.h - (me.h + be.h)
			});
			var pe = dojo._getPadExtents(node, cs);
			this._contentBox = {
				l: dojo._toPixelValue(node, cs.paddingLeft),
				t: dojo._toPixelValue(node, cs.paddingTop),
				w: bb.w - pe.w,
				h: bb.h - pe.h
			};

			// Callback for widget to adjust size of its children
			this.layout();
		},

		layout: function(){
			// summary:
			//		Widgets override this method to size and position their contents/children.
			//		When this is called this._contentBox is guaranteed to be set (see resize()).
			//
			//		This is called after startup(), and also when the widget's size has been
			//		changed.
			// tags:
			//		protected extension
		},

		_setupChild: function(/*dijit._Widget*/child){
			// summary:
			//		Common setup for initial children and children which are added after startup
			// tags:
			//		protected extension

			dojo.addClass(child.domNode, this.baseClass+"-child");
			if(child.baseClass){
				dojo.addClass(child.domNode, this.baseClass+"-"+child.baseClass);
			}
		},

		addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
			// Overrides _Container.addChild() to call _setupChild()
			this.inherited(arguments);
			if(this._started){
				this._setupChild(child);
			}
		},

		removeChild: function(/*dijit._Widget*/ child){
			// Overrides _Container.removeChild() to remove class added by _setupChild()
			dojo.removeClass(child.domNode, this.baseClass+"-child");
			if(child.baseClass){
				dojo.removeClass(child.domNode, this.baseClass+"-"+child.baseClass);
			}
			this.inherited(arguments);
		}
	}
);

dijit.layout.marginBox2contentBox = function(/*DomNode*/ node, /*Object*/ mb){
	// summary:
	//		Given the margin-box size of a node, return its content box size.
	//		Functions like dojo.contentBox() but is more reliable since it doesn't have
	//		to wait for the browser to compute sizes.
	var cs = dojo.getComputedStyle(node);
	var me = dojo._getMarginExtents(node, cs);
	var pb = dojo._getPadBorderExtents(node, cs);
	return {
		l: dojo._toPixelValue(node, cs.paddingLeft),
		t: dojo._toPixelValue(node, cs.paddingTop),
		w: mb.w - (me.w + pb.w),
		h: mb.h - (me.h + pb.h)
	};
};

(function(){
	var capitalize = function(word){
		return word.substring(0,1).toUpperCase() + word.substring(1);
	};

	var size = function(widget, dim){
		// size the child
		widget.resize ? widget.resize(dim) : dojo.marginBox(widget.domNode, dim);

		// record child's size, but favor our own numbers when we have them.
		// the browser lies sometimes
		dojo.mixin(widget, dojo.marginBox(widget.domNode));
		dojo.mixin(widget, dim);
	};

	dijit.layout.layoutChildren = function(/*DomNode*/ container, /*Object*/ dim, /*Object[]*/ children){
		// summary
		//		Layout a bunch of child dom nodes within a parent dom node
		// container:
		//		parent node
		// dim:
		//		{l, t, w, h} object specifying dimensions of container into which to place children
		// children:
		//		an array like [ {domNode: foo, layoutAlign: "bottom" }, {domNode: bar, layoutAlign: "client"} ]

		// copy dim because we are going to modify it
		dim = dojo.mixin({}, dim);

		dojo.addClass(container, "dijitLayoutContainer");

		// Move "client" elements to the end of the array for layout.  a11y dictates that the author
		// needs to be able to put them in the document in tab-order, but this algorithm requires that
		// client be last.
		children = dojo.filter(children, function(item){ return item.layoutAlign != "client"; })
			.concat(dojo.filter(children, function(item){ return item.layoutAlign == "client"; }));

		// set positions/sizes
		dojo.forEach(children, function(child){
			var elm = child.domNode,
				pos = child.layoutAlign;

			// set elem to upper left corner of unused space; may move it later
			var elmStyle = elm.style;
			elmStyle.left = dim.l+"px";
			elmStyle.top = dim.t+"px";
			elmStyle.bottom = elmStyle.right = "auto";

			dojo.addClass(elm, "dijitAlign" + capitalize(pos));

			// set size && adjust record of remaining space.
			// note that setting the width of a <div> may affect its height.
			if(pos == "top" || pos == "bottom"){
				size(child, { w: dim.w });
				dim.h -= child.h;
				if(pos == "top"){
					dim.t += child.h;
				}else{
					elmStyle.top = dim.t + dim.h + "px";
				}
			}else if(pos == "left" || pos == "right"){
				size(child, { h: dim.h });
				dim.w -= child.w;
				if(pos == "left"){
					dim.l += child.w;
				}else{
					elmStyle.left = dim.l + dim.w + "px";
				}
			}else if(pos == "client"){
				size(child, dim);
			}
		});
	};

})();

}

if(!dojo._hasResource["dojo.html"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.html"] = true;
dojo.provide("dojo.html");

// the parser might be needed..
 

(function(){ // private scope, sort of a namespace

	// idCounter is incremented with each instantiation to allow asignment of a unique id for tracking, logging purposes
	var idCounter = 0, 
		d = dojo;
	
	dojo.html._secureForInnerHtml = function(/*String*/ cont){
		// summary:
		//		removes !DOCTYPE and title elements from the html string.
		// 
		//		khtml is picky about dom faults, you can't attach a style or <title> node as child of body
		//		must go into head, so we need to cut out those tags
		//	cont:
		//		An html string for insertion into the dom
		//	
		return cont.replace(/(?:\s*<!DOCTYPE\s[^>]+>|<title[^>]*>[\s\S]*?<\/title>)/ig, ""); // String
	};

/*====
	dojo.html._emptyNode = function(node){
		// summary:
		//		removes all child nodes from the given node
		//	node: DOMNode
		//		the parent element
	};
=====*/
	dojo.html._emptyNode = dojo.empty;

	dojo.html._setNodeContent = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont){
		// summary:
		//		inserts the given content into the given node
		//	node:
		//		the parent element
		//	content:
		//		the content to be set on the parent element. 
		//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
		
		// always empty
		d.empty(node);

		if(cont) {
			if(typeof cont == "string") {
				cont = d._toDom(cont, node.ownerDocument);
			}
			if(!cont.nodeType && d.isArrayLike(cont)) {
				// handle as enumerable, but it may shrink as we enumerate it
				for(var startlen=cont.length, i=0; i<cont.length; i=startlen==cont.length ? i+1 : 0) {
					d.place( cont[i], node, "last");
				}
			} else {
				// pass nodes, documentFragments and unknowns through to dojo.place
				d.place(cont, node, "last");
			}
		}

		// return DomNode
		return node;
	};

	// we wrap up the content-setting operation in a object
	dojo.declare("dojo.html._ContentSetter", null, 
		{
			// node: DomNode|String
			//		An node which will be the parent element that we set content into
			node: "",

			// content: String|DomNode|DomNode[]
			//		The content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes
			content: "",
			
			// id: String?
			//		Usually only used internally, and auto-generated with each instance 
			id: "",

			// cleanContent: Boolean
			//		Should the content be treated as a full html document, 
			//		and the real content stripped of <html>, <body> wrapper before injection
			cleanContent: false,
			
			// extractContent: Boolean
			//		Should the content be treated as a full html document, and the real content stripped of <html>, <body> wrapper before injection
			extractContent: false,

			// parseContent: Boolean
			//		Should the node by passed to the parser after the new content is set
			parseContent: false,
			
			// lifecyle methods
			constructor: function(/* Object */params, /* String|DomNode */node){
				//	summary:
				//		Provides a configurable, extensible object to wrap the setting on content on a node
				//		call the set() method to actually set the content..
 
				// the original params are mixed directly into the instance "this"
				dojo.mixin(this, params || {});

				// give precedence to params.node vs. the node argument
				// and ensure its a node, not an id string
				node = this.node = dojo.byId( this.node || node );
	
				if(!this.id){
					this.id = [
						"Setter",
						(node) ? node.id || node.tagName : "", 
						idCounter++
					].join("_");
				}

				if(! (this.node || node)){
					new Error(this.declaredClass + ": no node provided to " + this.id);
				}
			},
			set: function(/* String|DomNode|NodeList? */ cont, /* Object? */ params){
				// summary:
				//		front-end to the set-content sequence 
				//	cont:
				//		An html string, node or enumerable list of nodes for insertion into the dom
				//		If not provided, the object's content property will be used
				if(undefined !== cont){
					this.content = cont;
				}
				// in the re-use scenario, set needs to be able to mixin new configuration
				if(params){
					this._mixin(params);
				}

				this.onBegin();
				this.setContent();
				this.onEnd();

				return this.node;
			},
			setContent: function(){
				// summary:
				//		sets the content on the node 

				var node = this.node; 
				if(!node) {
					console.error("setContent given no node");
				}
				try{
					node = dojo.html._setNodeContent(node, this.content);
				}catch(e){
					// check if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
	
					// FIXME: need to allow the user to provide a content error message string
					var errMess = this.onContentError(e); 
					try{
						node.innerHTML = errMess;
					}catch(e){
						console.error('Fatal ' + this.declaredClass + '.setContent could not change content due to '+e.message, e);
					}
				}
				// always put back the node for the next method
				this.node = node; // DomNode
			},
			
			empty: function() {
				// summary
				//	cleanly empty out existing content

				// destroy any widgets from a previous run
				// NOTE: if you dont want this you'll need to empty 
				// the parseResults array property yourself to avoid bad things happenning
				if(this.parseResults && this.parseResults.length) {
					dojo.forEach(this.parseResults, function(w) {
						if(w.destroy){
							w.destroy();
						}
					});
					delete this.parseResults;
				}
				// this is fast, but if you know its already empty or safe, you could 
				// override empty to skip this step
				dojo.html._emptyNode(this.node);
			},
	
			onBegin: function(){
				// summary
				//		Called after instantiation, but before set(); 
				//		It allows modification of any of the object properties 
				//		- including the node and content provided - before the set operation actually takes place
				//		This default implementation checks for cleanContent and extractContent flags to 
				//		optionally pre-process html string content
				var cont = this.content;
	
				if(dojo.isString(cont)){
					if(this.cleanContent){
						cont = dojo.html._secureForInnerHtml(cont);
					}
  
					if(this.extractContent){
						var match = cont.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
						if(match){ cont = match[1]; }
					}
				}

				// clean out the node and any cruft associated with it - like widgets
				this.empty();
				
				this.content = cont;
				return this.node; /* DomNode */
			},
	
			onEnd: function(){
				// summary
				//		Called after set(), when the new content has been pushed into the node
				//		It provides an opportunity for post-processing before handing back the node to the caller
				//		This default implementation checks a parseContent flag to optionally run the dojo parser over the new content
				if(this.parseContent){
					// populates this.parseResults if you need those..
					this._parse();
				}
				return this.node; /* DomNode */
			},
	
			tearDown: function(){
				// summary
				//		manually reset the Setter instance if its being re-used for example for another set()
				// description
				//		tearDown() is not called automatically. 
				//		In normal use, the Setter instance properties are simply allowed to fall out of scope
				//		but the tearDown method can be called to explicitly reset this instance.
				delete this.parseResults; 
				delete this.node; 
				delete this.content; 
			},
  
			onContentError: function(err){
				return "Error occured setting content: " + err; 
			},
			
			_mixin: function(params){
				// mix properties/methods into the instance
				// TODO: the intention with tearDown is to put the Setter's state 
				// back to that of the original constructor (vs. deleting/resetting everything regardless of ctor params)
				// so we could do something here to move the original properties aside for later restoration
				var empty = {}, key;
				for(key in params){
					if(key in empty){ continue; }
					// TODO: here's our opportunity to mask the properties we dont consider configurable/overridable
					// .. but history shows we'll almost always guess wrong
					this[key] = params[key]; 
				}
			},
			_parse: function(){
				// summary: 
				//		runs the dojo parser over the node contents, storing any results in this.parseResults
				//		Any errors resulting from parsing are passed to _onError for handling

				var rootNode = this.node;
				try{
					// store the results (widgets, whatever) for potential retrieval
					this.parseResults = dojo.parser.parse(rootNode, true);
				}catch(e){
					this._onError('Content', e, "Error parsing in _ContentSetter#"+this.id);
				}
			},
  
			_onError: function(type, err, consoleText){
				// summary:
				//		shows user the string that is returned by on[type]Error
				//		overide/implement on[type]Error and return your own string to customize
				var errText = this['on' + type + 'Error'].call(this, err);
				if(consoleText){
					console.error(consoleText, err);
				}else if(errText){ // a empty string won't change current content
					dojo.html._setNodeContent(this.node, errText, true);
				}
			}
	}); // end dojo.declare()

	dojo.html.set = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Object? */ params){
			// summary:
			//		inserts (replaces) the given content into the given node. dojo.place(cont, node, "only")
			//		may be a better choice for simple HTML insertion.
			// description:
			//		Unless you need to use the params capabilities of this method, you should use
			//		dojo.place(cont, node, "only"). dojo.place() has more robust support for injecting
			//		an HTML string into the DOM, but it only handles inserting an HTML string as DOM
			//		elements, or inserting a DOM node. dojo.place does not handle NodeList insertions
			//		or the other capabilities as defined by the params object for this method.
			//	node:
			//		the parent element that will receive the content
			//	cont:
			//		the content to be set on the parent element. 
			//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
			//	params: 
			//		Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter
			//	example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage: 
			//		dojo.html.set(node, "some string"); 
			//		dojo.html.set(node, contentNode, {options}); 
			//		dojo.html.set(node, myNode.childNodes, {options}); 
		if(undefined == cont){
			console.warn("dojo.html.set: no cont argument provided, using empty string");
			cont = "";
		}	
		if(!params){
			// simple and fast
			return dojo.html._setNodeContent(node, cont, true);
		}else{ 
			// more options but slower
			// note the arguments are reversed in order, to match the convention for instantiation via the parser
			var op = new dojo.html._ContentSetter(dojo.mixin( 
					params, 
					{ content: cont, node: node } 
			));
			return op.set();
		}
	};
})();

}

if(!dojo._hasResource["dijit.layout.ContentPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.ContentPane"] = true;
dojo.provide("dijit.layout.ContentPane");



	// for dijit.layout.marginBox2contentBox()






dojo.declare(
	"dijit.layout.ContentPane", dijit._Widget,
{
	// summary:
	//		A widget that acts as a container for mixed HTML and widgets, and includes an Ajax interface
	// description:
	//		A widget that can be used as a stand alone widget
	//		or as a base class for other widgets.
	//
	//		Handles replacement of document fragment using either external uri or javascript
	//		generated markup or DOM content, instantiating widgets within that content.
	//		Don't confuse it with an iframe, it only needs/wants document fragments.
	//		It's useful as a child of LayoutContainer, SplitContainer, or TabContainer.
	//		But note that those classes can contain any widget as a child.
	// example:
	//		Some quick samples:
	//		To change the innerHTML use .attr('content', '<b>new content</b>')
	//
	//		Or you can send it a NodeList, .attr('content', dojo.query('div [class=selected]', userSelection))
	//		please note that the nodes in NodeList will copied, not moved
	//
	//		To do a ajax update use .attr('href', url)

	// href: String
	//		The href of the content that displays now.
	//		Set this at construction if you want to load data externally when the
	//		pane is shown.  (Set preload=true to load it immediately.)
	//		Changing href after creation doesn't have any effect; use attr('href', ...);
	href: "",

/*=====
	// content: String || DomNode || NodeList || dijit._Widget
	//		The innerHTML of the ContentPane.
	//		Note that the initialization parameter / argument to attr("content", ...)
	//		can be a String, DomNode, Nodelist, or _Widget.
	content: "",
=====*/

	// extractContent: Boolean
	//		Extract visible content from inside of <body> .... </body>.
	//		I.e., strip <html> and <head> (and it's contents) from the href
	extractContent: false,

	// parseOnLoad: Boolean
	//		Parse content and create the widgets, if any.
	parseOnLoad: true,

	// preventCache: Boolean
	//		Prevent caching of data from href's by appending a timestamp to the href.
	preventCache: false,

	// preload: Boolean
	//		Force load of data on initialization even if pane is hidden.
	preload: false,

	// refreshOnShow: Boolean
	//		Refresh (re-download) content when pane goes from hidden to shown
	refreshOnShow: false,

	// loadingMessage: String
	//		Message that shows while downloading
	loadingMessage: "<span class='dijitContentPaneLoading'>${loadingState}</span>",

	// errorMessage: String
	//		Message that shows if an error occurs
	errorMessage: "<span class='dijitContentPaneError'>${errorState}</span>",

	// isLoaded: [readonly] Boolean
	//		True if the ContentPane has data in it, either specified
	//		during initialization (via href or inline content), or set
	//		via attr('content', ...) / attr('href', ...)
	//
	//		False if it doesn't have any content, or if ContentPane is
	//		still in the process of downloading href.
	isLoaded: false,

	baseClass: "dijitContentPane",

	// doLayout: Boolean
	//		- false - don't adjust size of children
	//		- true - if there is a single visible child widget, set it's size to
	//				however big the ContentPane is
	doLayout: true,

	// ioArgs: Object
	//		Parameters to pass to xhrGet() request, for example:
	// |	<div dojoType="dijit.layout.ContentPane" href="./bar" ioArgs="{timeout: 500}">
	ioArgs: {},

	// isContainer: [protected] Boolean
	//		Indicates that this widget acts as a "parent" to the descendant widgets.
	//		When the parent is started it will call startup() on the child widgets.
	//		See also `isLayoutContainer`.
	isContainer: true,

	// isLayoutContainer: [protected] Boolean
	//		Indicates that this widget will call resize() on it's child widgets
	//		when they become visible.
	isLayoutContainer: true,

	// onLoadDeferred: [readonly] dojo.Deferred
	//		This is the `dojo.Deferred` returned by attr('href', ...) and refresh().
	//		Calling onLoadDeferred.addCallback() or addErrback() registers your
	//		callback to be called only once, when the prior attr('href', ...) call or
	//		the initial href parameter to the constructor finishes loading.
	//
	//		This is different than an onLoad() handler which gets called any time any href is loaded.
	onLoadDeferred: null,

	// Override _Widget's attributeMap because we don't want the title attribute (used to specify
	// tab labels) to be copied to ContentPane.domNode... otherwise a tooltip shows up over the
	// entire pane.
	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		title: []
	}),

	postMixInProperties: function(){
		this.inherited(arguments);
		var messages = dojo.i18n.getLocalization("dijit", "loading", this.lang);
		this.loadingMessage = dojo.string.substitute(this.loadingMessage, messages);
		this.errorMessage = dojo.string.substitute(this.errorMessage, messages);

		// Detect if we were initialized with data
		if(!this.href && this.srcNodeRef && this.srcNodeRef.innerHTML){
			this.isLoaded = true;
		}
	},

	buildRendering: function(){
		// Overrides Widget.buildRendering().
		// Since we have no template we need to set this.containerNode ourselves.
		// For subclasses of ContentPane do have a template, does nothing.
		this.inherited(arguments);
		if(!this.containerNode){
			// make getDescendants() work
			this.containerNode = this.domNode;
		}
	},

	postCreate: function(){
		// remove the title attribute so it doesn't show up when hovering
		// over a node
		this.domNode.title = "";

		if(!dojo.attr(this.domNode,"role")){
			dijit.setWaiRole(this.domNode, "group");
		}

		dojo.addClass(this.domNode, this.baseClass);
	},

	startup: function(){
		// summary:
		//		See `dijit.layout._LayoutWidget.startup` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.
		if(this._started){ return; }

		var parent = dijit._Contained.prototype.getParent.call(this);
		this._childOfLayoutWidget = parent && parent.isLayoutContainer;

		// I need to call resize() on my child/children (when I become visible), unless
		// I'm the child of a layout widget in which case my parent will call resize() on me and I'll do it then.
		this._needLayout = !this._childOfLayoutWidget;

		if(this.isLoaded){
			dojo.forEach(this.getChildren(), function(child){
				child.startup();
			});
		}

		if(this._isShown() || this.preload){
			this._onShow();
		}

		this.inherited(arguments);
	},

	_checkIfSingleChild: function(){
		// summary:
		//		Test if we have exactly one visible widget as a child,
		//		and if so assume that we are a container for that widget,
		//		and should propogate startup() and resize() calls to it.
		//		Skips over things like data stores since they aren't visible.

		var childNodes = dojo.query("> *", this.containerNode).filter(function(node){
				return node.tagName !== "SCRIPT"; // or a regexp for hidden elements like script|area|map|etc..
			}),
			childWidgetNodes = childNodes.filter(function(node){
				return dojo.hasAttr(node, "dojoType") || dojo.hasAttr(node, "widgetId");
			}),
			candidateWidgets = dojo.filter(childWidgetNodes.map(dijit.byNode), function(widget){
				return widget && widget.domNode && widget.resize;
			});

		if(
			// all child nodes are widgets
			childNodes.length == childWidgetNodes.length &&

			// all but one are invisible (like dojo.data)
			candidateWidgets.length == 1
		){
			this._singleChild = candidateWidgets[0];
		}else{
			delete this._singleChild;
		}

		// So we can set overflow: hidden to avoid a safari bug w/scrollbars showing up (#9449)
		dojo.toggleClass(this.containerNode, this.baseClass + "SingleChild", !!this._singleChild);
	},

	setHref: function(/*String|Uri*/ href){
		// summary:
		//		Deprecated.   Use attr('href', ...) instead.
		dojo.deprecated("dijit.layout.ContentPane.setHref() is deprecated. Use attr('href', ...) instead.", "", "2.0");
		return this.attr("href", href);
	},
	_setHrefAttr: function(/*String|Uri*/ href){
		// summary:
		//		Hook so attr("href", ...) works.
		// description:
		//		Reset the (external defined) content of this pane and replace with new url
		//		Note: It delays the download until widget is shown if preload is false.
		//	href:
		//		url to the page you want to get, must be within the same domain as your mainpage

		// Cancel any in-flight requests (an attr('href') will cancel any in-flight attr('href', ...))
		this.cancel();

		this.onLoadDeferred = new dojo.Deferred(dojo.hitch(this, "cancel"));

		this.href = href;

		// _setHrefAttr() is called during creation and by the user, after creation.
		// only in the second case do we actually load the URL; otherwise it's done in startup()
		if(this._created && (this.preload || this._isShown())){
			this._load();
		}else{
			// Set flag to indicate that href needs to be loaded the next time the
			// ContentPane is made visible
			this._hrefChanged = true;
		}

		return this.onLoadDeferred;		// dojo.Deferred
	},

	setContent: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Deprecated.   Use attr('content', ...) instead.
		dojo.deprecated("dijit.layout.ContentPane.setContent() is deprecated.  Use attr('content', ...) instead.", "", "2.0");
		this.attr("content", data);
	},
	_setContentAttr: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Hook to make attr("content", ...) work.
		//		Replaces old content with data content, include style classes from old content
		//	data:
		//		the new Content may be String, DomNode or NodeList
		//
		//		if data is a NodeList (or an array of nodes) nodes are copied
		//		so you can import nodes from another document implicitly

		// clear href so we can't run refresh and clear content
		// refresh should only work if we downloaded the content
		this.href = "";

		// Cancel any in-flight requests (an attr('content') will cancel any in-flight attr('href', ...))
		this.cancel();

		// Even though user is just setting content directly, still need to define an onLoadDeferred
		// because the _onLoadHandler() handler is still getting called from setContent()
		this.onLoadDeferred = new dojo.Deferred(dojo.hitch(this, "cancel"));

		this._setContent(data || "");

		this._isDownloaded = false; // mark that content is from a attr('content') not an attr('href')

		return this.onLoadDeferred; 	// dojo.Deferred
	},
	_getContentAttr: function(){
		// summary:
		//		Hook to make attr("content") work
		return this.containerNode.innerHTML;
	},

	cancel: function(){
		// summary:
		//		Cancels an in-flight download of content
		if(this._xhrDfd && (this._xhrDfd.fired == -1)){
			this._xhrDfd.cancel();
		}
		delete this._xhrDfd; // garbage collect

		this.onLoadDeferred = null;
	},

	uninitialize: function(){
		if(this._beingDestroyed){
			this.cancel();
		}
		this.inherited(arguments);
	},

	destroyRecursive: function(/*Boolean*/ preserveDom){
		// summary:
		//		Destroy the ContentPane and its contents

		// if we have multiple controllers destroying us, bail after the first
		if(this._beingDestroyed){
			return;
		}
		this.inherited(arguments);
	},

	resize: function(changeSize, resultSize){
		// summary:
		//		See `dijit.layout._LayoutWidget.resize` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.

		// For the TabContainer --> BorderContainer --> ContentPane case, _onShow() is
		// never called, so resize() is our trigger to do the initial href download.
		if(!this._wasShown){
			this._onShow();
		}

		this._resizeCalled = true;

		// Set margin box size, unless it wasn't specified, in which case use current size.
		if(changeSize){
			dojo.marginBox(this.domNode, changeSize);
		}

		// Compute content box size of containerNode in case we [later] need to size our single child.
		var cn = this.containerNode;
		if(cn === this.domNode){
			// If changeSize or resultSize was passed to this method and this.containerNode ==
			// this.domNode then we can compute the content-box size without querying the node,
			// which is more reliable (similar to LayoutWidget.resize) (see for example #9449).
			var mb = resultSize || {};
			dojo.mixin(mb, changeSize || {}); // changeSize overrides resultSize
			if(!("h" in mb) || !("w" in mb)){
				mb = dojo.mixin(dojo.marginBox(cn), mb); // just use dojo.marginBox() to fill in missing values
			}
			this._contentBox = dijit.layout.marginBox2contentBox(cn, mb);
		}else{
			this._contentBox = dojo.contentBox(cn);
		}

		// Make my children layout, or size my single child widget
		this._layoutChildren();
	},

	_isShown: function(){
		// summary:
		//		Returns true if the content is currently shown.
		// description:
		//		If I am a child of a layout widget then it actually returns true if I've ever been visible,
		//		not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
		//		tree every call, and at least solves the performance problem on page load by deferring loading
		//		hidden ContentPanes until they are first shown

		if(this._childOfLayoutWidget){
			// If we are TitlePane, etc - we return that only *IF* we've been resized
			if(this._resizeCalled && "open" in this){
				return this.open;
			}
			return this._resizeCalled;
		}else if("open" in this){
			return this.open;		// for TitlePane, etc.
		}else{
			// TODO: with _childOfLayoutWidget check maybe this branch no longer necessary?
			var node = this.domNode;
			return (node.style.display != 'none') && (node.style.visibility != 'hidden') && !dojo.hasClass(node, "dijitHidden");
		}
	},

	_onShow: function(){
		// summary:
		//		Called when the ContentPane is made visible
		// description:
		//		For a plain ContentPane, this is called on initialization, from startup().
		//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
		//		called whenever the pane is made visible.
		//
		//		Does necessary processing, including href download and layout/resize of
		//		child widget(s)

		if(this.href){
			if(!this._xhrDfd && // if there's an href that isn't already being loaded
				(!this.isLoaded || this._hrefChanged || this.refreshOnShow)
			){
				this.refresh();
			}
		}else{
			// If we are the child of a layout widget then the layout widget will call resize() on
			// us, and then we will size our child/children.   Otherwise, we need to do it now.
			if(!this._childOfLayoutWidget && this._needLayout){
				// If a layout has been scheduled for when we become visible, do it now
				this._layoutChildren();
			}
		}

		this.inherited(arguments);

		// Need to keep track of whether ContentPane has been shown (which is different than
		// whether or not it's currently visible).
		this._wasShown = true;
	},

	refresh: function(){
		// summary:
		//		[Re]download contents of href and display
		// description:
		//		1. cancels any currently in-flight requests
		//		2. posts "loading..." message
		//		3. sends XHR to download new data

		// Cancel possible prior in-flight request
		this.cancel();

		this.onLoadDeferred = new dojo.Deferred(dojo.hitch(this, "cancel"));
		this._load();
		return this.onLoadDeferred;
	},

	_load: function(){
		// summary:
		//		Load/reload the href specified in this.href

		// display loading message
		this._setContent(this.onDownloadStart(), true);

		var self = this;
		var getArgs = {
			preventCache: (this.preventCache || this.refreshOnShow),
			url: this.href,
			handleAs: "text"
		};
		if(dojo.isObject(this.ioArgs)){
			dojo.mixin(getArgs, this.ioArgs);
		}

		var hand = (this._xhrDfd = (this.ioMethod || dojo.xhrGet)(getArgs));

		hand.addCallback(function(html){
			try{
				self._isDownloaded = true;
				self._setContent(html, false);
				self.onDownloadEnd();
			}catch(err){
				self._onError('Content', err); // onContentError
			}
			delete self._xhrDfd;
			return html;
		});

		hand.addErrback(function(err){
			if(!hand.canceled){
				// show error message in the pane
				self._onError('Download', err); // onDownloadError
			}
			delete self._xhrDfd;
			return err;
		});

		// Remove flag saying that a load is needed
		delete this._hrefChanged;
	},

	_onLoadHandler: function(data){
		// summary:
		//		This is called whenever new content is being loaded
		this.isLoaded = true;
		try{
			this.onLoadDeferred.callback(data);
			this.onLoad(data);
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onLoad code: ' + e.message);
		}
	},

	_onUnloadHandler: function(){
		// summary:
		//		This is called whenever the content is being unloaded
		this.isLoaded = false;
		try{
			this.onUnload();
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onUnload code: ' + e.message);
		}
	},

	destroyDescendants: function(){
		// summary:
		//		Destroy all the widgets inside the ContentPane and empty containerNode

		// Make sure we call onUnload (but only when the ContentPane has real content)
		if(this.isLoaded){
			this._onUnloadHandler();
		}

		// Even if this.isLoaded == false there might still be a "Loading..." message
		// to erase, so continue...

		// For historical reasons we need to delete all widgets under this.containerNode,
		// even ones that the user has created manually.
		var setter = this._contentSetter;
		dojo.forEach(this.getChildren(), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive();
			}
		});
		if(setter){
			// Most of the widgets in setter.parseResults have already been destroyed, but
			// things like Menu that have been moved to <body> haven't yet
			dojo.forEach(setter.parseResults, function(widget){
				if(widget.destroyRecursive && widget.domNode && widget.domNode.parentNode == dojo.body()){
					widget.destroyRecursive();
				}
			});
			delete setter.parseResults;
		}

		// And then clear away all the DOM nodes
		dojo.html._emptyNode(this.containerNode);

		// Delete any state information we have about current contents
		delete this._singleChild;
	},

	_setContent: function(cont, isFakeContent){
		// summary:
		//		Insert the content into the container node

		// first get rid of child widgets
		this.destroyDescendants();

		// dojo.html.set will take care of the rest of the details
		// we provide an override for the error handling to ensure the widget gets the errors
		// configure the setter instance with only the relevant widget instance properties
		// NOTE: unless we hook into attr, or provide property setters for each property,
		// we need to re-configure the ContentSetter with each use
		var setter = this._contentSetter;
		if(! (setter && setter instanceof dojo.html._ContentSetter)){
			setter = this._contentSetter = new dojo.html._ContentSetter({
				node: this.containerNode,
				_onError: dojo.hitch(this, this._onError),
				onContentError: dojo.hitch(this, function(e){
					// fires if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
					var errMess = this.onContentError(e);
					try{
						this.containerNode.innerHTML = errMess;
					}catch(e){
						console.error('Fatal '+this.id+' could not change content due to '+e.message, e);
					}
				})/*,
				_onError */
			});
		};

		var setterParams = dojo.mixin({
			cleanContent: this.cleanContent,
			extractContent: this.extractContent,
			parseContent: this.parseOnLoad
		}, this._contentSetterParams || {});

		dojo.mixin(setter, setterParams);

		setter.set( (dojo.isObject(cont) && cont.domNode) ? cont.domNode : cont );

		// setter params must be pulled afresh from the ContentPane each time
		delete this._contentSetterParams;

		if(!isFakeContent){
			// Startup each top level child widget (and they will start their children, recursively)
			dojo.forEach(this.getChildren(), function(child){
				// The parser has already called startup on all widgets *without* a getParent() method
				if(!this.parseOnLoad || child.getParent){
					child.startup();
				}
			}, this);

			// Call resize() on each of my child layout widgets,
			// or resize() on my single child layout widget...
			// either now (if I'm currently visible)
			// or when I become visible
			this._scheduleLayout();

			this._onLoadHandler(cont);
		}
	},

	_onError: function(type, err, consoleText){
		this.onLoadDeferred.errback(err);

		// shows user the string that is returned by on[type]Error
		// overide on[type]Error and return your own string to customize
		var errText = this['on' + type + 'Error'].call(this, err);
		if(consoleText){
			console.error(consoleText, err);
		}else if(errText){// a empty string won't change current content
			this._setContent(errText, true);
		}
	},

	_scheduleLayout: function(){
		// summary:
		//		Call resize() on each of my child layout widgets, either now
		//		(if I'm currently visible) or when I become visible
		if(this._isShown()){
			this._layoutChildren();
		}else{
			this._needLayout = true;
		}
	},

	_layoutChildren: function(){
		// summary:
		//		Since I am a Container widget, each of my children expects me to
		//		call resize() or layout() on them.
		// description:
		//		Should be called on initialization and also whenever we get new content
		//		(from an href, or from attr('content', ...))... but deferred until
		//		the ContentPane is visible

		if(this.doLayout){
			this._checkIfSingleChild();
		}

		if(this._singleChild && this._singleChild.resize){
			var cb = this._contentBox || dojo.contentBox(this.containerNode);

			// note: if widget has padding this._contentBox will have l and t set,
			// but don't pass them to resize() or it will doubly-offset the child
			this._singleChild.resize({w: cb.w, h: cb.h});
		}else{
			// All my child widgets are independently sized (rather than matching my size),
			// but I still need to call resize() on each child to make it layout.
			dojo.forEach(this.getChildren(), function(widget){
				if(widget.resize){
					widget.resize();
				}
			});
		}
		delete this._needLayout;
	},

	// EVENT's, should be overide-able
	onLoad: function(data){
		// summary:
		//		Event hook, is called after everything is loaded and widgetified
		// tags:
		//		callback
	},

	onUnload: function(){
		// summary:
		//		Event hook, is called before old content is cleared
		// tags:
		//		callback
	},

	onDownloadStart: function(){
		// summary:
		//		Called before download starts.
		// description:
		//		The string returned by this function will be the html
		//		that tells the user we are loading something.
		//		Override with your own function if you want to change text.
		// tags:
		//		extension
		return this.loadingMessage;
	},

	onContentError: function(/*Error*/ error){
		// summary:
		//		Called on DOM faults, require faults etc. in content.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		By default (if this method is not overriden), it returns
		//		nothing, so the error message is just printed to the console.
		// tags:
		//		extension
	},

	onDownloadError: function(/*Error*/ error){
		// summary:
		//		Called when download error occurs.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		Default behavior (if this method is not overriden) is to display
		//		the error message inside the pane.
		// tags:
		//		extension
		return this.errorMessage;
	},

	onDownloadEnd: function(){
		// summary:
		//		Called when download is finished.
		// tags:
		//		callback
	}
});

}

if(!dojo._hasResource["dijit.TooltipDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.TooltipDialog"] = true;
dojo.provide("dijit.TooltipDialog");






dojo.declare(
		"dijit.TooltipDialog",
		[dijit.layout.ContentPane, dijit._Templated, dijit.form._FormMixin, dijit._DialogMixin],
		{
			// summary:
			//		Pops up a dialog that appears like a Tooltip

			// title: String
			// 		Description of tooltip dialog (required for a11y)
			title: "",

			// doLayout: [protected] Boolean
			//		Don't change this parameter from the default value.
			//		This ContentPane parameter doesn't make sense for TooltipDialog, since TooltipDialog
			//		is never a child of a layout container, nor can you specify the size of
			//		TooltipDialog in order to control the size of an inner widget.
			doLayout: false,

			// autofocus: Boolean
			// 		A Toggle to modify the default focus behavior of a Dialog, which
			// 		is to focus on the first dialog element after opening the dialog.
			//		False will disable autofocusing. Default: true
			autofocus: true,

			// baseClass: [protected] String
			//		The root className to use for the various states of this widget
			baseClass: "dijitTooltipDialog",

			// _firstFocusItem: [private] [readonly] DomNode
			//		The pointer to the first focusable node in the dialog.
			//		Set by `dijit._DialogMixin._getFocusItems`.
			_firstFocusItem: null,

			// _lastFocusItem: [private] [readonly] DomNode
			//		The pointer to which node has focus prior to our dialog.
			//		Set by `dijit._DialogMixin._getFocusItems`.
			_lastFocusItem: null,

			templateString: dojo.cache("dijit", "templates/TooltipDialog.html", "<div waiRole=\"presentation\">\r\n\t<div class=\"dijitTooltipContainer\" waiRole=\"presentation\">\r\n\t\t<div class =\"dijitTooltipContents dijitTooltipFocusNode\" dojoAttachPoint=\"containerNode\" tabindex=\"-1\" waiRole=\"dialog\"></div>\r\n\t</div>\r\n\t<div class=\"dijitTooltipConnector\" waiRole=\"presentation\"></div>\r\n</div>\r\n"),

			postCreate: function(){
				this.inherited(arguments);
				this.connect(this.containerNode, "onkeypress", "_onKey");
				this.containerNode.title = this.title;
			},

			orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ corner){
				// summary:
				//		Configure widget to be displayed in given position relative to the button.
				//		This is called from the dijit.popup code, and should not be called
				//		directly.
				// tags:
				//		protected
				var c = this._currentOrientClass;
				if(c){
					dojo.removeClass(this.domNode, c);
				}
				c = "dijitTooltipAB"+(corner.charAt(1) == 'L'?"Left":"Right")+" dijitTooltip"+(corner.charAt(0) == 'T' ? "Below" : "Above");
				dojo.addClass(this.domNode, c);
				this._currentOrientClass = c;
			},

			onOpen: function(/*Object*/ pos){
				// summary:
				//		Called when dialog is displayed.
				//		This is called from the dijit.popup code, and should not be called directly.
				// tags:
				//		protected

				this.orient(this.domNode,pos.aroundCorner, pos.corner);
				this._onShow(); // lazy load trigger

				if(this.autofocus){
					this._getFocusItems(this.containerNode);
					dijit.focus(this._firstFocusItem);
				}
			},

			onClose: function(){
				// summary:
				//		Called when dialog is hidden.
				//		This is called from the dijit.popup code, and should not be called directly.
				// tags:
				//		protected
				this.onHide();
			},

			_onKey: function(/*Event*/ evt){
				// summary:
				//		Handler for keyboard events
				// description:
				//		Keep keyboard focus in dialog; close dialog on escape key
				// tags:
				//		private

				var node = evt.target;
				var dk = dojo.keys;
				if(evt.charOrCode === dk.TAB){
					this._getFocusItems(this.containerNode);
				}
				var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
				if(evt.charOrCode == dk.ESCAPE){
					// Use setTimeout to avoid crash on IE, see #10396.
					setTimeout(dojo.hitch(this, "onCancel"), 0);
					dojo.stopEvent(evt);
				}else if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === dk.TAB){
					if(!singleFocusItem){
						dijit.focus(this._lastFocusItem); // send focus to last item in dialog
					}
					dojo.stopEvent(evt);
				}else if(node == this._lastFocusItem && evt.charOrCode === dk.TAB && !evt.shiftKey){
					if(!singleFocusItem){
						dijit.focus(this._firstFocusItem); // send focus to first item in dialog
					}
					dojo.stopEvent(evt);
				}else if(evt.charOrCode === dk.TAB){
					// we want the browser's default tab handling to move focus
					// but we don't want the tab to propagate upwards
					evt.stopPropagation();
				}
			}
		}
	);

}

if(!dojo._hasResource["dijit.Dialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Dialog"] = true;
dojo.provide("dijit.Dialog");













/*=====
dijit._underlay = function(kwArgs){
	// summary:
	//		A shared instance of a `dijit.DialogUnderlay`
	//
	// description:
	//		A shared instance of a `dijit.DialogUnderlay` created and
	//		used by `dijit.Dialog`, though never created until some Dialog
	//		or subclass thereof is shown.
};
=====*/

dojo.declare(
	"dijit._DialogBase",
	[dijit._Templated, dijit.form._FormMixin, dijit._DialogMixin],
	{
		// summary:
		//		A modal dialog Widget
		//
		// description:
		//		Pops up a modal dialog window, blocking access to the screen
		//		and also graying out the screen Dialog is extended from
		//		ContentPane so it supports all the same parameters (href, etc.)
		//
		// example:
		// |	<div dojoType="dijit.Dialog" href="test.html"></div>
		//
		// example:
		// |	var foo = new dijit.Dialog({ title: "test dialog", content: "test content" };
		// |	dojo.body().appendChild(foo.domNode);
		// |	foo.startup();

		templateString: dojo.cache("dijit", "templates/Dialog.html", "<div class=\"dijitDialog\" tabindex=\"-1\" waiRole=\"dialog\" waiState=\"labelledby-${id}_title\">\r\n\t<div dojoAttachPoint=\"titleBar\" class=\"dijitDialogTitleBar\">\r\n\t<span dojoAttachPoint=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"></span>\r\n\t<span dojoAttachPoint=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" dojoAttachEvent=\"onclick: onCancel, onmouseenter: _onCloseEnter, onmouseleave: _onCloseLeave\" title=\"${buttonCancel}\">\r\n\t\t<span dojoAttachPoint=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\r\n\t</span>\r\n\t</div>\r\n\t\t<div dojoAttachPoint=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\r\n</div>\r\n"),

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			title: [
				{ node: "titleNode", type: "innerHTML" },
				{ node: "titleBar", type: "attribute" }
			],
			"aria-describedby":""
		}),

		// open: Boolean
		//		True if Dialog is currently displayed on screen.
		open: false,

		// duration: Integer
		//		The time in milliseconds it takes the dialog to fade in and out
		duration: dijit.defaultDuration,

		// refocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to re-focus the element which had focus before being opened.
		//		False will disable refocusing. Default: true
		refocus: true,

		// autofocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to focus on the first dialog element after opening the dialog.
		//		False will disable autofocusing. Default: true
		autofocus: true,

		// _firstFocusItem: [private] [readonly] DomNode
		//		The pointer to the first focusable node in the dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_firstFocusItem: null,

		// _lastFocusItem: [private] [readonly] DomNode
		//		The pointer to which node has focus prior to our dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_lastFocusItem: null,

		// doLayout: [protected] Boolean
		//		Don't change this parameter from the default value.
		//		This ContentPane parameter doesn't make sense for Dialog, since Dialog
		//		is never a child of a layout container, nor can you specify the size of
		//		Dialog in order to control the size of an inner widget.
		doLayout: false,

		// draggable: Boolean
		//		Toggles the moveable aspect of the Dialog. If true, Dialog
		//		can be dragged by it's title. If false it will remain centered
		//		in the viewport.
		draggable: true,

		//aria-describedby: String
		//		Allows the user to add an aria-describedby attribute onto the dialog.   The value should
		//		be the id of the container element of text that describes the dialog purpose (usually
		//		the first text in the dialog).
		//		<div dojoType="dijit.Dialog" aria-describedby="intro" .....>
		//			<div id="intro">Introductory text</div>
		//			<div>rest of dialog contents</div>
		//		</div>
		"aria-describedby":"",

		postMixInProperties: function(){
			var _nlsResources = dojo.i18n.getLocalization("dijit", "common");
			dojo.mixin(this, _nlsResources);
			this.inherited(arguments);
		},

		postCreate: function(){
			dojo.style(this.domNode, {
				display: "none",
				position:"absolute"
			});
			dojo.body().appendChild(this.domNode);

			this.inherited(arguments);

			this.connect(this, "onExecute", "hide");
			this.connect(this, "onCancel", "hide");
			this._modalconnects = [];
		},

		onLoad: function(){
			// summary:
			//		Called when data has been loaded from an href.
			//		Unlike most other callbacks, this function can be connected to (via `dojo.connect`)
			//		but should *not* be overriden.
			// tags:
			//		callback

			// when href is specified we need to reposition the dialog after the data is loaded
			this._position();
			this.inherited(arguments);
		},

		_endDrag: function(e){
			// summary:
			//		Called after dragging the Dialog. Saves the position of the dialog in the viewport.
			// tags:
			//		private
			if(e && e.node && e.node === this.domNode){
				this._relativePosition = dojo.position(e.node);
			}
		},

		_setup: function(){
			// summary:
			//		Stuff we need to do before showing the Dialog for the first
			//		time (but we defer it until right beforehand, for
			//		performance reasons).
			// tags:
			//		private

			var node = this.domNode;

			if(this.titleBar && this.draggable){
				this._moveable = (dojo.isIE == 6) ?
					new dojo.dnd.TimedMoveable(node, { handle: this.titleBar }) :	// prevent overload, see #5285
					new dojo.dnd.Moveable(node, { handle: this.titleBar, timeout: 0 });
				dojo.subscribe("/dnd/move/stop",this,"_endDrag");
			}else{
				dojo.addClass(node,"dijitDialogFixed");
			}

			this.underlayAttrs = {
				dialogId: this.id,
				"class": dojo.map(this["class"].split(/\s/), function(s){ return s+"_underlay"; }).join(" ")
			};

			this._fadeIn = dojo.fadeIn({
				node: node,
				duration: this.duration,
				beforeBegin: dojo.hitch(this, function(){
					var underlay = dijit._underlay;
					if(!underlay){
						underlay = dijit._underlay = new dijit.DialogUnderlay(this.underlayAttrs);
					}else{
						underlay.attr(this.underlayAttrs);
					}

					var zIndex = 948 + dijit._dialogStack.length*2;
					dojo.style(dijit._underlay.domNode, 'zIndex', zIndex);
					dojo.style(this.domNode, 'zIndex', zIndex + 1);
					underlay.show();
				}),
				onEnd: dojo.hitch(this, function(){
					if(this.autofocus){
						// find focusable Items each time dialog is shown since if dialog contains a widget the
						// first focusable items can change
						this._getFocusItems(this.domNode);
						dijit.focus(this._firstFocusItem);
					}
				})
			 });

			this._fadeOut = dojo.fadeOut({
				node: node,
				duration: this.duration,
				onEnd: dojo.hitch(this, function(){
					node.style.display = "none";

					// Restore the previous dialog in the stack, or if this is the only dialog
					// then restore to original page
					var ds = dijit._dialogStack;
					if(ds.length == 0){
						dijit._underlay.hide();
					}else{
						dojo.style(dijit._underlay.domNode, 'zIndex', 948 + ds.length*2);
						dijit._underlay.attr(ds[ds.length-1].underlayAttrs);
					}

					// Restore focus to wherever it was before this dialog was displayed
					if(this.refocus){
						var focus = this._savedFocus;

						// If we are returning control to a previous dialog but for some reason
						// that dialog didn't have a focused field, set focus to first focusable item.
						// This situation could happen if two dialogs appeared at nearly the same time,
						// since a dialog doesn't set it's focus until the fade-in is finished.
						if(ds.length > 0){
							var pd = ds[ds.length-1];
							if(!dojo.isDescendant(focus.node, pd.domNode)){
								pd._getFocusItems(pd.domNode);
								focus = pd._firstFocusItem;
							}
						}

						dijit.focus(focus);
					}
				})
			 });
		},

		uninitialize: function(){
			var wasPlaying = false;
			if(this._fadeIn && this._fadeIn.status() == "playing"){
				wasPlaying = true;
				this._fadeIn.stop();
			}
			if(this._fadeOut && this._fadeOut.status() == "playing"){
				wasPlaying = true;
				this._fadeOut.stop();
			}
			
			// Hide the underlay, unless the underlay widget has already been destroyed
			// because we are being called during page unload (when all widgets are destroyed)
			if((this.open || wasPlaying) && !dijit._underlay._destroyed){
				dijit._underlay.hide();
			}
			if(this._moveable){
				this._moveable.destroy();
			}
			this.inherited(arguments);
		},

		_size: function(){
			// summary:
			// 		If necessary, shrink dialog contents so dialog fits in viewport
			// tags:
			//		private

			this._checkIfSingleChild();

			// If we resized the dialog contents earlier, reset them back to original size, so
			// that if the user later increases the viewport size, the dialog can display w/out a scrollbar.
			// Need to do this before the dojo.marginBox(this.domNode) call below.
			if(this._singleChild){
				if(this._singleChildOriginalStyle){
					this._singleChild.domNode.style.cssText = this._singleChildOriginalStyle;
				}
				delete this._singleChildOriginalStyle;
			}else{
				dojo.style(this.containerNode, {
					width:"auto",
					height:"auto"
				});
			}

			var mb = dojo.marginBox(this.domNode);
			var viewport = dijit.getViewport();
			if(mb.w >= viewport.w || mb.h >= viewport.h){
				// Reduce size of dialog contents so that dialog fits in viewport

				var w = Math.min(mb.w, Math.floor(viewport.w * 0.75)),
					h = Math.min(mb.h, Math.floor(viewport.h * 0.75));

				if(this._singleChild && this._singleChild.resize){
					this._singleChildOriginalStyle = this._singleChild.domNode.style.cssText;
					this._singleChild.resize({w: w, h: h});
				}else{
					dojo.style(this.containerNode, {
						width: w + "px",
						height: h + "px",
						overflow: "auto",
						position: "relative"	// workaround IE bug moving scrollbar or dragging dialog
					});
				}
			}else{
				if(this._singleChild && this._singleChild.resize){
					this._singleChild.resize();
				}
			}
		},

		_position: function(){
			// summary:
			//		Position modal dialog in the viewport. If no relative offset
			//		in the viewport has been determined (by dragging, for instance),
			//		center the node. Otherwise, use the Dialog's stored relative offset,
			//		and position the node to top: left: values based on the viewport.
			// tags:
			//		private
			if(!dojo.hasClass(dojo.body(),"dojoMove")){
				var node = this.domNode,
					viewport = dijit.getViewport(),
					p = this._relativePosition,
					bb = p ? null : dojo._getBorderBox(node),
					l = Math.floor(viewport.l + (p ? p.x : (viewport.w - bb.w) / 2)),
					t = Math.floor(viewport.t + (p ? p.y : (viewport.h - bb.h) / 2))
				;
				dojo.style(node,{
					left: l + "px",
					top: t + "px"
				});
			}
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles the keyboard events for accessibility reasons
			// tags:
			//		private

			var ds = dijit._dialogStack;
			if(ds[ds.length-1] != this){
				// console.debug(this.id + ': skipping because', this, 'is not the active dialog');
				return;
			}

			if(evt.charOrCode){
				var dk = dojo.keys;
				var node = evt.target;
				if(evt.charOrCode === dk.TAB){
					this._getFocusItems(this.domNode);
				}
				var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
				// see if we are shift-tabbing from first focusable item on dialog
				if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === dk.TAB){
					if(!singleFocusItem){
						dijit.focus(this._lastFocusItem); // send focus to last item in dialog
					}
					dojo.stopEvent(evt);
				}else if(node == this._lastFocusItem && evt.charOrCode === dk.TAB && !evt.shiftKey){
					if(!singleFocusItem){
						dijit.focus(this._firstFocusItem); // send focus to first item in dialog
					}
					dojo.stopEvent(evt);
				}else{
					// see if the key is for the dialog
					while(node){
						if(node == this.domNode || dojo.hasClass(node, "dijitPopup")){
							if(evt.charOrCode == dk.ESCAPE){
								this.onCancel();
							}else{
								return; // just let it go
							}
						}
						node = node.parentNode;
					}
					// this key is for the disabled document window
					if(evt.charOrCode !== dk.TAB){ // allow tabbing into the dialog for a11y
						dojo.stopEvent(evt);
					// opera won't tab to a div
					}else if(!dojo.isOpera){
						try{
							this._firstFocusItem.focus();
						}catch(e){ /*squelch*/ }
					}
				}
			}
		},

		show: function(){
			// summary:
			//		Display the dialog
			if(this.open){ return; }

			// first time we show the dialog, there's some initialization stuff to do
			if(!this._alreadyInitialized){
				this._setup();
				this._alreadyInitialized=true;
			}

			if(this._fadeOut.status() == "playing"){
				this._fadeOut.stop();
			}

			this._modalconnects.push(dojo.connect(window, "onscroll", this, "layout"));
			this._modalconnects.push(dojo.connect(window, "onresize", this, function(){
				// IE gives spurious resize events and can actually get stuck
				// in an infinite loop if we don't ignore them
				var viewport = dijit.getViewport();
				if(!this._oldViewport ||
						viewport.h != this._oldViewport.h ||
						viewport.w != this._oldViewport.w){
					this.layout();
					this._oldViewport = viewport;
				}
			}));
			this._modalconnects.push(dojo.connect(dojo.doc.documentElement, "onkeypress", this, "_onKey"));

			dojo.style(this.domNode, {
				opacity:0,
				display:""
			});

			this.open = true;
			this._onShow(); // lazy load trigger

			this._size();
			this._position();
			dijit._dialogStack.push(this);
			this._fadeIn.play();

			this._savedFocus = dijit.getFocus(this);
		},

		hide: function(){
			// summary:
			//		Hide the dialog

			// if we haven't been initialized yet then we aren't showing and we can just return
			// or if we aren't the active dialog, don't allow us to close yet
			var ds = dijit._dialogStack;
			if(!this._alreadyInitialized || this != ds[ds.length-1]){
				return;
			}

			if(this._fadeIn.status() == "playing"){
				this._fadeIn.stop();
			}

			// throw away current active dialog from stack -- making the previous dialog or the node on the original page active
			ds.pop();

			this._fadeOut.play();

			if(this._scrollConnected){
				this._scrollConnected = false;
			}
			dojo.forEach(this._modalconnects, dojo.disconnect);
			this._modalconnects = [];

			if(this._relativePosition){
				delete this._relativePosition;
			}
			this.open = false;

			this.onHide();
		},

		layout: function(){
			// summary:
			//		Position the Dialog and the underlay
			// tags:
			//		private
			if(this.domNode.style.display != "none"){
				if(dijit._underlay){	// avoid race condition during show()
					dijit._underlay.layout();
				}
				this._position();
			}
		},

		destroy: function(){
			dojo.forEach(this._modalconnects, dojo.disconnect);
			if(this.refocus && this.open){
				setTimeout(dojo.hitch(dijit,"focus",this._savedFocus), 25);
			}
			this.inherited(arguments);
		},

		_onCloseEnter: function(){
			// summary:
			//		Called when user hovers over close icon
			// tags:
			//		private
			dojo.addClass(this.closeButtonNode, "dijitDialogCloseIcon-hover");
		},

		_onCloseLeave: function(){
			// summary:
			//		Called when user stops hovering over close icon
			// tags:
			//		private
			dojo.removeClass(this.closeButtonNode, "dijitDialogCloseIcon-hover");
		}
	}
);

dojo.declare(
	"dijit.Dialog",
	[dijit.layout.ContentPane, dijit._DialogBase],
	{}
);

// Stack of currenctly displayed dialogs, layered on top of each other
dijit._dialogStack = [];

// For back-compat.  TODO: remove in 2.0


}

if(!dojo._hasResource["dijit._TimePicker"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._TimePicker"] = true;
dojo.provide("dijit._TimePicker");




/*=====
dojo.declare(
	"dijit._TimePicker.__Constraints",
	dojo.date.locale.__FormatOptions,
	{
		// clickableIncrement: String
		//		See `dijit._TimePicker.clickableIncrement`
		clickableIncrement: "T00:15:00",

		// visibleIncrement: String
		//		See `dijit._TimePicker.visibleIncrement`
		visibleIncrement: "T01:00:00",

		// visibleRange: String
		//		See `dijit._TimePicker.visibleRange`
		visibleRange: "T05:00:00"
	}
);
=====*/

dojo.declare("dijit._TimePicker",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		A graphical time picker.
		//		This widget is used internally by other widgets and is not available
		//		as a standalone widget due to lack of accessibility support.

		templateString: dojo.cache("dijit", "templates/TimePicker.html", "<div id=\"widget_${id}\" class=\"dijitMenu ${baseClass}\"\r\n    ><div dojoAttachPoint=\"upArrow\" class=\"dijitButtonNode dijitUpArrowButton\" dojoAttachEvent=\"onmouseenter:_buttonMouse,onmouseleave:_buttonMouse\"\r\n\t\t><div class=\"dijitReset dijitInline dijitArrowButtonInner\" wairole=\"presentation\" role=\"presentation\">&nbsp;</div\r\n\t\t><div class=\"dijitArrowButtonChar\">&#9650;</div></div\r\n    ><div dojoAttachPoint=\"timeMenu,focusNode\" dojoAttachEvent=\"onclick:_onOptionSelected,onmouseover,onmouseout\"></div\r\n    ><div dojoAttachPoint=\"downArrow\" class=\"dijitButtonNode dijitDownArrowButton\" dojoAttachEvent=\"onmouseenter:_buttonMouse,onmouseleave:_buttonMouse\"\r\n\t\t><div class=\"dijitReset dijitInline dijitArrowButtonInner\" wairole=\"presentation\" role=\"presentation\">&nbsp;</div\r\n\t\t><div class=\"dijitArrowButtonChar\">&#9660;</div></div\r\n></div>\r\n"),

		// baseClass: [protected] String
		//		The root className to use for the various states of this widget
		baseClass: "dijitTimePicker",

		// clickableIncrement: String
		//		ISO-8601 string representing the amount by which
		//		every clickable element in the time picker increases.
		//		Set in local time, without a time zone.
		//		Example: `T00:15:00` creates 15 minute increments
		//		Must divide dijit._TimePicker.visibleIncrement evenly
		clickableIncrement: "T00:15:00",

		// visibleIncrement: String
		//		ISO-8601 string representing the amount by which
		//		every element with a visible time in the time picker increases.
		//		Set in local time, without a time zone.
		//		Example: `T01:00:00` creates text in every 1 hour increment
		visibleIncrement: "T01:00:00",

		// visibleRange: String
		//		ISO-8601 string representing the range of this TimePicker.
		//		The TimePicker will only display times in this range.
		//		Example: `T05:00:00` displays 5 hours of options
		visibleRange: "T05:00:00",

		// value: String
		//		Date to display.
		//		Defaults to current time and date.
		//		Can be a Date object or an ISO-8601 string.
		//		If you specify the GMT time zone (`-01:00`),
		//		the time will be converted to the local time in the local time zone.
		//		Otherwise, the time is considered to be in the local time zone.
		//		If you specify the date and isDate is true, the date is used.
		//		Example: if your local time zone is `GMT -05:00`,
		//		`T10:00:00` becomes `T10:00:00-05:00` (considered to be local time),
		//		`T10:00:00-01:00` becomes `T06:00:00-05:00` (4 hour difference),
		//		`T10:00:00Z` becomes `T05:00:00-05:00` (5 hour difference between Zulu and local time)
		//		`yyyy-mm-ddThh:mm:ss` is the format to set the date and time
		//		Example: `2007-06-01T09:00:00`
		value: new Date(),

		_visibleIncrement:2,
		_clickableIncrement:1,
		_totalIncrements:10,

		// constraints: dijit._TimePicker.__Constraints
		//		Specifies valid range of times (start time, end time)
		constraints:{},

/*=====
		serialize: function(val, options){
			// summary:
			//		User overridable function used to convert the attr('value') result to a String
			// val: Date
			//		The current value
			// options: Object?
			// tags:
			//		protected
		},
=====*/
		serialize: dojo.date.stamp.toISOString,

		// _filterString: string
		//		The string to filter by
		_filterString: "",

		setValue: function(/*Date*/ value){
			// summary:
			//		Deprecated.  Used attr('value') instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit._TimePicker:setValue() is deprecated.  Use attr('value') instead.", "", "2.0");
			this.attr('value', value);
		},
		_setValueAttr: function(/*Date*/ date){
			// summary:
			//		Hook so attr('value', ...) works.
			// description:
			//		Set the value of the TimePicker.
			//		Redraws the TimePicker around the new date.
			// tags:
			//		protected
			this.value = date;
			this._showText();
		},

		onOpen: function(best){
			// summary:
			//		This is called by the popup manager when a TimeTextBox is displayed on the screen
			// best:
			//		Whether it is being displayed above or below the `dijit.form.TimeTextBox`
			// tags:
			//		protected
			if(this._beenOpened && this.domNode.parentNode){
				// We've been opened before - so set our filter to to the
				// currently-displayed value (or empty string if it's already
				// valid)
				var p = dijit.byId(this.domNode.parentNode.dijitPopupParent);
				if(p){
					var val = p.attr('displayedValue');
					if(val && !p.parse(val, p.constraints)){
						this._filterString = val;
					}else{
						this._filterString = "";
					}
					this._showText();
				}
			}
			this._beenOpened = true;
		},

		isDisabledDate: function(/*Date*/ dateObject, /*String?*/ locale){
			// summary:
			//		May be overridden to disable certain dates in the TimePicker e.g. `isDisabledDate=dojo.date.locale.isWeekend`
			// type:
			//		extension
			return false; // Boolean
		},

		_getFilteredNodes: function(/*number*/ start, /*number*/ maxNum, /*Boolean*/ before){
			// summary:
			//		Returns an array of nodes with the filter applied.  At most maxNum nodes
			//		will be returned - but fewer may be returned as well.  If the
			//		before parameter is set to true, then it will return the elements
			//		before the given index
			// tags:
			//		private
			var nodes = [], n, i = start, max = this._maxIncrement + Math.abs(i),
				chk = before?-1:1, dec = before?1:0, inc = before?0:1;
			do{
				i = i - dec;
				n = this._createOption(i);
				if(n){nodes.push(n);}
				i = i + inc;
			}while(nodes.length < maxNum && (i*chk) < max);
			if(before){ nodes.reverse(); }
			return nodes;
		},

		_showText: function(){
			// summary:
			//		Displays the relevant choices in the drop down list
			// tags:
			//		private
			this.timeMenu.innerHTML = "";
			var fromIso = dojo.date.stamp.fromISOString;
			this._clickableIncrementDate=fromIso(this.clickableIncrement);
			this._visibleIncrementDate=fromIso(this.visibleIncrement);
			this._visibleRangeDate=fromIso(this.visibleRange);
			// get the value of the increments and the range in seconds (since 00:00:00) to find out how many divs to create
			var sinceMidnight = function(/*Date*/ date){
				return date.getHours() * 60 * 60 + date.getMinutes() * 60 + date.getSeconds();
			};

			var clickableIncrementSeconds = sinceMidnight(this._clickableIncrementDate);
			var visibleIncrementSeconds = sinceMidnight(this._visibleIncrementDate);
			var visibleRangeSeconds = sinceMidnight(this._visibleRangeDate);

			// round reference date to previous visible increment
			var time = this.value.getTime();
			this._refDate = new Date(time - time % (visibleIncrementSeconds*1000));
			this._refDate.setFullYear(1970,0,1); // match parse defaults

			// assume clickable increment is the smallest unit
			this._clickableIncrement = 1;
			// divide the visible range by the clickable increment to get the number of divs to create
			// example: 10:00:00/00:15:00 -> display 40 divs
			this._totalIncrements = visibleRangeSeconds / clickableIncrementSeconds;
			// divide the visible increments by the clickable increments to get how often to display the time inline
			// example: 01:00:00/00:15:00 -> display the time every 4 divs
			this._visibleIncrement = visibleIncrementSeconds / clickableIncrementSeconds;
			// divide the number of seconds in a day by the clickable increment in seconds to get the
			// absolute max number of increments.
			this._maxIncrement = (60 * 60 * 24) / clickableIncrementSeconds;

			// find the nodes we should display based on our filter
			var before = this._getFilteredNodes(0, this._totalIncrements >> 1, true);
			var after = this._getFilteredNodes(0, this._totalIncrements >> 1, false);
			if(before.length < this._totalIncrements >> 1){
				before = before.slice(before.length / 2);
				after = after.slice(0, after.length / 2);
			}
			dojo.forEach(before.concat(after), function(n){this.timeMenu.appendChild(n);}, this);

			// TODO:
			// I commented this out because it
			// causes problems for a TimeTextBox in a Dialog, or as the editor of an InlineEditBox,
			// because the timeMenu node isn't visible yet. -- Bill (Bug #????)
			// dijit.focus(this.timeMenu);
		},

		postCreate: function(){
			// instantiate constraints
			if(this.constraints === dijit._TimePicker.prototype.constraints){
				this.constraints={};
			}

			// brings in visibleRange, increments, etc.
			dojo.mixin(this, this.constraints);

			// dojo.date.locale needs the lang in the constraints as locale
			if(!this.constraints.locale){
				this.constraints.locale=this.lang;
			}

			// assign typematic mouse listeners to the arrow buttons
			this.connect(this.timeMenu, dojo.isIE ? "onmousewheel" : 'DOMMouseScroll', "_mouseWheeled");
			var _this = this;
			var typematic = function(){
				_this._connects.push(
					dijit.typematic.addMouseListener.apply(null, arguments)
				);
			};
			typematic(this.upArrow,this,this._onArrowUp, 1.0, 50);
			typematic(this.downArrow,this,this._onArrowDown, 1.0, 50);

			// Connect some callback functions to the hover event of the arrows
			var triggerFx = function(cb){
				return function(cnt){
					// don't run on the first firing
					if(cnt > 0){cb.call(this, arguments);}
				};
			};
			var hoverFx = function(node, cb){
				return function(e){
					dojo.stopEvent(e);
					dijit.typematic.trigger(e, this, node, triggerFx(cb), node, 1.0, 50);
				};
			};
			this.connect(this.upArrow, "onmouseover", hoverFx(this.upArrow, this._onArrowUp));
			this.connect(this.downArrow, "onmouseover", hoverFx(this.downArrow, this._onArrowDown));

			this.inherited(arguments);
		},

		_buttonMouse: function(/*Event*/ e){
			// summary:
			//		Handler for mouse button presses
			// tags:
			//		private
			dojo.toggleClass(e.currentTarget, "dijitButtonNodeHover", e.type == "mouseover");
		},

		_createOption: function(/*Number*/ index){
			// summary:
			//		Creates a clickable time option
			// tags:
			//		private
			var date = new Date(this._refDate);
			var incrementDate = this._clickableIncrementDate;
			date.setHours(date.getHours() + incrementDate.getHours() * index,
				date.getMinutes() + incrementDate.getMinutes() * index,
				date.getSeconds() + incrementDate.getSeconds() * index);
			if(this.constraints.selector == "time"){
				date.setFullYear(1970,0,1); // make sure each time is for the same date
			}
			var dateString = dojo.date.locale.format(date, this.constraints);
			if(this._filterString && dateString.toLowerCase().indexOf(this._filterString) !== 0){
				// Doesn't match the filter - return null
				return null;
			}

			var div = dojo.create("div", {"class": this.baseClass+"Item"});
			div.date = date;
			div.index = index;
			dojo.create('div',{
				"class": this.baseClass + "ItemInner",
				innerHTML: dateString
			}, div);

			if(index%this._visibleIncrement<1 && index%this._visibleIncrement>-1){
				dojo.addClass(div, this.baseClass+"Marker");
			}else if(!(index%this._clickableIncrement)){
				dojo.addClass(div, this.baseClass+"Tick");
			}

			if(this.isDisabledDate(date)){
				// set disabled
				dojo.addClass(div, this.baseClass+"ItemDisabled");
			}
			if(!dojo.date.compare(this.value, date, this.constraints.selector)){
				div.selected = true;
				dojo.addClass(div, this.baseClass+"ItemSelected");
				if(dojo.hasClass(div, this.baseClass+"Marker")){
					dojo.addClass(div, this.baseClass+"MarkerSelected");
				}else{
					dojo.addClass(div, this.baseClass+"TickSelected");
				}
			}
			return div;
		},

		_onOptionSelected: function(/*Object*/ tgt){
			// summary:
			//		Called when user clicks an option in the drop down list
			// tags:
			//		private
			var tdate = tgt.target.date || tgt.target.parentNode.date;
			if(!tdate || this.isDisabledDate(tdate)){ return; }
			this._highlighted_option = null;
			this.attr('value', tdate);
			this.onValueSelected(tdate);
		},

		onValueSelected: function(/*Date*/ time){
			// summary:
			//		Notification that a time was selected.  It may be the same as the previous value.
			// description:
			//      Used by `dijit.form._DateTimeTextBox` (and thus `dijit.form.TimeTextBox`)
			//      to get notification when the user has clicked a time.
			// tags:
			//      protected
		},


		_highlightOption: function(/*node*/ node, /*Boolean*/ highlight){
			// summary:
			//		Turns on/off hover effect on a node based on mouse out/over event
			// tags:
			//		private
			if(!node){return;}
			if(highlight){
				if(this._highlighted_option){
					this._highlightOption(this._highlighted_option, false);
				}
				this._highlighted_option = node;
			}else if(this._highlighted_option !== node){
				return;
			}else{
				this._highlighted_option = null;
			}
			dojo.toggleClass(node, this.baseClass+"ItemHover", highlight);
			if(dojo.hasClass(node, this.baseClass+"Marker")){
				dojo.toggleClass(node, this.baseClass+"MarkerHover", highlight);
			}else{
				dojo.toggleClass(node, this.baseClass+"TickHover", highlight);
			}
		},

		onmouseover: function(/*Event*/ e){
			// summary:
			//		Handler for onmouseover event
			// tags:
			//		private
			this._keyboardSelected = null;
			var tgr = (e.target.parentNode === this.timeMenu) ? e.target : e.target.parentNode;
			// if we aren't targeting an item, then we return
			if(!dojo.hasClass(tgr, this.baseClass+"Item")){return;}
			this._highlightOption(tgr, true);
		},

		onmouseout: function(/*Event*/ e){
			// summary:
			//		Handler for onmouseout event
			// tags:
			//		private
			this._keyboardSelected = null;
			var tgr = (e.target.parentNode === this.timeMenu) ? e.target : e.target.parentNode;
			this._highlightOption(tgr, false);
		},

		_mouseWheeled: function(/*Event*/ e){
			// summary:
			//		Handle the mouse wheel events
			// tags:
			//		private
			this._keyboardSelected = null;
			dojo.stopEvent(e);
			// we're not _measuring_ the scroll amount, just direction
			var scrollAmount = (dojo.isIE ? e.wheelDelta : -e.detail);
			this[(scrollAmount>0 ? "_onArrowUp" : "_onArrowDown")](); // yes, we're making a new dom node every time you mousewheel, or click
		},

		_onArrowUp: function(count){
			// summary:
			//		Handler for up arrow key.
			// description:
			//		Removes the bottom time and add one to the top
			// tags:
			//		private
			if(typeof count == "number" && count == -1){ return; } // typematic end
			if(!this.timeMenu.childNodes.length){ return; }
			var index = this.timeMenu.childNodes[0].index;
			var divs = this._getFilteredNodes(index, 1, true);
			if(divs.length){
				this.timeMenu.removeChild(this.timeMenu.childNodes[this.timeMenu.childNodes.length - 1]);
				this.timeMenu.insertBefore(divs[0], this.timeMenu.childNodes[0]);
			}
		},

		_onArrowDown: function(count){
			// summary:
			//		Handler for up arrow key.
			// description:
			//		Remove the top time and add one to the bottom
			// tags:
			//		private
			if(typeof count == "number" && count == -1){ return; } // typematic end
			if(!this.timeMenu.childNodes.length){ return; }
			var index = this.timeMenu.childNodes[this.timeMenu.childNodes.length - 1].index + 1;
			var divs = this._getFilteredNodes(index, 1, false);
			if(divs.length){
				this.timeMenu.removeChild(this.timeMenu.childNodes[0]);
				this.timeMenu.appendChild(divs[0]);
			}
		},

		handleKey: function(/*Event*/ e){
			// summary:
			//		Called from `dijit.form._DateTimeTextBox` to pass a keypress event
			//		from the `dijit.form.TimeTextBox` to be handled in this widget
			// tags:
			//		protected
			var dk = dojo.keys;
			if(e.keyChar || e.charOrCode === dk.BACKSPACE || e.charOrCode == dk.DELETE){
				// Set a timeout to kick off our filter
				setTimeout(dojo.hitch(this, function(){
					this._filterString = e.target.value.toLowerCase();
					this._showText();
				}),1);
			}else if(e.charOrCode == dk.DOWN_ARROW || e.charOrCode == dk.UP_ARROW){
				dojo.stopEvent(e);
				// Figure out which option to highlight now and then highlight it
				if(this._highlighted_option && !this._highlighted_option.parentNode){
					this._highlighted_option = null;
				}
				var timeMenu = this.timeMenu,
					tgt = this._highlighted_option || dojo.query("." + this.baseClass + "ItemSelected", timeMenu)[0];
				if(!tgt){
					tgt = timeMenu.childNodes[0];
				}else if(timeMenu.childNodes.length){
					if(e.charOrCode == dk.DOWN_ARROW && !tgt.nextSibling){
						this._onArrowDown();
					}else if(e.charOrCode == dk.UP_ARROW && !tgt.previousSibling){
						this._onArrowUp();
					}
					if(e.charOrCode == dk.DOWN_ARROW){
						tgt = tgt.nextSibling;
					}else{
						tgt = tgt.previousSibling;
					}
				}
				this._highlightOption(tgt, true);
				this._keyboardSelected = tgt;
			}else if(this._highlighted_option && (e.charOrCode == dk.ENTER || e.charOrCode === dk.TAB)){
				// Accept the currently-highlighted option as the value
				if(!this._keyboardSelected && e.charOrCode === dk.TAB){ return; } // mouse hover followed by TAB is NO selection
				if(e.charOrCode == dk.ENTER){dojo.stopEvent(e);}
				this._onOptionSelected({target: this._highlighted_option});
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.form.TimeTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.TimeTextBox"] = true;
dojo.provide("dijit.form.TimeTextBox");




/*=====
dojo.declare(
	"dijit.form.TimeTextBox.__Constraints",
	[dijit.form._DateTimeTextBox.__Constraints, dijit._TimePicker.__Constraints]
);
=====*/

dojo.declare(
	"dijit.form.TimeTextBox",
	dijit.form._DateTimeTextBox,
	{
		// summary:
		//		A validating, serializable, range-bound time text box with a drop down time picker

		baseClass: "dijitTextBox dijitTimeTextBox",
		popupClass: "dijit._TimePicker",
		_selector: "time",

/*=====
		// constraints: dijit.form.TimeTextBox.__Constraints
		constraints:{},
=====*/

		// value: Date
		//		The value of this widget as a JavaScript Date object, with only hours/minutes/seconds specified.
		//
		//		Example:
		// |	new dijit.form.TimeTextBox({value: dojo.date.local.fromISOString("T:12:59:59")})
		//
		//		When passed to the parser in markup, must be specified according to locale-independent
		//		`dojo.date.stamp.fromISOString` format.
		//
		//		Example:
		// |	<input dojotype='dijit.form.TimeTextBox' value='T12:34:00'>
		value: new Date("")		// value.toString()="NaN"
	}
);

}

if(!dojo._hasResource["dojo.data.util.sorter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.sorter"] = true;
dojo.provide("dojo.data.util.sorter");

dojo.data.util.sorter.basicComparator = function(	/*anything*/ a, 
													/*anything*/ b){
	//	summary:  
	//		Basic comparision function that compares if an item is greater or less than another item
	//	description:  
	//		returns 1 if a > b, -1 if a < b, 0 if equal.
	//		'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	//		And compared to each other, null is equivalent to undefined.
	
	//null is a problematic compare, so if null, we set to undefined.
	//Makes the check logic simple, compact, and consistent
	//And (null == undefined) === true, so the check later against null
	//works for undefined and is less bytes.
	var r = -1;
	if(a === null){
		a = undefined;
	}
	if(b === null){
		b = undefined;
	}
	if(a == b){
		r = 0; 
	}else if(a > b || a == null){
		r = 1; 
	}
	return r; //int {-1,0,1}
};

dojo.data.util.sorter.createSortFunction = function(	/* attributes array */sortSpec,
														/*dojo.data.core.Read*/ store){
	//	summary:  
	//		Helper function to generate the sorting function based off the list of sort attributes.
	//	description:  
	//		The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	//		it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	//		use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	//		Returns the sorting function for this particular list of attributes and sorting directions.
	//
	//	sortSpec: array
	//		A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	//		The objects should be formatted as follows:
	//		{
	//			attribute: "attributeName-string" || attribute,
	//			descending: true|false;   // Default is false.
	//		}
	//	store: object
	//		The datastore object to look up item values from.
	//
	var sortFunctions=[];

	function createSortFunction(attr, dir, comp, s){
		//Passing in comp and s (comparator and store), makes this
		//function much faster.
		return function(itemA, itemB){
			var a = s.getValue(itemA, attr);
			var b = s.getValue(itemB, attr);
			return dir * comp(a,b); //int
		};
	}
	var sortAttribute;
	var map = store.comparatorMap;
	var bc = dojo.data.util.sorter.basicComparator;
	for(var i = 0; i < sortSpec.length; i++){
		sortAttribute = sortSpec[i];
		var attr = sortAttribute.attribute;
		if(attr){
			var dir = (sortAttribute.descending) ? -1 : 1;
			var comp = bc;
			if(map){
				if(typeof attr !== "string" && ("toString" in attr)){
					 attr = attr.toString();
				}
				comp = map[attr] || bc;
			}
			sortFunctions.push(createSortFunction(attr, 
				dir, comp, store));
		}
	}
	return function(rowA, rowB){
		var i=0;
		while(i < sortFunctions.length){
			var ret = sortFunctions[i++](rowA, rowB);
			if(ret !== 0){
				return ret;//int
			}
		}
		return 0; //int  
	}; // Function
};

}

if(!dojo._hasResource["dojo.data.util.simpleFetch"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.simpleFetch"] = true;
dojo.provide("dojo.data.util.simpleFetch");


dojo.data.util.simpleFetch.fetch = function(/* Object? */ request){
	//	summary:
	//		The simpleFetch mixin is designed to serve as a set of function(s) that can
	//		be mixed into other datastore implementations to accelerate their development.  
	//		The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems() 
	//		call by returning an array of all the found items that matched the query.  The simpleFetch mixin
	//		is not designed to work for datastores that respond to a fetch() call by incrementally
	//		loading items, or sequentially loading partial batches of the result
	//		set.  For datastores that mixin simpleFetch, simpleFetch 
	//		implements a fetch method that automatically handles eight of the fetch()
	//		arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
	//		The class mixing in simpleFetch should not implement fetch(),
	//		but should instead implement a _fetchItems() method.  The _fetchItems() 
	//		method takes three arguments, the keywordArgs object that was passed 
	//		to fetch(), a callback function to be called when the result array is
	//		available, and an error callback to be called if something goes wrong.
	//		The _fetchItems() method should ignore any keywordArgs parameters for
	//		start, count, onBegin, onItem, onComplete, onError, sort, and scope.  
	//		The _fetchItems() method needs to correctly handle any other keywordArgs
	//		parameters, including the query parameter and any optional parameters 
	//		(such as includeChildren).  The _fetchItems() method should create an array of 
	//		result items and pass it to the fetchHandler along with the original request object 
	//		-- or, the _fetchItems() method may, if it wants to, create an new request object 
	//		with other specifics about the request that are specific to the datastore and pass 
	//		that as the request object to the handler.
	//
	//		For more information on this specific function, see dojo.data.api.Read.fetch()
	request = request || {};
	if(!request.store){
		request.store = this;
	}
	var self = this;

	var _errorHandler = function(errorData, requestObject){
		if(requestObject.onError){
			var scope = requestObject.scope || dojo.global;
			requestObject.onError.call(scope, errorData, requestObject);
		}
	};

	var _fetchHandler = function(items, requestObject){
		var oldAbortFunction = requestObject.abort || null;
		var aborted = false;

		var startIndex = requestObject.start?requestObject.start:0;
		var endIndex = (requestObject.count && (requestObject.count !== Infinity))?(startIndex + requestObject.count):items.length;

		requestObject.abort = function(){
			aborted = true;
			if(oldAbortFunction){
				oldAbortFunction.call(requestObject);
			}
		};

		var scope = requestObject.scope || dojo.global;
		if(!requestObject.store){
			requestObject.store = self;
		}
		if(requestObject.onBegin){
			requestObject.onBegin.call(scope, items.length, requestObject);
		}
		if(requestObject.sort){
			items.sort(dojo.data.util.sorter.createSortFunction(requestObject.sort, self));
		}
		if(requestObject.onItem){
			for(var i = startIndex; (i < items.length) && (i < endIndex); ++i){
				var item = items[i];
				if(!aborted){
					requestObject.onItem.call(scope, item, requestObject);
				}
			}
		}
		if(requestObject.onComplete && !aborted){
			var subset = null;
			if(!requestObject.onItem){
				subset = items.slice(startIndex, endIndex);
			}
			requestObject.onComplete.call(scope, subset, requestObject);
		}
	};
	this._fetchItems(request, _fetchHandler, _errorHandler);
	return request;	// Object
};

}

if(!dojo._hasResource["dojo.data.util.filter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.filter"] = true;
dojo.provide("dojo.data.util.filter");

dojo.data.util.filter.patternToRegExp = function(/*String*/pattern, /*boolean?*/ ignoreCase){
	//	summary:  
	//		Helper function to convert a simple pattern to a regular expression for matching.
	//	description:
	//		Returns a regular expression object that conforms to the defined conversion rules.
	//		For example:  
	//			ca*   -> /^ca.*$/
	//			*ca*  -> /^.*ca.*$/
	//			*c\*a*  -> /^.*c\*a.*$/
	//			*c\*a?*  -> /^.*c\*a..*$/
	//			and so on.
	//
	//	pattern: string
	//		A simple matching pattern to convert that follows basic rules:
	//			* Means match anything, so ca* means match anything starting with ca
	//			? Means match single character.  So, b?b will match to bob and bab, and so on.
	//      	\ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	//				To use a \ as a character in the string, it must be escaped.  So in the pattern it should be 
	//				represented by \\ to be treated as an ordinary \ character instead of an escape.
	//
	//	ignoreCase:
	//		An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	//		By default, it is assumed case sensitive.

	var rxp = "^";
	var c = null;
	for(var i = 0; i < pattern.length; i++){
		c = pattern.charAt(i);
		switch(c){
			case '\\':
				rxp += c;
				i++;
				rxp += pattern.charAt(i);
				break;
			case '*':
				rxp += ".*"; break;
			case '?':
				rxp += "."; break;
			case '$':
			case '^':
			case '/':
			case '+':
			case '.':
			case '|':
			case '(':
			case ')':
			case '{':
			case '}':
			case '[':
			case ']':
				rxp += "\\"; //fallthrough
			default:
				rxp += c;
		}
	}
	rxp += "$";
	if(ignoreCase){
		return new RegExp(rxp,"mi"); //RegExp
	}else{
		return new RegExp(rxp,"m"); //RegExp
	}
	
};

}

if(!dojo._hasResource["dijit.form.ComboBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ComboBox"] = true;
dojo.provide("dijit.form.ComboBox");









dojo.declare(
	"dijit.form.ComboBoxMixin",
	null,
	{
		// summary:
		//		Implements the base functionality for `dijit.form.ComboBox`/`dijit.form.FilteringSelect`
		// description:
		//		All widgets that mix in dijit.form.ComboBoxMixin must extend `dijit.form._FormValueWidget`.
		// tags:
		//		protected

		// item: Object
		//		This is the item returned by the dojo.data.store implementation that
		//		provides the data for this ComboBox, it's the currently selected item.
		item: null,

		// pageSize: Integer
		//		Argument to data provider.
		//		Specifies number of search results per page (before hitting "next" button)
		pageSize: Infinity,

		// store: Object
		//		Reference to data provider object used by this ComboBox
		store: null,

		// fetchProperties: Object
		//		Mixin to the dojo.data store's fetch.
		//		For example, to set the sort order of the ComboBox menu, pass:
		//	|	{ sort: {attribute:"name",descending: true} }
		//		To override the default queryOptions so that deep=false, do:
		//	|	{ queryOptions: {ignoreCase: true, deep: false} }
		fetchProperties:{},

		// query: Object
		//		A query that can be passed to 'store' to initially filter the items,
		//		before doing further filtering based on `searchAttr` and the key.
		//		Any reference to the `searchAttr` is ignored.
		query: {},

		// autoComplete: Boolean
		//		If user types in a partial string, and then tab out of the `<input>` box,
		//		automatically copy the first entry displayed in the drop down list to
		//		the `<input>` field
		autoComplete: true,

		// highlightMatch: String
		// 		One of: "first", "all" or "none".
		//
		//		If the ComboBox/FilteringSelect opens with the search results and the searched
		//		string can be found, it will be highlighted.  If set to "all"
		//		then will probably want to change `queryExpr` parameter to '*${0}*'
		//
		//		Highlighting is only performed when `labelType` is "text", so as to not
		//		interfere with any HTML markup an HTML label might contain.
		highlightMatch: "first",

		// searchDelay: Integer
		//		Delay in milliseconds between when user types something and we start
		//		searching based on that value
		searchDelay: 100,

		// searchAttr: String
		//		Search for items in the data store where this attribute (in the item)
		//		matches what the user typed
		searchAttr: "name",

		// labelAttr: String?
		//		The entries in the drop down list come from this attribute in the
		//		dojo.data items.
		//		If not specified, the searchAttr attribute is used instead.
		labelAttr: "",

		// labelType: String
		//		Specifies how to interpret the labelAttr in the data store items.
		//		Can be "html" or "text".
		labelType: "text",

		// queryExpr: String
		//		This specifies what query ComboBox/FilteringSelect sends to the data store,
		//		based on what the user has typed.  Changing this expression will modify
		//		whether the drop down shows only exact matches, a "starting with" match,
		//		etc.   Use it in conjunction with highlightMatch.
		//		dojo.data query expression pattern.
		//		`${0}` will be substituted for the user text.
		//		`*` is used for wildcards.
		//		`${0}*` means "starts with", `*${0}*` means "contains", `${0}` means "is"
		queryExpr: "${0}*",

		// ignoreCase: Boolean
		//		Set true if the ComboBox/FilteringSelect should ignore case when matching possible items
		ignoreCase: true,

		// hasDownArrow: [const] Boolean
		//		Set this textbox to have a down arrow button, to display the drop down list.
		//		Defaults to true.
		hasDownArrow: true,

		templateString: dojo.cache("dijit.form", "templates/ComboBox.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\r\n\tid=\"widget_${id}\"\r\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\" dojoAttachPoint=\"comboNode\" waiRole=\"combobox\" tabIndex=\"-1\"\r\n\t><div style=\"overflow:hidden;\"\r\n\t\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton'\r\n\t\t\tdojoAttachPoint=\"downArrowNode\" waiRole=\"presentation\"\r\n\t\t\tdojoAttachEvent=\"onmousedown:_onArrowMouseDown,onmouseup:_onMouse,onmouseenter:_onMouse,onmouseleave:_onMouse\"\r\n\t\t\t><div class=\"dijitArrowButtonInner\">&thinsp;</div\r\n\t\t\t><div class=\"dijitArrowButtonChar\">&#9660;</div\r\n\t\t></div\r\n\t\t><div class=\"dijitReset dijitValidationIcon\"><br></div\r\n\t\t><div class=\"dijitReset dijitValidationIconText\">&Chi;</div\r\n\t\t><div class=\"dijitReset dijitInputField\"\r\n\t\t\t><input ${nameAttrSetting} type=\"text\" autocomplete=\"off\" class='dijitReset'\r\n\t\t\tdojoAttachEvent=\"onkeypress:_onKeyPress,compositionend\"\r\n\t\t\tdojoAttachPoint=\"textbox,focusNode\" waiRole=\"textbox\" waiState=\"haspopup-true,autocomplete-list\"\r\n\t\t/></div\r\n\t></div\r\n></div>\r\n"),

		baseClass:"dijitComboBox",

		_getCaretPos: function(/*DomNode*/ element){
			// khtml 3.5.2 has selection* methods as does webkit nightlies from 2005-06-22
			var pos = 0;
			if(typeof(element.selectionStart) == "number"){
				// FIXME: this is totally borked on Moz < 1.3. Any recourse?
				pos = element.selectionStart;
			}else if(dojo.isIE){
				// in the case of a mouse click in a popup being handled,
				// then the dojo.doc.selection is not the textarea, but the popup
				// var r = dojo.doc.selection.createRange();
				// hack to get IE 6 to play nice. What a POS browser.
				var tr = dojo.doc.selection.createRange().duplicate();
				var ntr = element.createTextRange();
				tr.move("character",0);
				ntr.move("character",0);
				try{
					// If control doesnt have focus, you get an exception.
					// Seems to happen on reverse-tab, but can also happen on tab (seems to be a race condition - only happens sometimes).
					// There appears to be no workaround for this - googled for quite a while.
					ntr.setEndPoint("EndToEnd", tr);
					pos = String(ntr.text).replace(/\r/g,"").length;
				}catch(e){
					// If focus has shifted, 0 is fine for caret pos.
				}
			}
			return pos;
		},

		_setCaretPos: function(/*DomNode*/ element, /*Number*/ location){
			location = parseInt(location);
			dijit.selectInputText(element, location, location);
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			// Additional code to set disabled state of ComboBox node.
			// Overrides _FormValueWidget._setDisabledAttr() or ValidationTextBox._setDisabledAttr().
			this.inherited(arguments);
			dijit.setWaiState(this.comboNode, "disabled", value);
		},

		_abortQuery: function(){
			// stop in-progress query
			if(this.searchTimer){
				clearTimeout(this.searchTimer);
				this.searchTimer = null;
			}
			if(this._fetchHandle){
				if(this._fetchHandle.abort){ this._fetchHandle.abort(); }
				this._fetchHandle = null;
			}
		},

		_onKeyPress: function(/*Event*/ evt){
			// summary:
			//		Handles keyboard events
			var key = evt.charOrCode;
			// except for cutting/pasting case - ctrl + x/v
			if(evt.altKey || ((evt.ctrlKey || evt.metaKey) && (key != 'x' && key != 'v')) || key == dojo.keys.SHIFT){
				return; // throw out weird key combinations and spurious events
			}
			var doSearch = false;
			var searchFunction = "_startSearchFromInput";
			var pw = this._popupWidget;
			var dk = dojo.keys;
			var highlighted = null;
			this._prev_key_backspace = false;
			this._abortQuery();
			if(this._isShowingNow){
				pw.handleKey(key);
				highlighted = pw.getHighlightedOption();
			}
			switch(key){
				case dk.PAGE_DOWN:
				case dk.DOWN_ARROW:
				case dk.PAGE_UP:
				case dk.UP_ARROW:
					if(!this._isShowingNow){
						this._arrowPressed();
						doSearch = true;
						searchFunction = "_startSearchAll";
					}else{
						this._announceOption(highlighted);
					}
					dojo.stopEvent(evt);
					break;

				case dk.ENTER:
					// prevent submitting form if user presses enter. Also
					// prevent accepting the value if either Next or Previous
					// are selected
					if(highlighted){
						// only stop event on prev/next
						if(highlighted == pw.nextButton){
							this._nextSearch(1);
							dojo.stopEvent(evt);
							break;
						}else if(highlighted == pw.previousButton){
							this._nextSearch(-1);
							dojo.stopEvent(evt);
							break;
						}
					}else{
						// Update 'value' (ex: KY) according to currently displayed text
						this._setBlurValue(); // set value if needed
						this._setCaretPos(this.focusNode, this.focusNode.value.length); // move cursor to end and cancel highlighting
					}
					// default case:
					// prevent submit, but allow event to bubble
					evt.preventDefault();
					// fall through

				case dk.TAB:
					var newvalue = this.attr('displayedValue');
					//	if the user had More Choices selected fall into the
					//	_onBlur handler
					if(pw && (
						newvalue == pw._messages["previousMessage"] ||
						newvalue == pw._messages["nextMessage"])
					){
						break;
					}
					if(highlighted){
						this._selectOption();
					}
					if(this._isShowingNow){
						this._lastQuery = null; // in case results come back later
						this._hideResultList();
					}
					break;

				case ' ':
					if(highlighted){
						dojo.stopEvent(evt);
						this._selectOption();
						this._hideResultList();
					}else{
						doSearch = true;
					}
					break;

				case dk.ESCAPE:
					if(this._isShowingNow){
						dojo.stopEvent(evt);
						this._hideResultList();
					}
					break;

				case dk.DELETE:
				case dk.BACKSPACE:
					this._prev_key_backspace = true;
					doSearch = true;
					break;

				default:
					// Non char keys (F1-F12 etc..)  shouldn't open list.
					// Ascii characters and IME input (Chinese, Japanese etc.) should.
					// On IE and safari, IME input produces keycode == 229, and we simulate
					// it on firefox by attaching to compositionend event (see compositionend method)
					doSearch = typeof key == 'string' || key == 229;
			}
			if(doSearch){
				// need to wait a tad before start search so that the event
				// bubbles through DOM and we have value visible
				this.item = undefined; // undefined means item needs to be set
				this.searchTimer = setTimeout(dojo.hitch(this, searchFunction),1);
			}
		},

		_autoCompleteText: function(/*String*/ text){
			// summary:
			// 		Fill in the textbox with the first item from the drop down
			// 		list, and highlight the characters that were
			// 		auto-completed. For example, if user typed "CA" and the
			// 		drop down list appeared, the textbox would be changed to
			// 		"California" and "ifornia" would be highlighted.

			var fn = this.focusNode;

			// IE7: clear selection so next highlight works all the time
			dijit.selectInputText(fn, fn.value.length);
			// does text autoComplete the value in the textbox?
			var caseFilter = this.ignoreCase? 'toLowerCase' : 'substr';
			if(text[caseFilter](0).indexOf(this.focusNode.value[caseFilter](0)) == 0){
				var cpos = this._getCaretPos(fn);
				// only try to extend if we added the last character at the end of the input
				if((cpos+1) > fn.value.length){
					// only add to input node as we would overwrite Capitalisation of chars
					// actually, that is ok
					fn.value = text;//.substr(cpos);
					// visually highlight the autocompleted characters
					dijit.selectInputText(fn, cpos);
				}
			}else{
				// text does not autoComplete; replace the whole value and highlight
				fn.value = text;
				dijit.selectInputText(fn);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ dataObject){
			this._fetchHandle = null;
			if(	this.disabled ||
				this.readOnly ||
				(dataObject.query[this.searchAttr] != this._lastQuery)
			){
				return;
			}
			this._popupWidget.clearResultList();
			if(!results.length){
				this._hideResultList();
				return;
			}


			// Fill in the textbox with the first item from the drop down list,
			// and highlight the characters that were auto-completed. For
			// example, if user typed "CA" and the drop down list appeared, the
			// textbox would be changed to "California" and "ifornia" would be
			// highlighted.

			dataObject._maxOptions = this._maxOptions;
			var nodes = this._popupWidget.createOptions(
				results,
				dataObject,
				dojo.hitch(this, "_getMenuLabelFromItem")
			);

			// show our list (only if we have content, else nothing)
			this._showResultList();

			// #4091:
			//		tell the screen reader that the paging callback finished by
			//		shouting the next choice
			if(dataObject.direction){
				if(1 == dataObject.direction){
					this._popupWidget.highlightFirstOption();
				}else if(-1 == dataObject.direction){
					this._popupWidget.highlightLastOption();
				}
				this._announceOption(this._popupWidget.getHighlightedOption());
			}else if(this.autoComplete && !this._prev_key_backspace /*&& !dataObject.direction*/
				// when the user clicks the arrow button to show the full list,
				// startSearch looks for "*".
				// it does not make sense to autocomplete
				// if they are just previewing the options available.
				&& !/^[*]+$/.test(dataObject.query[this.searchAttr])){
					this._announceOption(nodes[1]); // 1st real item
			}
		},

		_showResultList: function(){
			this._hideResultList();
			this._arrowPressed();
			// hide the tooltip
			this.displayMessage("");

			// Position the list and if it's too big to fit on the screen then
			// size it to the maximum possible height
			// Our dear friend IE doesnt take max-height so we need to
			// calculate that on our own every time

			// TODO: want to redo this, see
			//		http://trac.dojotoolkit.org/ticket/3272
			//	and
			//		http://trac.dojotoolkit.org/ticket/4108


			// natural size of the list has changed, so erase old
			// width/height settings, which were hardcoded in a previous
			// call to this function (via dojo.marginBox() call)
			dojo.style(this._popupWidget.domNode, {width: "", height: ""});

			var best = this.open();
			// #3212:
			//		only set auto scroll bars if necessary prevents issues with
			//		scroll bars appearing when they shouldn't when node is made
			//		wider (fractional pixels cause this)
			var popupbox = dojo.marginBox(this._popupWidget.domNode);
			this._popupWidget.domNode.style.overflow =
				((best.h == popupbox.h) && (best.w == popupbox.w)) ? "hidden" : "auto";
			// #4134:
			//		borrow TextArea scrollbar test so content isn't covered by
			//		scrollbar and horizontal scrollbar doesn't appear
			var newwidth = best.w;
			if(best.h < this._popupWidget.domNode.scrollHeight){
				newwidth += 16;
			}
			dojo.marginBox(this._popupWidget.domNode, {
				h: best.h,
				w: Math.max(newwidth, this.domNode.offsetWidth)
			});
			
			// If we increased the width of drop down to match the width of ComboBox.domNode,
			// then need to reposition the drop down (wrapper) so (all of) the drop down still
			// appears underneath the ComboBox.domNode
			if(newwidth < this.domNode.offsetWidth){
				this._popupWidget.domNode.parentNode.style.left = dojo.position(this.domNode).x + "px";
			}

			dijit.setWaiState(this.comboNode, "expanded", "true");
		},

		_hideResultList: function(){
			this._abortQuery();
			if(this._isShowingNow){
				dijit.popup.close(this._popupWidget);
				this._arrowIdle();
				this._isShowingNow=false;
				dijit.setWaiState(this.comboNode, "expanded", "false");
				dijit.removeWaiState(this.focusNode,"activedescendant");
			}
		},

		_setBlurValue: function(){
			// if the user clicks away from the textbox OR tabs away, set the
			// value to the textbox value
			// #4617:
			//		if value is now more choices or previous choices, revert
			//		the value
			var newvalue=this.attr('displayedValue');
			var pw = this._popupWidget;
			if(pw && (
				newvalue == pw._messages["previousMessage"] ||
				newvalue == pw._messages["nextMessage"]
				)
			){
				this._setValueAttr(this._lastValueReported, true);
			}else if(typeof this.item == "undefined"){
				// Update 'value' (ex: KY) according to currently displayed text
				this.item = null;
				this.attr('displayedValue', newvalue);
			}else{
				if(this.value != this._lastValueReported){
					dijit.form._FormValueWidget.prototype._setValueAttr.call(this, this.value, true);
				}
				this._refreshState();
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's drop down
			this._hideResultList();
			this._arrowIdle();
			this.inherited(arguments);
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//              Set the displayed valued in the input box, and the hidden value
			//              that gets submitted, based on a dojo.data store item.
			// description:
			//              Users shouldn't call this function; they should be calling
			//              attr('item', value)
			// tags:
			//              private
			if(!displayedValue){ displayedValue = this.labelFunc(item, this.store); }
			this.value = this._getValueField() != this.searchAttr? this.store.getIdentity(item) : displayedValue;
			this.item = item;
			dijit.form.ComboBox.superclass._setValueAttr.call(this, this.value, priorityChange, displayedValue);
		},

		_announceOption: function(/*Node*/ node){
			// summary:
			//		a11y code that puts the highlighted option in the textbox.
			//		This way screen readers will know what is happening in the
			//		menu.

			if(!node){
				return;
			}
			// pull the text value from the item attached to the DOM node
			var newValue;
			if( node == this._popupWidget.nextButton ||
				node == this._popupWidget.previousButton){
				newValue = node.innerHTML;
				this.item = undefined;
				this.value = '';
			}else{
				newValue = this.labelFunc(node.item, this.store);
				this.attr('item', node.item, false, newValue);
			}
			// get the text that the user manually entered (cut off autocompleted text)
			this.focusNode.value = this.focusNode.value.substring(0, this._lastInput.length);
			// set up ARIA activedescendant
			dijit.setWaiState(this.focusNode, "activedescendant", dojo.attr(node, "id"));
			// autocomplete the rest of the option to announce change
			this._autoCompleteText(newValue);
		},

		_selectOption: function(/*Event*/ evt){
			// summary:
			//		Menu callback function, called when an item in the menu is selected.
			if(evt){
				this._announceOption(evt.target);
			}
			this._hideResultList();
			this._setCaretPos(this.focusNode, this.focusNode.value.length);
			dijit.form._FormValueWidget.prototype._setValueAttr.call(this, this.value, true); // set this.value and fire onChange
		},

		_onArrowMouseDown: function(evt){
			// summary:
			//		Callback when arrow is clicked
			if(this.disabled || this.readOnly){
				return;
			}
			dojo.stopEvent(evt);
			this.focus();
			if(this._isShowingNow){
				this._hideResultList();
			}else{
				// forces full population of results, if they click
				// on the arrow it means they want to see more options
				this._startSearchAll();
			}
		},

		_startSearchAll: function(){
			this._startSearch('');
		},

		_startSearchFromInput: function(){
			this._startSearch(this.focusNode.value.replace(/([\\\*\?])/g, "\\$1"));
		},

		_getQueryString: function(/*String*/ text){
			return dojo.string.substitute(this.queryExpr, [text]);
		},

		_startSearch: function(/*String*/ key){
			if(!this._popupWidget){
				var popupId = this.id + "_popup";
				this._popupWidget = new dijit.form._ComboBoxMenu({
					onChange: dojo.hitch(this, this._selectOption),
					id: popupId
				});
				dijit.removeWaiState(this.focusNode,"activedescendant");
				dijit.setWaiState(this.textbox,"owns",popupId); // associate popup with textbox
			}
			// create a new query to prevent accidentally querying for a hidden
			// value from FilteringSelect's keyField
			var query = dojo.clone(this.query); // #5970
			this._lastInput = key; // Store exactly what was entered by the user.
			this._lastQuery = query[this.searchAttr] = this._getQueryString(key);
			// #5970: set _lastQuery, *then* start the timeout
			// otherwise, if the user types and the last query returns before the timeout,
			// _lastQuery won't be set and their input gets rewritten
			this.searchTimer=setTimeout(dojo.hitch(this, function(query, _this){
				this.searchTimer = null;
				var fetch = {
					queryOptions: {
						ignoreCase: this.ignoreCase,
						deep: true
					},
					query: query,
					onBegin: dojo.hitch(this, "_setMaxOptions"),
					onComplete: dojo.hitch(this, "_openResultList"),
					onError: function(errText){
						_this._fetchHandle = null;
						console.error('dijit.form.ComboBox: ' + errText);
						dojo.hitch(_this, "_hideResultList")();
					},
					start: 0,
					count: this.pageSize
				};
				dojo.mixin(fetch, _this.fetchProperties);
				this._fetchHandle = _this.store.fetch(fetch);

				var nextSearch = function(dataObject, direction){
					dataObject.start += dataObject.count*direction;
					// #4091:
					//		tell callback the direction of the paging so the screen
					//		reader knows which menu option to shout
					dataObject.direction = direction;
					this._fetchHandle = this.store.fetch(dataObject);
				};
				this._nextSearch = this._popupWidget.onPage = dojo.hitch(this, nextSearch, this._fetchHandle);
			}, query, this), this.searchDelay);
		},

		_setMaxOptions: function(size, request){
			 this._maxOptions = size;
		},

		_getValueField: function(){
			// summmary:
			//		Helper for postMixInProperties() to set this.value based on data inlined into the markup.
			//		Returns the attribute name in the item (in dijit.form._ComboBoxDataStore) to use as the value.
			return this.searchAttr;
		},

		/////////////// Event handlers /////////////////////

		_arrowPressed: function(){
			if(!this.disabled && !this.readOnly && this.hasDownArrow){
				dojo.addClass(this.downArrowNode, "dijitArrowButtonActive");
			}
		},

		_arrowIdle: function(){
			if(!this.disabled && !this.readOnly && this.hasDownArrow){
				dojo.removeClass(this.downArrowNode, "dojoArrowButtonPushed");
			}
		},

		// FIXME: For 2.0, rename to "_compositionEnd"
		compositionend: function(/*Event*/ evt){
			// summary:
			//		When inputting characters using an input method, such as
			//		Asian languages, it will generate this event instead of
			//		onKeyDown event.
			//		Note: this event is only triggered in FF (not in IE/safari)
			// tags:
			//		private

			// 229 is the code produced by IE and safari while pressing keys during
			// IME input mode
			this._onKeyPress({charOrCode: 229});
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.query={};
			this.fetchProperties={};
		},

		postMixInProperties: function(){
			if(!this.hasDownArrow){
				this.baseClass = "dijitTextBox";
			}
			if(!this.store){
				var srcNodeRef = this.srcNodeRef;

				// if user didn't specify store, then assume there are option tags
				this.store = new dijit.form._ComboBoxDataStore(srcNodeRef);

				// if there is no value set and there is an option list, set
				// the value to the first value to be consistent with native
				// Select

				// Firefox and Safari set value
				// IE6 and Opera set selectedIndex, which is automatically set
				// by the selected attribute of an option tag
				// IE6 does not set value, Opera sets value = selectedIndex
				if(	!this.value || (
						(typeof srcNodeRef.selectedIndex == "number") &&
						srcNodeRef.selectedIndex.toString() === this.value)
				){
					var item = this.store.fetchSelectedItem();
					if(item){
						var valueField = this._getValueField();
						this.value = valueField != this.searchAttr? this.store.getValue(item, valueField) : this.labelFunc(item, this.store);
					}
				}
			}
			this.inherited(arguments);
		},

		postCreate: function(){
			// summary:
			//		Subclasses must call this method from their postCreate() methods
			// tags:
			//		protected

			// find any associated label element and add to ComboBox node.
			var label=dojo.query('label[for="'+this.id+'"]');
			if(label.length){
				label[0].id = (this.id+"_label");
				var cn=this.comboNode;
				dijit.setWaiState(cn, "labelledby", label[0].id);

			}
			this.inherited(arguments);
		},

		uninitialize: function(){
			if(this._popupWidget && !this._popupWidget._destroyed){
				this._hideResultList();
				this._popupWidget.destroy();
			}
			this.inherited(arguments);
		},

		_getMenuLabelFromItem: function(/*Item*/ item){
			var label = this.labelAttr? this.store.getValue(item, this.labelAttr) : this.labelFunc(item, this.store);
			var labelType = this.labelType;
			// If labelType is not "text" we don't want to screw any markup ot whatever.
			if(this.highlightMatch != "none" && this.labelType == "text" && this._lastInput){
				label = this.doHighlight(label, this._escapeHtml(this._lastInput));
				labelType = "html";
			}
			return {html: labelType == "html", label: label};
		},

		doHighlight: function(/*String*/label, /*String*/find){
			// summary:
			//		Highlights the string entered by the user in the menu.  By default this
			//		highlights the first occurence found. Override this method
			//		to implement your custom highlighing.
			// tags:
			//		protected

			// Add greedy when this.highlightMatch == "all"
			var modifiers = "i"+(this.highlightMatch == "all"?"g":"");
			var escapedLabel = this._escapeHtml(label);
			find = dojo.regexp.escapeString(find); // escape regexp special chars
			var ret = escapedLabel.replace(new RegExp("(^|\\s)("+ find +")", modifiers),
					'$1<span class="dijitComboBoxHighlightMatch">$2</span>');
			return ret;// returns String, (almost) valid HTML (entities encoded)
		},

		_escapeHtml: function(/*string*/str){
			// TODO Should become dojo.html.entities(), when exists use instead
			// summary:
			//		Adds escape sequences for special characters in XML: &<>"'
			str = String(str).replace(/&/gm, "&amp;").replace(/</gm, "&lt;")
				.replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
			return str; // string
		},

		open: function(){
			// summary:
			//		Opens the drop down menu.  TODO: rename to _open.
			// tags:
			//		private
			this._isShowingNow=true;
			return dijit.popup.open({
				popup: this._popupWidget,
				around: this.domNode,
				parent: this
			});
		},

		reset: function(){
			// Overrides the _FormWidget.reset().
			// Additionally reset the .item (to clean up).
			this.item = null;
			this.inherited(arguments);
		},

		labelFunc: function(/*item*/ item, /*dojo.data.store*/ store){
			// summary:
			//              Computes the label to display based on the dojo.data store item.
			// returns:
			//              The label that the ComboBox should display
			// tags:
			//              private

			// Use toString() because XMLStore returns an XMLItem whereas this
			// method is expected to return a String (#9354)
			return store.getValue(item, this.searchAttr).toString(); // String
		}
	}
);

dojo.declare(
	"dijit.form._ComboBoxMenu",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		Focus-less menu for internal use in `dijit.form.ComboBox`
		// tags:
		//		private

		templateString: "<ul class='dijitReset dijitMenu' dojoAttachEvent='onmousedown:_onMouseDown,onmouseup:_onMouseUp,onmouseover:_onMouseOver,onmouseout:_onMouseOut' tabIndex='-1' style='overflow: \"auto\"; overflow-x: \"hidden\";'>"
				+"<li class='dijitMenuItem dijitMenuPreviousButton' dojoAttachPoint='previousButton' waiRole='option'></li>"
				+"<li class='dijitMenuItem dijitMenuNextButton' dojoAttachPoint='nextButton' waiRole='option'></li>"
			+"</ul>",

		// _messages: Object
		//		Holds "next" and "previous" text for paging buttons on drop down
		_messages: null,

		postMixInProperties: function(){
			this._messages = dojo.i18n.getLocalization("dijit.form", "ComboBox", this.lang);
			this.inherited(arguments);
		},

		_setValueAttr: function(/*Object*/ value){
			this.value = value;
			this.onChange(value);
		},

		// stubs
		onChange: function(/*Object*/ value){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked an option in the drop down menu.
			//		Probably should be called onSelect.
			// tags:
			//		callback
		},
		onPage: function(/*Number*/ direction){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked to advance to next/previous page.
			// tags:
			//		callback
		},

		postCreate: function(){
			// fill in template with i18n messages
			this.previousButton.innerHTML = this._messages["previousMessage"];
			this.nextButton.innerHTML = this._messages["nextMessage"];
			this.inherited(arguments);
		},

		onClose: function(){
			// summary:
			//		Callback from dijit.popup code to this widget, notifying it that it closed
			// tags:
			//		private
			this._blurOptionNode();
		},

		_createOption: function(/*Object*/ item, labelFunc){
			// summary:
			//		Creates an option to appear on the popup menu subclassed by
			//		`dijit.form.FilteringSelect`.

			var labelObject = labelFunc(item);
			var menuitem = dojo.doc.createElement("li");
			dijit.setWaiRole(menuitem, "option");
			if(labelObject.html){
				menuitem.innerHTML = labelObject.label;
			}else{
				menuitem.appendChild(
					dojo.doc.createTextNode(labelObject.label)
				);
			}
			// #3250: in blank options, assign a normal height
			if(menuitem.innerHTML == ""){
				menuitem.innerHTML = "&nbsp;";
			}
			menuitem.item=item;
			return menuitem;
		},

		createOptions: function(results, dataObject, labelFunc){
			// summary:
			//		Fills in the items in the drop down list
			// results:
			//		Array of dojo.data items
			// dataObject:
			//		dojo.data store
			// labelFunc:
			//		Function to produce a label in the drop down list from a dojo.data item

			//this._dataObject=dataObject;
			//this._dataObject.onComplete=dojo.hitch(comboBox, comboBox._openResultList);
			// display "Previous . . ." button
			this.previousButton.style.display = (dataObject.start == 0) ? "none" : "";
			dojo.attr(this.previousButton, "id", this.id + "_prev");
			// create options using _createOption function defined by parent
			// ComboBox (or FilteringSelect) class
			// #2309:
			//		iterate over cache nondestructively
			dojo.forEach(results, function(item, i){
				var menuitem = this._createOption(item, labelFunc);
				menuitem.className = "dijitReset dijitMenuItem";
				dojo.attr(menuitem, "id", this.id + i);
				this.domNode.insertBefore(menuitem, this.nextButton);
			}, this);
			// display "Next . . ." button
			var displayMore = false;
			//Try to determine if we should show 'more'...
			if(dataObject._maxOptions && dataObject._maxOptions != -1){
				if((dataObject.start + dataObject.count) < dataObject._maxOptions){
					displayMore = true;
				}else if((dataObject.start + dataObject.count) > (dataObject._maxOptions - 1)){
					//Weird return from a datastore, where a start + count > maxOptions
					// implies maxOptions isn't really valid and we have to go into faking it.
					//And more or less assume more if count == results.length
					if(dataObject.count == results.length){
						displayMore = true;
					}
				}
			}else if(dataObject.count == results.length){
				//Don't know the size, so we do the best we can based off count alone.
				//So, if we have an exact match to count, assume more.
				displayMore = true;
			}

			this.nextButton.style.display = displayMore ? "" : "none";
			dojo.attr(this.nextButton,"id", this.id + "_next");
			return this.domNode.childNodes;
		},

		clearResultList: function(){
			// summary:
			//		Clears the entries in the drop down list, but of course keeps the previous and next buttons.
			while(this.domNode.childNodes.length>2){
				this.domNode.removeChild(this.domNode.childNodes[this.domNode.childNodes.length-2]);
			}
		},

		_onMouseDown: function(/*Event*/ evt){
			dojo.stopEvent(evt);
		},

		_onMouseUp: function(/*Event*/ evt){
			if(evt.target === this.domNode){
				return;
			}else if(evt.target == this.previousButton){
				this.onPage(-1);
			}else if(evt.target == this.nextButton){
				this.onPage(1);
			}else{
				var tgt = evt.target;
				// while the clicked node is inside the div
				while(!tgt.item){
					// recurse to the top
					tgt = tgt.parentNode;
				}
				this._setValueAttr({ target: tgt }, true);
			}
		},

		_onMouseOver: function(/*Event*/ evt){
			if(evt.target === this.domNode){ return; }
			var tgt = evt.target;
			if(!(tgt == this.previousButton || tgt == this.nextButton)){
				// while the clicked node is inside the div
				while(!tgt.item){
					// recurse to the top
					tgt = tgt.parentNode;
				}
			}
			this._focusOptionNode(tgt);
		},

		_onMouseOut: function(/*Event*/ evt){
			if(evt.target === this.domNode){ return; }
			this._blurOptionNode();
		},

		_focusOptionNode: function(/*DomNode*/ node){
			// summary:
			//		Does the actual highlight.
			if(this._highlighted_option != node){
				this._blurOptionNode();
				this._highlighted_option = node;
				dojo.addClass(this._highlighted_option, "dijitMenuItemSelected");
			}
		},

		_blurOptionNode: function(){
			// summary:
			//		Removes highlight on highlighted option.
			if(this._highlighted_option){
				dojo.removeClass(this._highlighted_option, "dijitMenuItemSelected");
				this._highlighted_option = null;
			}
		},

		_highlightNextOption: function(){
			// summary:
			// 		Highlight the item just below the current selection.
			// 		If nothing selected, highlight first option.

			// because each press of a button clears the menu,
			// the highlighted option sometimes becomes detached from the menu!
			// test to see if the option has a parent to see if this is the case.
			var fc = this.domNode.firstChild;
			if(!this.getHighlightedOption()){
				this._focusOptionNode(fc.style.display == "none" ? fc.nextSibling : fc);
			}else{
				var ns = this._highlighted_option.nextSibling;
				if(ns && ns.style.display != "none"){
					this._focusOptionNode(ns);
				}
			}
			// scrollIntoView is called outside of _focusOptionNode because in IE putting it inside causes the menu to scroll up on mouseover
			dijit.scrollIntoView(this._highlighted_option);
		},

		highlightFirstOption: function(){
			// summary:
			// 		Highlight the first real item in the list (not Previous Choices).
			this._focusOptionNode(this.domNode.firstChild.nextSibling);
			dijit.scrollIntoView(this._highlighted_option);
		},

		highlightLastOption: function(){
			// summary:
			// 		Highlight the last real item in the list (not More Choices).
			this._focusOptionNode(this.domNode.lastChild.previousSibling);
			dijit.scrollIntoView(this._highlighted_option);
		},

		_highlightPrevOption: function(){
			// summary:
			// 		Highlight the item just above the current selection.
			// 		If nothing selected, highlight last option (if
			// 		you select Previous and try to keep scrolling up the list).
			var lc = this.domNode.lastChild;
			if(!this.getHighlightedOption()){
				this._focusOptionNode(lc.style.display == "none" ? lc.previousSibling : lc);
			}else{
				var ps = this._highlighted_option.previousSibling;
				if(ps && ps.style.display != "none"){
					this._focusOptionNode(ps);
				}
			}
			dijit.scrollIntoView(this._highlighted_option);
		},

		_page: function(/*Boolean*/ up){
			// summary:
			//		Handles page-up and page-down keypresses

			var scrollamount = 0;
			var oldscroll = this.domNode.scrollTop;
			var height = dojo.style(this.domNode, "height");
			// if no item is highlighted, highlight the first option
			if(!this.getHighlightedOption()){
				this._highlightNextOption();
			}
			while(scrollamount<height){
				if(up){
					// stop at option 1
					if(!this.getHighlightedOption().previousSibling ||
						this._highlighted_option.previousSibling.style.display == "none"){
						break;
					}
					this._highlightPrevOption();
				}else{
					// stop at last option
					if(!this.getHighlightedOption().nextSibling ||
						this._highlighted_option.nextSibling.style.display == "none"){
						break;
					}
					this._highlightNextOption();
				}
				// going backwards
				var newscroll=this.domNode.scrollTop;
				scrollamount+=(newscroll-oldscroll)*(up ? -1:1);
				oldscroll=newscroll;
			}
		},

		pageUp: function(){
			// summary:
			//		Handles pageup keypress.
			//		TODO: just call _page directly from handleKey().
			// tags:
			//		private
			this._page(true);
		},

		pageDown: function(){
			// summary:
			//		Handles pagedown keypress.
			//		TODO: just call _page directly from handleKey().
			// tags:
			//		private
			this._page(false);
		},

		getHighlightedOption: function(){
			// summary:
			//		Returns the highlighted option.
			var ho = this._highlighted_option;
			return (ho && ho.parentNode) ? ho : null;
		},

		handleKey: function(key){
			switch(key){
				case dojo.keys.DOWN_ARROW:
					this._highlightNextOption();
					break;
				case dojo.keys.PAGE_DOWN:
					this.pageDown();
					break;
				case dojo.keys.UP_ARROW:
					this._highlightPrevOption();
					break;
				case dojo.keys.PAGE_UP:
					this.pageUp();
					break;
			}
		}
	}
);

dojo.declare(
	"dijit.form.ComboBox",
	[dijit.form.ValidationTextBox, dijit.form.ComboBoxMixin],
	{
		// summary:
		//		Auto-completing text box, and base class for dijit.form.FilteringSelect.
		//
		// description:
		//		The drop down box's values are populated from an class called
		//		a data provider, which returns a list of values based on the characters
		//		that the user has typed into the input box.
		//		If OPTION tags are used as the data provider via markup,
		//		then the OPTION tag's child text node is used as the widget value
		//		when selected.  The OPTION tag's value attribute is ignored.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Some of the options to the ComboBox are actually arguments to the data
		//		provider.

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Hook so attr('value', value) works.
			// description:
			//		Sets the value of the select.
			this.item = null; // value not looked up in store
			if(!value){ value = ''; } // null translates to blank
			dijit.form.ValidationTextBox.prototype._setValueAttr.call(this, value, priorityChange, displayedValue);
		}
	}
);

dojo.declare("dijit.form._ComboBoxDataStore", null, {
	// summary:
	//		Inefficient but small data store specialized for inlined `dijit.form.ComboBox` data
	//
	// description:
	//		Provides a store for inlined data like:
	//
	//	|	<select>
	//	|		<option value="AL">Alabama</option>
	//	|		...
	//
	//		Actually. just implements the subset of dojo.data.Read/Notification
	//		needed for ComboBox and FilteringSelect to work.
	//
	//		Note that an item is just a pointer to the <option> DomNode.

	constructor: function( /*DomNode*/ root){
		this.root = root;

		dojo.query("> option", root).forEach(function(node){
			//	TODO: this was added in #3858 but unclear why/if it's needed;  doesn't seem to be.
			//	If it is needed then can we just hide the select itself instead?
			//node.style.display="none";
			node.innerHTML = dojo.trim(node.innerHTML);
		});

	},

	getValue: function(	/* item */ item,
						/* attribute-name-string */ attribute,
						/* value? */ defaultValue){
		return (attribute == "value") ? item.value : (item.innerText || item.textContent || '');
	},

	isItemLoaded: function(/* anything */ something){
		return true;
	},

	getFeatures: function(){
		return {"dojo.data.api.Read": true, "dojo.data.api.Identity": true};
	},

	_fetchItems: function(	/* Object */ args,
							/* Function */ findCallback,
							/* Function */ errorCallback){
		// summary:
		//		See dojo.data.util.simpleFetch.fetch()
		if(!args.query){ args.query = {}; }
		if(!args.query.name){ args.query.name = ""; }
		if(!args.queryOptions){ args.queryOptions = {}; }
		var matcher = dojo.data.util.filter.patternToRegExp(args.query.name, args.queryOptions.ignoreCase),
			items = dojo.query("> option", this.root).filter(function(option){
				return (option.innerText || option.textContent || '').match(matcher);
			} );
		if(args.sort){
			items.sort(dojo.data.util.sorter.createSortFunction(args.sort, this));
		}
		findCallback(items, args);
	},

	close: function(/*dojo.data.api.Request || args || null */ request){
		return;
	},

	getLabel: function(/* item */ item){
		return item.innerHTML;
	},

	getIdentity: function(/* item */ item){
		return dojo.attr(item, "value");
	},

	fetchItemByIdentity: function(/* Object */ args){
		// summary:
		//		Given the identity of an item, this method returns the item that has
		//		that identity through the onItem callback.
		//		Refer to dojo.data.api.Identity.fetchItemByIdentity() for more details.
		//
		// description:
		//		Given arguments like:
		//
		//	|		{identity: "CA", onItem: function(item){...}
		//
		//		Call `onItem()` with the DOM node `<option value="CA">California</option>`
		var item = dojo.query("option[value='" + args.identity + "']", this.root)[0];
		args.onItem(item);
	},

	fetchSelectedItem: function(){
		// summary:
		//		Get the option marked as selected, like `<option selected>`.
		//		Not part of dojo.data API.
		var root = this.root,
			si = root.selectedIndex;
		return dojo.query("> option:nth-child(" +
			(si != -1 ? si+1 : 1) + ")",
			root)[0];	// dojo.data.Item
	}
});
//Mix in the simple fetch implementation to this class.
dojo.extend(dijit.form._ComboBoxDataStore,dojo.data.util.simpleFetch);

}

if(!dojo._hasResource["dijit.form.FilteringSelect"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.FilteringSelect"] = true;
dojo.provide("dijit.form.FilteringSelect");



dojo.declare(
	"dijit.form.FilteringSelect",
	[dijit.form.MappedTextBox, dijit.form.ComboBoxMixin],
	{
		// summary:
		//		An enhanced version of the HTML SELECT tag, populated dynamically
		//
		// description:
		//		An enhanced version of the HTML SELECT tag, populated dynamically. It works
		//		very nicely with very large data sets because it can load and page data as needed.
		//		It also resembles ComboBox, but does not allow values outside of the provided ones.
		//		If OPTION tags are used as the data provider via markup, then the
		//		OPTION tag's child text node is used as the displayed value when selected
		//		while the OPTION tag's value attribute is used as the widget value on form submit.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Similar features:
		//			- There is a drop down list of possible values.
		//			- You can only enter a value from the drop down list.  (You can't
		//				enter an arbitrary value.)
		//			- The value submitted with the form is the hidden value (ex: CA),
		//				not the displayed value a.k.a. label (ex: California)
		//
		//		Enhancements over plain HTML version:
		//			- If you type in some text then it will filter down the list of
		//				possible values in the drop down list.
		//			- List can be specified either as a static list or via a javascript
		//				function (that can get the list from a server)

		_isvalid: true,

		// required: Boolean
		//		True (default) if user is required to enter a value into this field.
		required: true,

		_lastDisplayedValue: "",

		isValid: function(){
			// Overrides ValidationTextBox.isValid()
			return this._isvalid || (!this.required && this.attr('displayedValue') == ""); // #5974
		},

		_callbackSetLabel: function(	/*Array*/ result,
						/*Object*/ dataObject,
						/*Boolean?*/ priorityChange){
			// summary:
			//		Callback function that dynamically sets the label of the
			//		ComboBox

			// setValue does a synchronous lookup,
			// so it calls _callbackSetLabel directly,
			// and so does not pass dataObject
			// still need to test against _lastQuery in case it came too late
			if((dataObject && dataObject.query[this.searchAttr] != this._lastQuery) || (!dataObject && result.length && this.store.getIdentity(result[0]) != this._lastQuery)){
				return;
			}
			if(!result.length){
				//#3268: do nothing on bad input
				//#3285: change CSS to indicate error
				this.valueNode.value = "";
				dijit.form.TextBox.superclass._setValueAttr.call(this, "", priorityChange || (priorityChange === undefined && !this._focused));
				this._isvalid = false;
				this.validate(this._focused);
				this.item = null;
			}else{
				this.attr('item', result[0], priorityChange);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ dataObject){
			// Overrides ComboBox._openResultList()

			// #3285: tap into search callback to see if user's query resembles a match
			if(dataObject.query[this.searchAttr] != this._lastQuery){
				return;
			}
			this._isvalid = results.length != 0; // FIXME: should this be greater-than?
			this.validate(true);
			dijit.form.ComboBoxMixin.prototype._openResultList.apply(this, arguments);
		},

		_getValueAttr: function(){
			// summary:
			//		Hook for attr('value') to work.

			// don't get the textbox value but rather the previously set hidden value.
			// Use this.valueNode.value which isn't always set for other MappedTextBox widgets until blur
			return this.valueNode.value;
		},

		_getValueField: function(){
			// Overrides ComboBox._getValueField()
			return "value";
		},

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so attr('value', value) works.
			// description:
			//		Sets the value of the select.
			//		Also sets the label to the corresponding value by reverse lookup.
			if(!this._onChangeActive){ priorityChange = null; }
			this._lastQuery = value;

			if(value === null || value === ''){
				this._setDisplayedValueAttr('', priorityChange);
				return;
			}

			//#3347: fetchItemByIdentity if no keyAttr specified
			var self = this;
			this.store.fetchItemByIdentity({
				identity: value,
				onItem: function(item){
					self._callbackSetLabel([item], undefined, priorityChange);
				}
			});
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		attr('item', value)
			// tags:
			//		private
			this._isvalid = true;
			this.inherited(arguments);
			this.valueNode.value = this.value;
			this._lastDisplayedValue = this.textbox.value;
		},

		_getDisplayQueryString: function(/*String*/ text){
			return text.replace(/([\\\*\?])/g, "\\$1");
		},

		_setDisplayedValueAttr: function(/*String*/ label, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so attr('displayedValue', label) works.
			// description:
			//		Sets textbox to display label. Also performs reverse lookup
			//		to set the hidden value.

			// When this is called during initialization it'll ping the datastore
			// for reverse lookup, and when that completes (after an XHR request)
			// will call setValueAttr()... but that shouldn't trigger an onChange()
			// event, even when it happens after creation has finished
			if(!this._created){
				priorityChange = false;
			}

			if(this.store){
				this._hideResultList();
				var query = dojo.clone(this.query); // #6196: populate query with user-specifics
				// escape meta characters of dojo.data.util.filter.patternToRegExp().
				this._lastQuery = query[this.searchAttr] = this._getDisplayQueryString(label);
				// if the label is not valid, the callback will never set it,
				// so the last valid value will get the warning textbox set the
				// textbox value now so that the impending warning will make
				// sense to the user
				this.textbox.value = label;
				this._lastDisplayedValue = label;
				var _this = this;
				var fetch = {
					query: query,
					queryOptions: {
						ignoreCase: this.ignoreCase,
						deep: true
					},
					onComplete: function(result, dataObject){
						_this._fetchHandle = null;
						dojo.hitch(_this, "_callbackSetLabel")(result, dataObject, priorityChange);
					},
					onError: function(errText){
						_this._fetchHandle = null;
						console.error('dijit.form.FilteringSelect: ' + errText);
						dojo.hitch(_this, "_callbackSetLabel")([], undefined, false);
					}
				};
				dojo.mixin(fetch, this.fetchProperties);
				this._fetchHandle = this.store.fetch(fetch);
			}
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this._isvalid = !this.required;
		},

		undo: function(){
			this.attr('displayedValue', this._lastDisplayedValue);
		}
	}
);

}

if(!dojo._hasResource["dijit.form.SimpleTextarea"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.SimpleTextarea"] = true;
dojo.provide("dijit.form.SimpleTextarea");



dojo.declare("dijit.form.SimpleTextarea",
	dijit.form.TextBox,
	{
	// summary:
	//		A simple textarea that degrades, and responds to
	// 		minimal LayoutContainer usage, and works with dijit.form.Form.
	//		Doesn't automatically size according to input, like Textarea.
	//
	// example:
	//	|	<textarea dojoType="dijit.form.SimpleTextarea" name="foo" value="bar" rows=30 cols=40></textarea>
	//
	// example:
	//	|	new dijit.form.SimpleTextarea({ rows:20, cols:30 }, "foo");

	baseClass: "dijitTextArea",

	attributeMap: dojo.delegate(dijit.form._FormValueWidget.prototype.attributeMap, {
		rows:"textbox", cols: "textbox"
	}),

	// rows: Number
	//		The number of rows of text.
	rows: "3",

	// rows: Number
	//		The number of characters per line.
	cols: "20",

	templateString: "<textarea ${nameAttrSetting} dojoAttachPoint='focusNode,containerNode,textbox' autocomplete='off'></textarea>",

	postMixInProperties: function(){
		// Copy value from srcNodeRef, unless user specified a value explicitly (or there is no srcNodeRef)
		if(!this.value && this.srcNodeRef){
			this.value = this.srcNodeRef.value;
		}
		this.inherited(arguments);
	},

	filter: function(/*String*/ value){
		// Override TextBox.filter to deal with newlines... specifically (IIRC) this is for IE which writes newlines
		// as \r\n instead of just \n
		if(value){
			value = value.replace(/\r/g,"");
		}
		return this.inherited(arguments);
	},

	postCreate: function(){
		this.inherited(arguments);
		if(dojo.isIE && this.cols){ // attribute selectors is not supported in IE6
			dojo.addClass(this.textbox, "dijitTextAreaCols");
		}
	},

	_previousValue: "",
	_onInput: function(/*Event?*/ e){
		// Override TextBox._onInput() to enforce maxLength restriction
		if(this.maxLength){
			var maxLength = parseInt(this.maxLength);
			var value = this.textbox.value.replace(/\r/g,'');
			var overflow = value.length - maxLength;
			if(overflow > 0){
				if(e){ dojo.stopEvent(e); }
				var textarea = this.textbox;
				if(textarea.selectionStart){
					var pos = textarea.selectionStart;
					var cr = 0;
					if(dojo.isOpera){
						cr = (this.textbox.value.substring(0,pos).match(/\r/g) || []).length;
					}
					this.textbox.value = value.substring(0,pos-overflow-cr)+value.substring(pos-cr);
					textarea.setSelectionRange(pos-overflow, pos-overflow);
				}else if(dojo.doc.selection){ //IE
					textarea.focus();
					var range = dojo.doc.selection.createRange();
					// delete overflow characters
					range.moveStart("character", -overflow);
					range.text = '';
					// show cursor
					range.select();
				}
			}
			this._previousValue = this.textbox.value;
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["dijit.form.Textarea"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Textarea"] = true;
dojo.provide("dijit.form.Textarea");



dojo.declare(
	"dijit.form.Textarea",
	dijit.form.SimpleTextarea,
	{
	// summary:
	//		A textarea widget that adjusts it's height according to the amount of data.
	//
	// description:
	//		A textarea that dynamically expands/contracts (changing it's height) as
	//		the user types, to display all the text without requiring a scroll bar.
	//
	//		Takes nearly all the parameters (name, value, etc.) that a vanilla textarea takes.
	//		Rows is not supported since this widget adjusts the height.
	//
	// example:
	// |	<textarea dojoType="dijit.form.TextArea">...</textarea>


	// Override SimpleTextArea.cols to default to width:100%, for backward compatibility
	cols: "",

	_previousNewlines: 0,
	_strictMode: (dojo.doc.compatMode != 'BackCompat'), // not the same as !dojo.isQuirks

	_getHeight: function(textarea){
		var newH = textarea.scrollHeight;
		if(dojo.isIE){
			newH += textarea.offsetHeight - textarea.clientHeight - ((dojo.isIE < 8 && this._strictMode) ? dojo._getPadBorderExtents(textarea).h : 0);
		}else if(dojo.isMoz){
			newH += textarea.offsetHeight - textarea.clientHeight; // creates room for horizontal scrollbar
		}else if(dojo.isWebKit && !(dojo.isSafari < 4)){ // Safari 4.0 && Chrome
			newH += dojo._getBorderExtents(textarea).h;
		}else{ // Safari 3.x and Opera 9.6
			newH += dojo._getPadBorderExtents(textarea).h;
		}
		return newH;
	},

	_estimateHeight: function(textarea){
		// summary:
		// 		Approximate the height when the textarea is invisible with the number of lines in the text.
		// 		Fails when someone calls setValue with a long wrapping line, but the layout fixes itself when the user clicks inside so . . .
		// 		In IE, the resize event is supposed to fire when the textarea becomes visible again and that will correct the size automatically.
		//
		textarea.style.maxHeight = "";
		textarea.style.height = "auto";
		// #rows = #newlines+1
		// Note: on Moz, the following #rows appears to be 1 too many.
		// Actually, Moz is reserving room for the scrollbar.
		// If you increase the font size, this behavior becomes readily apparent as the last line gets cut off without the +1.
		textarea.rows = (textarea.value.match(/\n/g) || []).length + 1;
	},

	_needsHelpShrinking: dojo.isMoz || dojo.isWebKit,

	_onInput: function(){
		// Override SimpleTextArea._onInput() to deal with height adjustment
		this.inherited(arguments);
		if(this._busyResizing){ return; }
		this._busyResizing = true;
		var textarea = this.textbox;
		if(textarea.scrollHeight && textarea.offsetHeight && textarea.clientHeight){
			var newH = this._getHeight(textarea) + "px";
			if(textarea.style.height != newH){
				textarea.style.maxHeight = textarea.style.height = newH;
			}
			if(this._needsHelpShrinking){
				if(this._setTimeoutHandle){
					clearTimeout(this._setTimeoutHandle);
				}
				this._setTimeoutHandle = setTimeout(dojo.hitch(this, "_shrink"), 0); // try to collapse multiple shrinks into 1
			}
		}else{
			// hidden content of unknown size
			this._estimateHeight(textarea);
		}
		this._busyResizing = false;
	},

	_busyResizing: false,
	_shrink: function(){
		// grow paddingBottom to see if scrollHeight shrinks (when it is unneccesarily big)
		this._setTimeoutHandle = null;
		if(this._needsHelpShrinking && !this._busyResizing){
			this._busyResizing = true;
			var textarea = this.textbox;
			var empty = false;
			if(textarea.value == ''){
				textarea.value = ' '; // prevent collapse all the way back to 0
				empty = true;
			}
			var scrollHeight = textarea.scrollHeight;
			if(!scrollHeight){
				this._estimateHeight(textarea);
			}else{
				var oldPadding = textarea.style.paddingBottom;
				var newPadding = dojo._getPadExtents(textarea);
				newPadding = newPadding.h - newPadding.t;
				textarea.style.paddingBottom = newPadding + 1 + "px"; // tweak padding to see if height can be reduced
				var newH = this._getHeight(textarea) - 1 + "px"; // see if the height changed by the 1px added
				if(textarea.style.maxHeight != newH){ // if can be reduced, so now try a big chunk
					textarea.style.paddingBottom = newPadding + scrollHeight + "px";
					textarea.scrollTop = 0;
					textarea.style.maxHeight = this._getHeight(textarea) - scrollHeight + "px"; // scrollHeight is the added padding
				}
				textarea.style.paddingBottom = oldPadding;
			}
			if(empty){
				textarea.value = '';
			}
			this._busyResizing = false;
		}
	},

	resize: function(){
		// summary:
		//		Resizes the textarea vertically (should be called after a style/value change)
		this._onInput();
	},

	_setValueAttr: function(){
		this.inherited(arguments);
		this.resize();
	},

	postCreate: function(){
		this.inherited(arguments);
		// tweak textarea style to reduce browser differences
		dojo.style(this.textbox, { overflowY: 'hidden', overflowX: 'auto', boxSizing: 'border-box', MsBoxSizing: 'border-box', WebkitBoxSizing: 'border-box', MozBoxSizing: 'border-box' });
		this.connect(this.textbox, "onscroll", this._onInput);
		this.connect(this.textbox, "onresize", this._onInput);
		this.connect(this.textbox, "onfocus", this._onInput); // useful when a previous estimate was off a bit
		setTimeout(dojo.hitch(this, "resize"), 0);
	}
});

}

if(!dojo._hasResource["dojo.data.ItemFileReadStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.ItemFileReadStore"] = true;
dojo.provide("dojo.data.ItemFileReadStore");





dojo.declare("dojo.data.ItemFileReadStore", null,{
	//	summary:
	//		The ItemFileReadStore implements the dojo.data.api.Read API and reads
	//		data from JSON files that have contents in this format --
	//		{ items: [
	//			{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},
	//			{ name:'Fozzie Bear', wears:['hat', 'tie']},
	//			{ name:'Miss Piggy', pets:'Foo-Foo'}
	//		]}
	//		Note that it can also contain an 'identifer' property that specified which attribute on the items 
	//		in the array of items that acts as the unique identifier for that item.
	//
	constructor: function(/* Object */ keywordParameters){
		//	summary: constructor
		//	keywordParameters: {url: String}
		//	keywordParameters: {data: jsonObject}
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the 
		//		value of _value as the initialization parameters.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//		}
	
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = [];
		this._loadFinished = false;
		this._jsonFileUrl = keywordParameters.url;
		this._ccUrl = keywordParameters.url;
		this.url = keywordParameters.url;
		this._jsonData = keywordParameters.data;
		this.data = null;
		this._datatypeMap = keywordParameters.typeMap || {};
		if(!this._datatypeMap['Date']){
			//If no default mapping for dates, then set this as default.
			//We use the dojo.date.stamp here because the ISO format is the 'dojo way'
			//of generically representing dates.
			this._datatypeMap['Date'] = {
											type: Date,
											deserialize: function(value){
												return dojo.date.stamp.fromISOString(value);
											}
										};
		}
		this._features = {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true};
		this._itemsByIdentity = null;
		this._storeRefPropName = "_S"; // Default name for the store reference to attach to every item.
		this._itemNumPropName = "_0"; // Default Item Id for isItem to attach to every item.
		this._rootItemPropName = "_RI"; // Default Item Id for isItem to attach to every item.
		this._reverseRefMap = "_RRM"; // Default attribute for constructing a reverse reference map for use with reference integrity
		this._loadInProgress = false; //Got to track the initial load to prevent duelling loads of the dataset.
		this._queuedFetches = [];
		if(keywordParameters.urlPreventCache !== undefined){
			this.urlPreventCache = keywordParameters.urlPreventCache?true:false;
		}
		if(keywordParameters.hierarchical !== undefined){
			this.hierarchical = keywordParameters.hierarchical?true:false;
		}
		if(keywordParameters.clearOnClose){
			this.clearOnClose = true;
		}
		if("failOk" in keywordParameters){
			this.failOk = keywordParameters.failOk?true:false;
		}
	},
	
	url: "",	// use "" rather than undefined for the benefit of the parser (#3539)

	//Internal var, crossCheckUrl.  Used so that setting either url or _jsonFileUrl, can still trigger a reload
	//when clearOnClose and close is used.
	_ccUrl: "",

	data: null,	// define this so that the parser can populate it

	typeMap: null, //Define so parser can populate.
	
	//Parameter to allow users to specify if a close call should force a reload or not.
	//By default, it retains the old behavior of not clearing if close is called.  But
	//if set true, the store will be reset to default state.  Note that by doing this,
	//all item handles will become invalid and a new fetch must be issued.
	clearOnClose: false,

	//Parameter to allow specifying if preventCache should be passed to the xhrGet call or not when loading data from a url.  
	//Note this does not mean the store calls the server on each fetch, only that the data load has preventCache set as an option.
	//Added for tracker: #6072
	urlPreventCache: false,
	
	//Parameter for specifying that it is OK for the xhrGet call to fail silently.
	failOk: false,

	//Parameter to indicate to process data from the url as hierarchical 
	//(data items can contain other data items in js form).  Default is true 
	//for backwards compatibility.  False means only root items are processed 
	//as items, all child objects outside of type-mapped objects and those in 
	//specific reference format, are left straight JS data objects.
	hierarchical: true,

	_assertIsItem: function(/* item */ item){
		//	summary:
		//		This function tests whether the item passed in is indeed an item in the store.
		//	item: 
		//		The item to test for being contained by the store.
		if(!this.isItem(item)){ 
			throw new Error("dojo.data.ItemFileReadStore: Invalid item argument.");
		}
	},

	_assertIsAttribute: function(/* attribute-name-string */ attribute){
		//	summary:
		//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
		//	attribute: 
		//		The attribute to test for being contained by the store.
		if(typeof attribute !== "string"){ 
			throw new Error("dojo.data.ItemFileReadStore: Invalid attribute argument.");
		}
	},

	getValue: function(	/* item */ item, 
						/* attribute-name-string */ attribute, 
						/* value? */ defaultValue){
		//	summary: 
		//		See dojo.data.api.Read.getValue()
		var values = this.getValues(item, attribute);
		return (values.length > 0)?values[0]:defaultValue; // mixed
	},

	getValues: function(/* item */ item, 
						/* attribute-name-string */ attribute){
		//	summary: 
		//		See dojo.data.api.Read.getValues()

		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return item[attribute] || []; // Array
	},

	getAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getAttributes()
		this._assertIsItem(item);
		var attributes = [];
		for(var key in item){
			// Save off only the real item attributes, not the special id marks for O(1) isItem.
			if((key !== this._storeRefPropName) && (key !== this._itemNumPropName) && (key !== this._rootItemPropName) && (key !== this._reverseRefMap)){
				attributes.push(key);
			}
		}
		return attributes; // Array
	},

	hasAttribute: function(	/* item */ item,
							/* attribute-name-string */ attribute){
		//	summary: 
		//		See dojo.data.api.Read.hasAttribute()
		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return (attribute in item);
	},

	containsValue: function(/* item */ item, 
							/* attribute-name-string */ attribute, 
							/* anything */ value){
		//	summary: 
		//		See dojo.data.api.Read.containsValue()
		var regexp = undefined;
		if(typeof value === "string"){
			regexp = dojo.data.util.filter.patternToRegExp(value, false);
		}
		return this._containsValue(item, attribute, value, regexp); //boolean.
	},

	_containsValue: function(	/* item */ item, 
								/* attribute-name-string */ attribute, 
								/* anything */ value,
								/* RegExp?*/ regexp){
		//	summary: 
		//		Internal function for looking at the values contained by the item.
		//	description: 
		//		Internal function for looking at the values contained by the item.  This 
		//		function allows for denoting if the comparison should be case sensitive for
		//		strings or not (for handling filtering cases where string case should not matter)
		//	
		//	item:
		//		The data item to examine for attribute values.
		//	attribute:
		//		The attribute to inspect.
		//	value:	
		//		The value to match.
		//	regexp:
		//		Optional regular expression generated off value if value was of string type to handle wildcarding.
		//		If present and attribute values are string, then it can be used for comparison instead of 'value'
		return dojo.some(this.getValues(item, attribute), function(possibleValue){
			if(possibleValue !== null && !dojo.isObject(possibleValue) && regexp){
				if(possibleValue.toString().match(regexp)){
					return true; // Boolean
				}
			}else if(value === possibleValue){
				return true; // Boolean
			}
		});
	},

	isItem: function(/* anything */ something){
		//	summary: 
		//		See dojo.data.api.Read.isItem()
		if(something && something[this._storeRefPropName] === this){
			if(this._arrayOfAllItems[something[this._itemNumPropName]] === something){
				return true;
			}
		}
		return false; // Boolean
	},

	isItemLoaded: function(/* anything */ something){
		//	summary: 
		//		See dojo.data.api.Read.isItemLoaded()
		return this.isItem(something); //boolean
	},

	loadItem: function(/* object */ keywordArgs){
		//	summary: 
		//		See dojo.data.api.Read.loadItem()
		this._assertIsItem(keywordArgs.item);
	},

	getFeatures: function(){
		//	summary: 
		//		See dojo.data.api.Read.getFeatures()
		return this._features; //Object
	},

	getLabel: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getLabel()
		if(this._labelAttr && this.isItem(item)){
			return this.getValue(item,this._labelAttr); //String
		}
		return undefined; //undefined
	},

	getLabelAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getLabelAttributes()
		if(this._labelAttr){
			return [this._labelAttr]; //array
		}
		return null; //null
	},

	_fetchItems: function(	/* Object */ keywordArgs, 
							/* Function */ findCallback, 
							/* Function */ errorCallback){
		//	summary: 
		//		See dojo.data.util.simpleFetch.fetch()
		var self = this;
		var filter = function(requestArgs, arrayOfItems){
			var items = [];
			var i, key;
			if(requestArgs.query){
				var value;
				var ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false; 

				//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the
				//same value for each item examined.  Much more efficient.
				var regexpList = {};
				for(key in requestArgs.query){
					value = requestArgs.query[key];
					if(typeof value === "string"){
						regexpList[key] = dojo.data.util.filter.patternToRegExp(value, ignoreCase);
					}else if(value instanceof RegExp){
						regexpList[key] = value;
					}
				}
				for(i = 0; i < arrayOfItems.length; ++i){
					var match = true;
					var candidateItem = arrayOfItems[i];
					if(candidateItem === null){
						match = false;
					}else{
						for(key in requestArgs.query){
							value = requestArgs.query[key];
							if(!self._containsValue(candidateItem, key, value, regexpList[key])){
								match = false;
							}
						}
					}
					if(match){
						items.push(candidateItem);
					}
				}
				findCallback(items, requestArgs);
			}else{
				// We want a copy to pass back in case the parent wishes to sort the array. 
				// We shouldn't allow resort of the internal list, so that multiple callers 
				// can get lists and sort without affecting each other.  We also need to
				// filter out any null values that have been left as a result of deleteItem()
				// calls in ItemFileWriteStore.
				for(i = 0; i < arrayOfItems.length; ++i){
					var item = arrayOfItems[i];
					if(item !== null){
						items.push(item);
					}
				}
				findCallback(items, requestArgs);
			}
		};

		if(this._loadFinished){
			filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
		}else{
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards 
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				dojo.deprecated("dojo.data.ItemFileReadStore: ", 
					"To change the url, set the url property of the store," +
					" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}

			//See if there was any forced reset of data.
			if(this.data != null && this._jsonData == null){
				this._jsonData = this.data;
				this.data = null;
			}

			if(this._jsonFileUrl){
				//If fetches come in before the loading has finished, but while
				//a load is in progress, we have to defer the fetching to be 
				//invoked in the callback.
				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs, filter: filter});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl, 
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache,
							failOk: this.failOk
						};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							
							filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions));
							self._handleQueuedFetches();
						}catch(e){
							self._loadFinished = true;
							self._loadInProgress = false;
							errorCallback(e, keywordArgs);
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						errorCallback(error, keywordArgs);
					});

					//Wire up the cancel to abort of the request
					//This call cancel on the deferred if it hasn't been called
					//yet and then will chain to the simple abort of the
					//simpleFetch keywordArgs
					var oldAbort = null;
					if(keywordArgs.abort){
						oldAbort = keywordArgs.abort;
					}
					keywordArgs.abort = function(){
						var df = getHandler;
						if(df && df.fired === -1){
							df.cancel();
							df = null;
						}
						if(oldAbort){
							oldAbort.call(keywordArgs);
						}
					};
				}
			}else if(this._jsonData){
				try{
					this._loadFinished = true;
					this._getItemsFromLoadedData(this._jsonData);
					this._jsonData = null;
					filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
				}catch(e){
					errorCallback(e, keywordArgs);
				}
			}else{
				errorCallback(new Error("dojo.data.ItemFileReadStore: No JSON source data was provided as either URL or a nested Javascript object."), keywordArgs);
			}
		}
	},

	_handleQueuedFetches: function(){
		//	summary: 
		//		Internal function to execute delayed request in the store.
		//Execute any deferred fetches now.
		if(this._queuedFetches.length > 0){
			for(var i = 0; i < this._queuedFetches.length; i++){
				var fData = this._queuedFetches[i];
				var delayedQuery = fData.args;
				var delayedFilter = fData.filter;
				if(delayedFilter){
					delayedFilter(delayedQuery, this._getItemsArray(delayedQuery.queryOptions)); 
				}else{
					this.fetchItemByIdentity(delayedQuery);
				}
			}
			this._queuedFetches = [];
		}
	},

	_getItemsArray: function(/*object?*/queryOptions){
		//	summary: 
		//		Internal function to determine which list of items to search over.
		//	queryOptions: The query options parameter, if any.
		if(queryOptions && queryOptions.deep){
			return this._arrayOfAllItems; 
		}
		return this._arrayOfTopLevelItems;
	},

	close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
		 //	summary: 
		 //		See dojo.data.api.Read.close()
		 if(this.clearOnClose && 
			this._loadFinished && 
			!this._loadInProgress){
			 //Reset all internalsback to default state.  This will force a reload
			 //on next fetch.  This also checks that the data or url param was set 
			 //so that the store knows it can get data.  Without one of those being set,
			 //the next fetch will trigger an error.

			 if(((this._jsonFileUrl == "" || this._jsonFileUrl == null) && 
				 (this.url == "" || this.url == null)
				) && this.data == null){
				 console.debug("dojo.data.ItemFileReadStore: WARNING!  Data reload " +
					" information has not been provided." + 
					"  Please set 'url' or 'data' to the appropriate value before" +
					" the next fetch");
			 }
			 this._arrayOfAllItems = [];
			 this._arrayOfTopLevelItems = [];
			 this._loadFinished = false;
			 this._itemsByIdentity = null;
			 this._loadInProgress = false;
			 this._queuedFetches = [];
		 }
	},

	_getItemsFromLoadedData: function(/* Object */ dataObject){
		//	summary:
		//		Function to parse the loaded data into item format and build the internal items array.
		//	description:
		//		Function to parse the loaded data into item format and build the internal items array.
		//
		//	dataObject:
		//		The JS data object containing the raw data to convery into item format.
		//
		// 	returns: array
		//		Array of items in store item format.
		
		// First, we define a couple little utility functions...
		var addingArrays = false;
		var self = this;
		
		function valueIsAnItem(/* anything */ aValue){
			// summary:
			//		Given any sort of value that could be in the raw json data,
			//		return true if we should interpret the value as being an
			//		item itself, rather than a literal value or a reference.
			// example:
			// 	|	false == valueIsAnItem("Kermit");
			// 	|	false == valueIsAnItem(42);
			// 	|	false == valueIsAnItem(new Date());
			// 	|	false == valueIsAnItem({_type:'Date', _value:'May 14, 1802'});
			// 	|	false == valueIsAnItem({_reference:'Kermit'});
			// 	|	true == valueIsAnItem({name:'Kermit', color:'green'});
			// 	|	true == valueIsAnItem({iggy:'pop'});
			// 	|	true == valueIsAnItem({foo:42});
			var isItem = (
				(aValue !== null) &&
				(typeof aValue === "object") &&
				(!dojo.isArray(aValue) || addingArrays) &&
				(!dojo.isFunction(aValue)) &&
				(aValue.constructor == Object || dojo.isArray(aValue)) &&
				(typeof aValue._reference === "undefined") && 
				(typeof aValue._type === "undefined") && 
				(typeof aValue._value === "undefined") &&
				self.hierarchical
			);
			return isItem;
		}
		
		function addItemAndSubItemsToArrayOfAllItems(/* Item */ anItem){
			self._arrayOfAllItems.push(anItem);
			for(var attribute in anItem){
				var valueForAttribute = anItem[attribute];
				if(valueForAttribute){
					if(dojo.isArray(valueForAttribute)){
						var valueArray = valueForAttribute;
						for(var k = 0; k < valueArray.length; ++k){
							var singleValue = valueArray[k];
							if(valueIsAnItem(singleValue)){
								addItemAndSubItemsToArrayOfAllItems(singleValue);
							}
						}
					}else{
						if(valueIsAnItem(valueForAttribute)){
							addItemAndSubItemsToArrayOfAllItems(valueForAttribute);
						}
					}
				}
			}
		}

		this._labelAttr = dataObject.label;

		// We need to do some transformations to convert the data structure
		// that we read from the file into a format that will be convenient
		// to work with in memory.

		// Step 1: Walk through the object hierarchy and build a list of all items
		var i;
		var item;
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = dataObject.items;

		for(i = 0; i < this._arrayOfTopLevelItems.length; ++i){
			item = this._arrayOfTopLevelItems[i];
			if(dojo.isArray(item)){
				addingArrays = true;
			}
			addItemAndSubItemsToArrayOfAllItems(item);
			item[this._rootItemPropName]=true;
		}

		// Step 2: Walk through all the attribute values of all the items, 
		// and replace single values with arrays.  For example, we change this:
		//		{ name:'Miss Piggy', pets:'Foo-Foo'}
		// into this:
		//		{ name:['Miss Piggy'], pets:['Foo-Foo']}
		// 
		// We also store the attribute names so we can validate our store  
		// reference and item id special properties for the O(1) isItem
		var allAttributeNames = {};
		var key;

		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			for(key in item){
				if(key !== this._rootItemPropName){
					var value = item[key];
					if(value !== null){
						if(!dojo.isArray(value)){
							item[key] = [value];
						}
					}else{
						item[key] = [null];
					}
				}
				allAttributeNames[key]=key;
			}
		}

		// Step 3: Build unique property names to use for the _storeRefPropName and _itemNumPropName
		// This should go really fast, it will generally never even run the loop.
		while(allAttributeNames[this._storeRefPropName]){
			this._storeRefPropName += "_";
		}
		while(allAttributeNames[this._itemNumPropName]){
			this._itemNumPropName += "_";
		}
		while(allAttributeNames[this._reverseRefMap]){
			this._reverseRefMap += "_";
		}

		// Step 4: Some data files specify an optional 'identifier', which is 
		// the name of an attribute that holds the identity of each item. 
		// If this data file specified an identifier attribute, then build a 
		// hash table of items keyed by the identity of the items.
		var arrayOfValues;

		var identifier = dataObject.identifier;
		if(identifier){
			this._itemsByIdentity = {};
			this._features['dojo.data.api.Identity'] = identifier;
			for(i = 0; i < this._arrayOfAllItems.length; ++i){
				item = this._arrayOfAllItems[i];
				arrayOfValues = item[identifier];
				var identity = arrayOfValues[0];
				if(!this._itemsByIdentity[identity]){
					this._itemsByIdentity[identity] = item;
				}else{
					if(this._jsonFileUrl){
						throw new Error("dojo.data.ItemFileReadStore:  The json data as specified by: [" + this._jsonFileUrl + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}else if(this._jsonData){
						throw new Error("dojo.data.ItemFileReadStore:  The json data provided by the creation arguments is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}
				}
			}
		}else{
			this._features['dojo.data.api.Identity'] = Number;
		}

		// Step 5: Walk through all the items, and set each item's properties 
		// for _storeRefPropName and _itemNumPropName, so that store.isItem() will return true.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			item[this._storeRefPropName] = this;
			item[this._itemNumPropName] = i;
		}

		// Step 6: We walk through all the attribute values of all the items,
		// looking for type/value literals and item-references.
		//
		// We replace item-references with pointers to items.  For example, we change:
		//		{ name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
		// into this:
		//		{ name:['Kermit'], friends:[miss_piggy] } 
		// (where miss_piggy is the object representing the 'Miss Piggy' item).
		//
		// We replace type/value pairs with typed-literals.  For example, we change:
		//		{ name:['Nelson Mandela'], born:[{_type:'Date', _value:'July 18, 1918'}] }
		// into this:
		//		{ name:['Kermit'], born:(new Date('July 18, 1918')) } 
		//
		// We also generate the associate map for all items for the O(1) isItem function.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i]; // example: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
			for(key in item){
				arrayOfValues = item[key]; // example: [{_reference:{name:'Miss Piggy'}}]
				for(var j = 0; j < arrayOfValues.length; ++j){
					value = arrayOfValues[j]; // example: {_reference:{name:'Miss Piggy'}}
					if(value !== null && typeof value == "object"){
						if(("_type" in value) && ("_value" in value)){
							var type = value._type; // examples: 'Date', 'Color', or 'ComplexNumber'
							var mappingObj = this._datatypeMap[type]; // examples: Date, dojo.Color, foo.math.ComplexNumber, {type: dojo.Color, deserialize(value){ return new dojo.Color(value)}}
							if(!mappingObj){ 
								throw new Error("dojo.data.ItemFileReadStore: in the typeMap constructor arg, no object class was specified for the datatype '" + type + "'");
							}else if(dojo.isFunction(mappingObj)){
								arrayOfValues[j] = new mappingObj(value._value);
							}else if(dojo.isFunction(mappingObj.deserialize)){
								arrayOfValues[j] = mappingObj.deserialize(value._value);
							}else{
								throw new Error("dojo.data.ItemFileReadStore: Value provided in typeMap was neither a constructor, nor a an object with a deserialize function");
							}
						}
						if(value._reference){
							var referenceDescription = value._reference; // example: {name:'Miss Piggy'}
							if(!dojo.isObject(referenceDescription)){
								// example: 'Miss Piggy'
								// from an item like: { name:['Kermit'], friends:[{_reference:'Miss Piggy'}]}
								arrayOfValues[j] = this._itemsByIdentity[referenceDescription];
							}else{
								// example: {name:'Miss Piggy'}
								// from an item like: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
								for(var k = 0; k < this._arrayOfAllItems.length; ++k){
									var candidateItem = this._arrayOfAllItems[k];
									var found = true;
									for(var refKey in referenceDescription){
										if(candidateItem[refKey] != referenceDescription[refKey]){ 
											found = false; 
										}
									}
									if(found){ 
										arrayOfValues[j] = candidateItem; 
									}
								}
							}
							if(this.referenceIntegrity){
								var refItem = arrayOfValues[j];
								if(this.isItem(refItem)){
									this._addReferenceToMap(refItem, item, key);
								}
							}
						}else if(this.isItem(value)){
							//It's a child item (not one referenced through _reference).  
							//We need to treat this as a referenced item, so it can be cleaned up
							//in a write store easily.
							if(this.referenceIntegrity){
								this._addReferenceToMap(value, item, key);
							}
						}
					}
				}
			}
		}
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		 //	summary:
		 //		Method to add an reference map entry for an item and attribute.
		 //	description:
		 //		Method to add an reference map entry for an item and attribute. 		 //
		 //	refItem:
		 //		The item that is referenced.
		 //	parentItem:
		 //		The item that holds the new reference to refItem.
		 //	attribute:
		 //		The attribute on parentItem that contains the new reference.
		 
		 //Stub function, does nothing.  Real processing is in ItemFileWriteStore.
	},

	getIdentity: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Identity.getIdentity()
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			return item[this._itemNumPropName]; // Number
		}else{
			var arrayOfValues = item[identifier];
			if(arrayOfValues){
				return arrayOfValues[0]; // Object || String
			}
		}
		return null; // null
	},

	fetchItemByIdentity: function(/* Object */ keywordArgs){
		//	summary: 
		//		See dojo.data.api.Identity.fetchItemByIdentity()

		// Hasn't loaded yet, we have to trigger the load.
		var item;
		var scope;
		if(!this._loadFinished){
			var self = this;
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards 
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				dojo.deprecated("dojo.data.ItemFileReadStore: ", 
					"To change the url, set the url property of the store," +
					" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}
			
			//See if there was any forced reset of data.
			if(this.data != null && this._jsonData == null){
				this._jsonData = this.data;
				this.data = null;
			}

			if(this._jsonFileUrl){

				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl, 
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache,
							failOk: this.failOk
					};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							item = self._getItemByIdentity(keywordArgs.identity);
							if(keywordArgs.onItem){
								keywordArgs.onItem.call(scope, item);
							}
							self._handleQueuedFetches();
						}catch(error){
							self._loadInProgress = false;
							if(keywordArgs.onError){
								keywordArgs.onError.call(scope, error);
							}
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						if(keywordArgs.onError){
							var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
							keywordArgs.onError.call(scope, error);
						}
					});
				}

			}else if(this._jsonData){
				// Passed in data, no need to xhr.
				self._getItemsFromLoadedData(self._jsonData);
				self._jsonData = null;
				self._loadFinished = true;
				item = self._getItemByIdentity(keywordArgs.identity);
				if(keywordArgs.onItem){
					scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
					keywordArgs.onItem.call(scope, item);
				}
			} 
		}else{
			// Already loaded.  We can just look it up and call back.
			item = this._getItemByIdentity(keywordArgs.identity);
			if(keywordArgs.onItem){
				scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
				keywordArgs.onItem.call(scope, item);
			}
		}
	},

	_getItemByIdentity: function(/* Object */ identity){
		//	summary:
		//		Internal function to look an item up by its identity map.
		var item = null;
		if(this._itemsByIdentity){
			item = this._itemsByIdentity[identity];
		}else{
			item = this._arrayOfAllItems[identity];
		}
		if(item === undefined){
			item = null;
		}
		return item; // Object
	},

	getIdentityAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Identity.getIdentifierAttributes()
		 
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			// If (identifier === Number) it means getIdentity() just returns
			// an integer item-number for each item.  The dojo.data.api.Identity
			// spec says we need to return null if the identity is not composed 
			// of attributes 
			return null; // null
		}else{
			return [identifier]; // Array
		}
	},
	
	_forceLoad: function(){
		//	summary: 
		//		Internal function to force a load of the store if it hasn't occurred yet.  This is required
		//		for specific functions to work properly.  
		var self = this;
		//Do a check on the JsonFileUrl and crosscheck it.
		//If it doesn't match the cross-check, it needs to be updated
		//This allows for either url or _jsonFileUrl to he changed to
		//reset the store load location.  Done this way for backwards 
		//compatibility.  People use _jsonFileUrl (even though officially
		//private.
		if(this._jsonFileUrl !== this._ccUrl){
			dojo.deprecated("dojo.data.ItemFileReadStore: ", 
				"To change the url, set the url property of the store," +
				" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
			this._ccUrl = this._jsonFileUrl;
			this.url = this._jsonFileUrl;
		}else if(this.url !== this._ccUrl){
			this._jsonFileUrl = this.url;
			this._ccUrl = this.url;
		}

		//See if there was any forced reset of data.
		if(this.data != null && this._jsonData == null){
			this._jsonData = this.data;
			this.data = null;
		}

		if(this._jsonFileUrl){
				var getArgs = {
					url: this._jsonFileUrl, 
					handleAs: "json-comment-optional",
					preventCache: this.urlPreventCache,
					failOk: this.failOk,
					sync: true
				};
			var getHandler = dojo.xhrGet(getArgs);
			getHandler.addCallback(function(data){
				try{
					//Check to be sure there wasn't another load going on concurrently 
					//So we don't clobber data that comes in on it.  If there is a load going on
					//then do not save this data.  It will potentially clobber current data.
					//We mainly wanted to sync/wait here.
					//TODO:  Revisit the loading scheme of this store to improve multi-initial
					//request handling.
					if(self._loadInProgress !== true && !self._loadFinished){
						self._getItemsFromLoadedData(data);
						self._loadFinished = true;
					}else if(self._loadInProgress){
						//Okay, we hit an error state we can't recover from.  A forced load occurred
						//while an async load was occurring.  Since we cannot block at this point, the best
						//that can be managed is to throw an error.
						throw new Error("dojo.data.ItemFileReadStore:  Unable to perform a synchronous load, an async load is in progress."); 
					}
				}catch(e){
					console.log(e);
					throw e;
				}
			});
			getHandler.addErrback(function(error){
				throw error;
			});
		}else if(this._jsonData){
			self._getItemsFromLoadedData(self._jsonData);
			self._jsonData = null;
			self._loadFinished = true;
		} 
	}
});
//Mix in the simple fetch implementation to this class.
dojo.extend(dojo.data.ItemFileReadStore,dojo.data.util.simpleFetch);

}

if(!dojo._hasResource["dojo.number"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.number"] = true;
dojo.provide("dojo.number");







/*=====
dojo.number = {
	// summary: localized formatting and parsing routines for Number
}

dojo.number.__FormatOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	places: Number?
	//		fixed number of decimal places to show.  This overrides any
	//		information in the provided pattern.
	//	round: Number?
	//		5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	//		means do not round.
	//	locale: String?
	//		override the locale used to determine formatting rules
	this.pattern = pattern;
	this.type = type;
	this.places = places;
	this.round = round;
	this.locale = locale;
}
=====*/

dojo.number.format = function(/*Number*/value, /*dojo.number.__FormatOptions?*/options){
	// summary:
	//		Format a Number as a String, using locale-specific settings
	// description:
	//		Create a string from a Number using a known localized pattern.
	//		Formatting patterns appropriate to the locale are chosen from the
	//		[CLDR](http://unicode.org/cldr) as well as the appropriate symbols and
	//		delimiters.  See <http://www.unicode.org/reports/tr35/#Number_Elements>
	//		If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.
	// value:
	//		the number to be formatted

	options = dojo.mixin({}, options || {});
	var locale = dojo.i18n.normalizeLocale(options.locale);
	var bundle = dojo.i18n.getLocalization("dojo.cldr", "number", locale);
	options.customs = bundle;
	var pattern = options.pattern || bundle[(options.type || "decimal") + "Format"];
	if(isNaN(value) || Math.abs(value) == Infinity){ return null; } // null
	return dojo.number._applyPattern(value, pattern, options); // String
};

//dojo.number._numberPatternRE = /(?:[#0]*,?)*[#0](?:\.0*#*)?/; // not precise, but good enough
dojo.number._numberPatternRE = /[#0,]*[#0](?:\.0*#*)?/; // not precise, but good enough

dojo.number._applyPattern = function(/*Number*/value, /*String*/pattern, /*dojo.number.__FormatOptions?*/options){
	// summary:
	//		Apply pattern to format value as a string using options. Gives no
	//		consideration to local customs.
	// value:
	//		the number to be formatted.
	// pattern:
	//		a pattern string as described by
	//		[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	// options: dojo.number.__FormatOptions?
	//		_applyPattern is usually called via `dojo.number.format()` which
	//		populates an extra property in the options parameter, "customs".
	//		The customs object specifies group and decimal parameters if set.

	//TODO: support escapes
	options = options || {};
	var group = options.customs.group;
	var decimal = options.customs.decimal;

	var patternList = pattern.split(';');
	var positivePattern = patternList[0];
	pattern = patternList[(value < 0) ? 1 : 0] || ("-" + positivePattern);

	//TODO: only test against unescaped
	if(pattern.indexOf('%') != -1){
		value *= 100;
	}else if(pattern.indexOf('\u2030') != -1){
		value *= 1000; // per mille
	}else if(pattern.indexOf('\u00a4') != -1){
		group = options.customs.currencyGroup || group;//mixins instead?
		decimal = options.customs.currencyDecimal || decimal;// Should these be mixins instead?
		pattern = pattern.replace(/\u00a4{1,3}/, function(match){
			var prop = ["symbol", "currency", "displayName"][match.length-1];
			return options[prop] || options.currency || "";
		});
	}else if(pattern.indexOf('E') != -1){
		throw new Error("exponential notation not supported");
	}
	
	//TODO: support @ sig figs?
	var numberPatternRE = dojo.number._numberPatternRE;
	var numberPattern = positivePattern.match(numberPatternRE);
	if(!numberPattern){
		throw new Error("unable to find a number expression in pattern: "+pattern);
	}
	if(options.fractional === false){ options.places = 0; }
	return pattern.replace(numberPatternRE,
		dojo.number._formatAbsolute(value, numberPattern[0], {decimal: decimal, group: group, places: options.places, round: options.round}));
}

dojo.number.round = function(/*Number*/value, /*Number?*/places, /*Number?*/increment){
	//	summary:
	//		Rounds to the nearest value with the given number of decimal places, away from zero
	//	description:
	//		Rounds to the nearest value with the given number of decimal places, away from zero if equal.
	//		Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
	//		fractional increments also, such as the nearest quarter.
	//		NOTE: Subject to floating point errors.  See dojox.math.round for experimental workaround.
	//	value:
	//		The number to round
	//	places:
	//		The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.
	//		Must be non-negative.
	//	increment:
	//		Rounds next place to nearest value of increment/10.  10 by default.
	//	example:
	//		>>> dojo.number.round(-0.5)
	//		-1
	//		>>> dojo.number.round(162.295, 2)
	//		162.29  // note floating point error.  Should be 162.3
	//		>>> dojo.number.round(10.71, 0, 2.5)
	//		10.75
	var factor = 10 / (increment || 10);
	return (factor * +value).toFixed(places) / factor; // Number
}

if((0.9).toFixed() == 0){
	// (isIE) toFixed() bug workaround: Rounding fails on IE when most significant digit
	// is just after the rounding place and is >=5
	(function(){
		var round = dojo.number.round;
		dojo.number.round = function(v, p, m){
			var d = Math.pow(10, -p || 0), a = Math.abs(v);
			if(!v || a >= d || a * Math.pow(10, p + 1) < 5){
				d = 0;
			}
			return round(v, p, m) + (v > 0 ? d : -d);
		}
	})();
}

/*=====
dojo.number.__FormatAbsoluteOptions = function(){
	//	decimal: String?
	//		the decimal separator
	//	group: String?
	//		the group separator
	//	places: Number?|String?
	//		number of decimal places.  the range "n,m" will format to m places.
	//	round: Number?
	//		5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	//		means don't round.
	this.decimal = decimal;
	this.group = group;
	this.places = places;
	this.round = round;
}
=====*/

dojo.number._formatAbsolute = function(/*Number*/value, /*String*/pattern, /*dojo.number.__FormatAbsoluteOptions?*/options){
	// summary: 
	//		Apply numeric pattern to absolute value using options. Gives no
	//		consideration to local customs.
	// value:
	//		the number to be formatted, ignores sign
	// pattern:
	//		the number portion of a pattern (e.g. `#,##0.00`)
	options = options || {};
	if(options.places === true){options.places=0;}
	if(options.places === Infinity){options.places=6;} // avoid a loop; pick a limit

	var patternParts = pattern.split(".");
	var maxPlaces = (options.places >= 0) ? options.places : (patternParts[1] && patternParts[1].length) || 0;
	if(!(options.round < 0)){
		value = dojo.number.round(value, maxPlaces, options.round);
	}

	var valueParts = String(Math.abs(value)).split(".");
	var fractional = valueParts[1] || "";
	if(options.places){
		var comma = dojo.isString(options.places) && options.places.indexOf(",");
		if(comma){
			options.places = options.places.substring(comma+1);
		}
		valueParts[1] = dojo.string.pad(fractional.substr(0, options.places), options.places, '0', true);
	}else if(patternParts[1] && options.places !== 0){
		// Pad fractional with trailing zeros
		var pad = patternParts[1].lastIndexOf("0") + 1;
		if(pad > fractional.length){
			valueParts[1] = dojo.string.pad(fractional, pad, '0', true);
		}

		// Truncate fractional
		var places = patternParts[1].length;
		if(places < fractional.length){
			valueParts[1] = fractional.substr(0, places);
		}
	}else{
		if(valueParts[1]){ valueParts.pop(); }
	}

	// Pad whole with leading zeros
	var patternDigits = patternParts[0].replace(',', '');
	pad = patternDigits.indexOf("0");
	if(pad != -1){
		pad = patternDigits.length - pad;
		if(pad > valueParts[0].length){
			valueParts[0] = dojo.string.pad(valueParts[0], pad);
		}

		// Truncate whole
		if(patternDigits.indexOf("#") == -1){
			valueParts[0] = valueParts[0].substr(valueParts[0].length - pad);
		}
	}

	// Add group separators
	var index = patternParts[0].lastIndexOf(',');
	var groupSize, groupSize2;
	if(index != -1){
		groupSize = patternParts[0].length - index - 1;
		var remainder = patternParts[0].substr(0, index);
		index = remainder.lastIndexOf(',');
		if(index != -1){
			groupSize2 = remainder.length - index - 1;
		}
	}
	var pieces = [];
	for(var whole = valueParts[0]; whole;){
		var off = whole.length - groupSize;
		pieces.push((off > 0) ? whole.substr(off) : whole);
		whole = (off > 0) ? whole.slice(0, off) : "";
		if(groupSize2){
			groupSize = groupSize2;
			delete groupSize2;
		}
	}
	valueParts[0] = pieces.reverse().join(options.group || ",");

	return valueParts.join(options.decimal || ".");
};

/*=====
dojo.number.__RegexpOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	locale: String?
	//		override the locale used to determine formatting rules
	//	strict: Boolean?
	//		strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	//		Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
	//	places: Number|String?
	//		number of decimal places to accept: Infinity, a positive number, or
	//		a range "n,m".  Defined by pattern or Infinity if pattern not provided.
	this.pattern = pattern;
	this.type = type;
	this.locale = locale;
	this.strict = strict;
	this.places = places;
}
=====*/
dojo.number.regexp = function(/*dojo.number.__RegexpOptions?*/options){
	//	summary:
	//		Builds the regular needed to parse a number
	//	description:
	//		Returns regular expression with positive and negative match, group
	//		and decimal separators
	return dojo.number._parseInfo(options).regexp; // String
}

dojo.number._parseInfo = function(/*Object?*/options){
	options = options || {};
	var locale = dojo.i18n.normalizeLocale(options.locale);
	var bundle = dojo.i18n.getLocalization("dojo.cldr", "number", locale);
	var pattern = options.pattern || bundle[(options.type || "decimal") + "Format"];
//TODO: memoize?
	var group = bundle.group;
	var decimal = bundle.decimal;
	var factor = 1;

	if(pattern.indexOf('%') != -1){
		factor /= 100;
	}else if(pattern.indexOf('\u2030') != -1){
		factor /= 1000; // per mille
	}else{
		var isCurrency = pattern.indexOf('\u00a4') != -1;
		if(isCurrency){
			group = bundle.currencyGroup || group;
			decimal = bundle.currencyDecimal || decimal;
		}
	}

	//TODO: handle quoted escapes
	var patternList = pattern.split(';');
	if(patternList.length == 1){
		patternList.push("-" + patternList[0]);
	}

	var re = dojo.regexp.buildGroupRE(patternList, function(pattern){
		pattern = "(?:"+dojo.regexp.escapeString(pattern, '.')+")";
		return pattern.replace(dojo.number._numberPatternRE, function(format){
			var flags = {
				signed: false,
				separator: options.strict ? group : [group,""],
				fractional: options.fractional,
				decimal: decimal,
				exponent: false};
			var parts = format.split('.');
			var places = options.places;
			if(parts.length == 1 || places === 0){flags.fractional = false;}
			else{
				if(places === undefined){ places = options.pattern ? parts[1].lastIndexOf('0')+1 : Infinity; }
				if(places && options.fractional == undefined){flags.fractional = true;} // required fractional, unless otherwise specified
				if(!options.places && (places < parts[1].length)){ places += "," + parts[1].length; }
				flags.places = places;
			}
			var groups = parts[0].split(',');
			if(groups.length>1){
				flags.groupSize = groups.pop().length;
				if(groups.length>1){
					flags.groupSize2 = groups.pop().length;
				}
			}
			return "("+dojo.number._realNumberRegexp(flags)+")";
		});
	}, true);

	if(isCurrency){
		// substitute the currency symbol for the placeholder in the pattern
		re = re.replace(/([\s\xa0]*)(\u00a4{1,3})([\s\xa0]*)/g, function(match, before, target, after){
			var prop = ["symbol", "currency", "displayName"][target.length-1];
			var symbol = dojo.regexp.escapeString(options[prop] || options.currency || "");
			before = before ? "[\\s\\xa0]" : "";
			after = after ? "[\\s\\xa0]" : "";
			if(!options.strict){
				if(before){before += "*";}
				if(after){after += "*";}
				return "(?:"+before+symbol+after+")?";
			}
			return before+symbol+after;
		});
	}

//TODO: substitute localized sign/percent/permille/etc.?

	// normalize whitespace and return
	return {regexp: re.replace(/[\xa0 ]/g, "[\\s\\xa0]"), group: group, decimal: decimal, factor: factor}; // Object
}

/*=====
dojo.number.__ParseOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	locale: String?
	//		override the locale used to determine formatting rules
	//	strict: Boolean?
	//		strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	//		Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
	this.pattern = pattern;
	this.type = type;
	this.locale = locale;
	this.strict = strict;
}
=====*/
dojo.number.parse = function(/*String*/expression, /*dojo.number.__ParseOptions?*/options){
	// summary:
	//		Convert a properly formatted string to a primitive Number, using
	//		locale-specific settings.
	// description:
	//		Create a Number from a string using a known localized pattern.
	//		Formatting patterns are chosen appropriate to the locale
	//		and follow the syntax described by
	//		[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	// expression:
	//		A string representation of a Number
	var info = dojo.number._parseInfo(options);
	var results = (new RegExp("^"+info.regexp+"$")).exec(expression);
	if(!results){
		return NaN; //NaN
	}
	var absoluteMatch = results[1]; // match for the positive expression
	if(!results[1]){
		if(!results[2]){
			return NaN; //NaN
		}
		// matched the negative pattern
		absoluteMatch =results[2];
		info.factor *= -1;
	}

	// Transform it to something Javascript can parse as a number.  Normalize
	// decimal point and strip out group separators or alternate forms of whitespace
	absoluteMatch = absoluteMatch.
		replace(new RegExp("["+info.group + "\\s\\xa0"+"]", "g"), "").
		replace(info.decimal, ".");
	// Adjust for negative sign, percent, etc. as necessary
	return absoluteMatch * info.factor; //Number
};

/*=====
dojo.number.__RealNumberRegexpFlags = function(){
	//	places: Number?
	//		The integer number of decimal places or a range given as "n,m".  If
	//		not given, the decimal part is optional and the number of places is
	//		unlimited.
	//	decimal: String?
	//		A string for the character used as the decimal point.  Default
	//		is ".".
	//	fractional: Boolean?|Array?
	//		Whether decimal places are used.  Can be true, false, or [true,
	//		false].  Default is [true, false] which means optional.
	//	exponent: Boolean?|Array?
	//		Express in exponential notation.  Can be true, false, or [true,
	//		false]. Default is [true, false], (i.e. will match if the
	//		exponential part is present are not).
	//	eSigned: Boolean?|Array?
	//		The leading plus-or-minus sign on the exponent.  Can be true,
	//		false, or [true, false].  Default is [true, false], (i.e. will
	//		match if it is signed or unsigned).  flags in regexp.integer can be
	//		applied.
	this.places = places;
	this.decimal = decimal;
	this.fractional = fractional;
	this.exponent = exponent;
	this.eSigned = eSigned;
}
=====*/

dojo.number._realNumberRegexp = function(/*dojo.number.__RealNumberRegexpFlags?*/flags){
	// summary:
	//		Builds a regular expression to match a real number in exponential
	//		notation

	// assign default values to missing paramters
	flags = flags || {};
	//TODO: use mixin instead?
	if(!("places" in flags)){ flags.places = Infinity; }
	if(typeof flags.decimal != "string"){ flags.decimal = "."; }
	if(!("fractional" in flags) || /^0/.test(flags.places)){ flags.fractional = [true, false]; }
	if(!("exponent" in flags)){ flags.exponent = [true, false]; }
	if(!("eSigned" in flags)){ flags.eSigned = [true, false]; }

	// integer RE
	var integerRE = dojo.number._integerRegexp(flags);

	// decimal RE
	var decimalRE = dojo.regexp.buildGroupRE(flags.fractional,
		function(q){
			var re = "";
			if(q && (flags.places!==0)){
				re = "\\" + flags.decimal;
				if(flags.places == Infinity){ 
					re = "(?:" + re + "\\d+)?"; 
				}else{
					re += "\\d{" + flags.places + "}"; 
				}
			}
			return re;
		},
		true
	);

	// exponent RE
	var exponentRE = dojo.regexp.buildGroupRE(flags.exponent,
		function(q){ 
			if(q){ return "([eE]" + dojo.number._integerRegexp({ signed: flags.eSigned}) + ")"; }
			return ""; 
		}
	);

	// real number RE
	var realRE = integerRE + decimalRE;
	// allow for decimals without integers, e.g. .25
	if(decimalRE){realRE = "(?:(?:"+ realRE + ")|(?:" + decimalRE + "))";}
	return realRE + exponentRE; // String
};

/*=====
dojo.number.__IntegerRegexpFlags = function(){
	//	signed: Boolean?
	//		The leading plus-or-minus sign. Can be true, false, or `[true,false]`.
	//		Default is `[true, false]`, (i.e. will match if it is signed
	//		or unsigned).
	//	separator: String?
	//		The character used as the thousands separator. Default is no
	//		separator. For more than one symbol use an array, e.g. `[",", ""]`,
	//		makes ',' optional.
	//	groupSize: Number?
	//		group size between separators
	//	groupSize2: Number?
	//		second grouping, where separators 2..n have a different interval than the first separator (for India)
	this.signed = signed;
	this.separator = separator;
	this.groupSize = groupSize;
	this.groupSize2 = groupSize2;
}
=====*/

dojo.number._integerRegexp = function(/*dojo.number.__IntegerRegexpFlags?*/flags){
	// summary: 
	//		Builds a regular expression that matches an integer

	// assign default values to missing paramters
	flags = flags || {};
	if(!("signed" in flags)){ flags.signed = [true, false]; }
	if(!("separator" in flags)){
		flags.separator = "";
	}else if(!("groupSize" in flags)){
		flags.groupSize = 3;
	}
	// build sign RE
	var signRE = dojo.regexp.buildGroupRE(flags.signed,
		function(q){ return q ? "[-+]" : ""; },
		true
	);

	// number RE
	var numberRE = dojo.regexp.buildGroupRE(flags.separator,
		function(sep){
			if(!sep){
				return "(?:\\d+)";
			}

			sep = dojo.regexp.escapeString(sep);
			if(sep == " "){ sep = "\\s"; }
			else if(sep == "\xa0"){ sep = "\\s\\xa0"; }

			var grp = flags.groupSize, grp2 = flags.groupSize2;
			//TODO: should we continue to enforce that numbers with separators begin with 1-9?  See #6933
			if(grp2){
				var grp2RE = "(?:0|[1-9]\\d{0," + (grp2-1) + "}(?:[" + sep + "]\\d{" + grp2 + "})*[" + sep + "]\\d{" + grp + "})";
				return ((grp-grp2) > 0) ? "(?:" + grp2RE + "|(?:0|[1-9]\\d{0," + (grp-1) + "}))" : grp2RE;
			}
			return "(?:0|[1-9]\\d{0," + (grp-1) + "}(?:[" + sep + "]\\d{" + grp + "})*)";
		},
		true
	);

	// integer RE
	return signRE + numberRE; // String
}

}

if(!dojo._hasResource["dojo.cldr.monetary"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cldr.monetary"] = true;
dojo.provide("dojo.cldr.monetary");

dojo.cldr.monetary.getData = function(/*String*/code){
// summary: A mapping of currency code to currency-specific formatting information. Returns a unique object with properties: places, round.
// code: an [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code

// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/currencyData/fractions

	var placesData = {
		ADP:0,BHD:3,BIF:0,BYR:0,CLF:0,CLP:0,DJF:0,ESP:0,GNF:0,
		IQD:3,ITL:0,JOD:3,JPY:0,KMF:0,KRW:0,KWD:3,LUF:0,LYD:3,
		MGA:0,MGF:0,OMR:3,PYG:0,RWF:0,TND:3,TRL:0,VUV:0,XAF:0,
		XOF:0,XPF:0
	};

	var roundingData = {CHF:5};

	var places = placesData[code], round = roundingData[code];
	if(typeof places == "undefined"){ places = 2; }
	if(typeof round == "undefined"){ round = 0; }

	return {places: places, round: round}; // Object
};

}

if(!dojo._hasResource["dojo.currency"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.currency"] = true;
dojo.provide("dojo.currency");






/*=====
dojo.currency = {
	// summary: localized formatting and parsing routines for currencies
}
=====*/

dojo.currency._mixInDefaults = function(options){
	options = options || {};
	options.type = "currency";

	// Get locale-depenent currency data, like the symbol
	var bundle = dojo.i18n.getLocalization("dojo.cldr", "currency", options.locale) || {};

	// Mixin locale-independent currency data, like # of places
	var iso = options.currency;
	var data = dojo.cldr.monetary.getData(iso);

	dojo.forEach(["displayName","symbol","group","decimal"], function(prop){
		data[prop] = bundle[iso+"_"+prop];
	});

	data.fractional = [true, false];

	// Mixin with provided options
	return dojo.mixin(data, options);
}

/*=====
dojo.declare("dojo.currency.__FormatOptions", [dojo.number.__FormatOptions], {
	//	type: String?
	//		Should not be set.  Value is assumed to be currency.
	//	currency: String?
	//		an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD".
	//		For use with dojo.currency only.
	//	symbol: String?
	//		localized currency symbol. The default will be looked up in table of supported currencies in `dojo.cldr`
	//		A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.
	//	places: Number?
	//		number of decimal places to show.  Default is defined based on which currency is used.
	type: "",
	symbol: "",
	places: "",
	fractional: ""
});
=====*/

dojo.currency.format = function(/*Number*/value, /*dojo.currency.__FormatOptions?*/options){
// summary:
//		Format a Number as a currency, using locale-specific settings
//
// description:
//		Create a string from a Number using a known, localized pattern.
//		[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Elements) appropriate to the locale are chosen from the [CLDR](http://unicode.org/cldr)
//		as well as the appropriate symbols and delimiters.
//
// value:
//		the number to be formatted.

	return dojo.number.format(value, dojo.currency._mixInDefaults(options));
}

dojo.currency.regexp = function(/*dojo.number.__RegexpOptions?*/options){
//
// summary:
//		Builds the regular needed to parse a currency value
//
// description:
//		Returns regular expression with positive and negative match, group and decimal separators
//		Note: the options.places default, the number of decimal places to accept, is defined by the currency type.
	return dojo.number.regexp(dojo.currency._mixInDefaults(options)); // String
}

/*=====
dojo.declare("dojo.currency.__ParseOptions", [dojo.number.__ParseOptions], {
	//	type: String?
	//		Should not be set.  Value is assumed to be currency.
	//	currency: String?
	//		an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD".
	//		For use with dojo.currency only.
	//	symbol: String?
	//		localized currency symbol. The default will be looked up in table of supported currencies in `dojo.cldr`
	//		A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.
	//	places: Number?
	//		number of decimal places to accept.  Default is defined based on which currency is used.
	//	fractional: Boolean?|Array?
	//		Whether to include the fractional portion, where the number of decimal places are implied by pattern
	//		or explicit 'places' parameter.  By default for currencies, it the fractional portion is optional.
	type: "",
	symbol: "",
	places: "",
	fractional: ""
});
=====*/

dojo.currency.parse = function(/*String*/expression, /*dojo.currency.__ParseOptions?*/options){
	//
	// summary:
	//		Convert a properly formatted currency string to a primitive Number,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Number from a string using a known, localized pattern.
	//		[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Format_Patterns) are chosen appropriate to the locale.
	//
	// expression: A string representation of a Number

	return dojo.number.parse(expression, dojo.currency._mixInDefaults(options));
}

}

if(!dojo._hasResource["dijit.form.NumberTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.NumberTextBox"] = true;
dojo.provide("dijit.form.NumberTextBox");




/*=====
dojo.declare(
	"dijit.form.NumberTextBox.__Constraints",
	[dijit.form.RangeBoundTextBox.__Constraints, dojo.number.__FormatOptions, dojo.number.__ParseOptions], {
	// summary:
	//		Specifies both the rules on valid/invalid values (minimum, maximum,
	//		number of required decimal places), and also formatting options for
	//		displaying the value when the field is not focused.
	// example:
	//		Minimum/maximum:
	//		To specify a field between 0 and 120:
	//	|		{min:0,max:120}
	//		To specify a field that must be an integer:
	//	|		{fractional:false}
	//		To specify a field where 0 to 3 decimal places are allowed on input,
	//		but after the field is blurred the value is displayed with 3 decimal places:
	//	|		{places:'0,3'}
});
=====*/

dojo.declare("dijit.form.NumberTextBoxMixin",
	null,
	{
		// summary:
		//		A mixin for all number textboxes
		// tags:
		//		protected

		// Override ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale (plus formatting options too?)
		regExpGen: dojo.number.regexp,

		/*=====
		// constraints: dijit.form.NumberTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including minimum/maximum allowed values) as well as
		//		formatting options like places (the number of digits to display after
		//		the decimal point).   See `dijit.form.NumberTextBox.__Constraints` for details.
		constraints: {},
		======*/

		// value: Number
		//		The value of this NumberTextBox as a javascript Number (ie, not a String).
		//		If the displayed value is blank, the value is NaN, and if the user types in
		//		an gibberish value (like "hello world"), the value is undefined
		//		(i.e. attr('value') returns undefined).
		//
		//		Symetrically, attr('value', NaN) will clear the displayed value,
		//		whereas attr('value', undefined) will have no effect.
		value: NaN,

		// editOptions: [protected] Object
		//		Properties to mix into constraints when the value is being edited.
		//		This is here because we edit the number in the format "12345", which is
		//		different than the display value (ex: "12,345")
		editOptions: { pattern: '#.######' },

		/*=====
		_formatter: function(value, options){
			// summary:
			//		_formatter() is called by format().   It's the base routine for formatting a number,
			//		as a string, for example converting 12345 into "12,345".
			// value: Number
			//		The number to be converted into a string.
			// options: dojo.number.__FormatOptions?
			//		Formatting options
			// tags:
			//		protected extension

			return "12345";		// String
		},
		 =====*/
		_formatter: dojo.number.format,

		postMixInProperties: function(){
			var places = typeof this.constraints.places == "number"? this.constraints.places : 0;
			if(places){ places++; } // decimal rounding errors take away another digit of precision
			if(typeof this.constraints.max != "number"){
				this.constraints.max = 9 * Math.pow(10, 15-places);
			}
			if(typeof this.constraints.min != "number"){
				this.constraints.min = -9 * Math.pow(10, 15-places);
			}
			this.inherited(arguments);
		},

		_onFocus: function(){
			if(this.disabled){ return; }
			var val = this.attr('value');
			if(typeof val == "number" && !isNaN(val)){
				var formattedValue = this.format(val, this.constraints);
				if(formattedValue !== undefined){
					this.textbox.value = formattedValue;
				}
			}
			this.inherited(arguments);
		},

		format: function(/*Number*/ value, /*dojo.number.__FormatOptions*/ constraints){
			// summary:
			//		Formats the value as a Number, according to constraints.
			// tags:
			//		protected

			if(typeof value != "number"){ return String(value); }
			if(isNaN(value)){ return ""; }
			if(("rangeCheck" in this) && !this.rangeCheck(value, constraints)){ return String(value) }
			if(this.editOptions && this._focused){
				constraints = dojo.mixin({}, constraints, this.editOptions);
			}
			return this._formatter(value, constraints);
		},

		/*=====
		parse: function(value, constraints){
			// summary:
			//		Parses the string value as a Number, according to constraints.
			// value: String
			//		String representing a number
			// constraints: dojo.number.__ParseOptions
			//		Formatting options
			// tags:
			//		protected

			return 123.45;		// Number
		},
		=====*/
		parse: dojo.number.parse,

		_getDisplayedValueAttr: function(){
			var v = this.inherited(arguments);
			return isNaN(v) ? this.textbox.value : v;
		},

		filter: function(/*Number*/ value){
			// summary:
			//		This is called with both the display value (string), and the actual value (a number).
			//		When called with the actual value it does corrections so that '' etc. are represented as NaN.
			//		Otherwise it dispatches to the superclass's filter() method.
			//
			//		See `dijit.form.TextBox.filter` for more details.
			return (value === null || value === '' || value === undefined) ? NaN : this.inherited(arguments); // attr('value', null||''||undefined) should fire onChange(NaN)
		},

		serialize: function(/*Number*/ value, /*Object?*/options){
			// summary:
			//		Convert value (a Number) into a canonical string (ie, how the number literal is written in javascript/java/C/etc.)
			// tags:
			//		protected
			return (typeof value != "number" || isNaN(value)) ? '' : this.inherited(arguments);
		},

		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange, /*String?*/formattedValue){
			// summary:
			//		Hook so attr('value', ...) works.
			if(value !== undefined && formattedValue === undefined){
				if(typeof value == "number"){
					if(isNaN(value)){ formattedValue = '' }
					else if(("rangeCheck" in this) && !this.rangeCheck(value, this.constraints)){
						formattedValue = String(value);
					}
				}else if(!value){ // 0 processed in if branch above, ''|null|undefined flow thru here
					formattedValue = '';
					value = NaN;
				}else{ // non-numeric values
					formattedValue = String(value);
					value = undefined;
				}
			}
			this.inherited(arguments, [value, priorityChange, formattedValue]);
		},

		_getValueAttr: function(){
			// summary:
			//		Hook so attr('value') works.
			//		Returns Number, NaN for '', or undefined for unparsable text
			var v = this.inherited(arguments); // returns Number for all values accepted by parse() or NaN for all other displayed values

			// If the displayed value of the textbox is gibberish (ex: "hello world"), this.inherited() above
			// returns NaN; this if() branch converts the return value to undefined.
			// Returning undefined prevents user text from being overwritten when doing _setValueAttr(_getValueAttr()).
			// A blank displayed value is still returned as NaN.
			if(isNaN(v) && this.textbox.value !== ''){
				if(this.constraints.exponent !== false && /\de[-+]?|\d/i.test(this.textbox.value) && (new RegExp("^"+dojo.number._realNumberRegexp(dojo.mixin({}, this.constraints))+"$").test(this.textbox.value))){	// check for exponential notation that parse() rejected (erroneously?)
					var n = Number(this.textbox.value);
					return isNaN(n) ? undefined : n; // return exponential Number or undefined for random text (may not be possible to do with the above RegExp check)
				}else{
					return undefined; // gibberish
				}
			}else{
				return v; // Number or NaN for ''
			}
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.RangeBoundTextBox.isValid to check that the editing-mode value is valid since
			// it may not be formatted according to the regExp vaidation rules
			if(!this._focused || this._isEmpty(this.textbox.value)){
				return this.inherited(arguments);
			}else{
				var v = this.attr('value');
				if(!isNaN(v) && this.rangeCheck(v, this.constraints)){
					if(this.constraints.exponent !== false && /\de[-+]?\d/i.test(this.textbox.value)){ // exponential, parse doesn't like it
						return true; // valid exponential number in range
					}else{
						return this.inherited(arguments);
					}
				}else{
					return false;
				}
			}
		}
	}
);

dojo.declare("dijit.form.NumberTextBox",
	[dijit.form.RangeBoundTextBox,dijit.form.NumberTextBoxMixin],
	{
		// summary:
		//		A TextBox for entering numbers, with formatting and range checking
		// description:
		//		NumberTextBox is a textbox for entering and displaying numbers, supporting
		//		the following main features:
		//
		//			1. Enforce minimum/maximum allowed values (as well as enforcing that the user types
		//				a number rather than a random string)
		//			2. NLS support (altering roles of comma and dot as "thousands-separator" and "decimal-point"
		//				depending on locale).
		//			3. Separate modes for editing the value and displaying it, specifically that
		//				the thousands separator character (typically comma) disappears when editing
		//				but reappears after the field is blurred.
		//			4. Formatting and constraints regarding the number of places (digits after the decimal point)
		//				allowed on input, and number of places displayed when blurred (see `constraints` parameter).
	}
);

}

if(!dojo._hasResource["dijit.form.CurrencyTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.CurrencyTextBox"] = true;
dojo.provide("dijit.form.CurrencyTextBox");




/*=====
dojo.declare(
	"dijit.form.CurrencyTextBox.__Constraints",
	[dijit.form.NumberTextBox.__Constraints, dojo.currency.__FormatOptions, dojo.currency.__ParseOptions], {
	// summary:
	//		Specifies both the rules on valid/invalid values (minimum, maximum,
	//		number of required decimal places), and also formatting options for
	//		displaying the value when the field is not focused (currency symbol,
	//		etc.)
	// description:
	//		Follows the pattern of `dijit.form.NumberTextBox.constraints`.
	//		In general developers won't need to set this parameter
	// example:
	//		To ensure that the user types in the cents (for example, 1.00 instead of just 1):
	//	|		{fractional:true}
});
=====*/

dojo.declare(
	"dijit.form.CurrencyTextBox",
	dijit.form.NumberTextBox,
	{
		// summary:
		//		A validating currency textbox
		// description:
		//		CurrencyTextBox is similar to `dijit.form.NumberTextBox` but has a few
		//		extra features related to currency:
		//
		//		1. After specifying the currency type (american dollars, euros, etc.) it automatically
		//			sets parse/format options such as how many decimal places to show.
		//		2. The currency mark (dollar sign, euro mark, etc.) is displayed when the field is blurred
		//			but erased during editing, so that the user can just enter a plain number.

		// currency: String
		//		the [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD"
		currency: "",

		// constraints: dijit.form.CurrencyTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including minimum/maximum allowed values) as well as
		//		formatting options.   See `dijit.form.CurrencyTextBox.__Constraints` for details.
		/*=====
		constraints: {},
		======*/

		// Override regExpGen ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale  (plus formatting options too?)
		regExpGen: function(constraints){
			// if focused, accept either currency data or NumberTextBox format
			return '(' + (this._focused? this.inherited(arguments, [ dojo.mixin({}, constraints, this.editOptions) ]) + '|' : '')
				+ dojo.currency.regexp(constraints) + ')';
		},

		// Override NumberTextBox._formatter to deal with currencies, ex: converts "123.45" to "$123.45"
		_formatter: dojo.currency.format,

		parse: function(/* String */ value, /* Object */ constraints){
			// summary:
			// 		Parses string value as a Currency, according to the constraints object
			// tags:
			// 		protected extension
			var v = dojo.currency.parse(value, constraints);
			if(isNaN(v) && /\d+/.test(value)){ // currency parse failed, but it could be because they are using NumberTextBox format so try its parse
				return this.inherited(arguments, [ value, dojo.mixin({}, constraints, this.editOptions) ]);
			}
			return v;
		},


		postMixInProperties: function(){
			this.constraints = dojo.currency._mixInDefaults(dojo.mixin(this.constraints, { currency: this.currency, exponent: false })); // get places
			this.inherited(arguments);
		}
	}
);

}

if(!dojo._hasResource["dijit._KeyNavContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._KeyNavContainer"] = true;
dojo.provide("dijit._KeyNavContainer");


dojo.declare("dijit._KeyNavContainer",
	dijit._Container,
	{

		// summary:
		//		A _Container with keyboard navigation of its children.
		// description:
		//		To use this mixin, call connectKeyNavHandlers() in
		//		postCreate() and call startupKeyNavChildren() in startup().
		//		It provides normalized keyboard and focusing code for Container
		//		widgets.
/*=====
		// focusedChild: [protected] Widget
		//		The currently focused child widget, or null if there isn't one
		focusedChild: null,
=====*/

		// tabIndex: Integer
		//		Tab index of the container; same as HTML tabIndex attribute.
		//		Note then when user tabs into the container, focus is immediately
		//		moved to the first item in the container.
		tabIndex: "0",

		_keyNavCodes: {},

		connectKeyNavHandlers: function(/*dojo.keys[]*/ prevKeyCodes, /*dojo.keys[]*/ nextKeyCodes){
			// summary:
			//		Call in postCreate() to attach the keyboard handlers
			//		to the container.
			// preKeyCodes: dojo.keys[]
			//		Key codes for navigating to the previous child.
			// nextKeyCodes: dojo.keys[]
			//		Key codes for navigating to the next child.
			// tags:
			//		protected

			var keyCodes = (this._keyNavCodes = {});
			var prev = dojo.hitch(this, this.focusPrev);
			var next = dojo.hitch(this, this.focusNext);
			dojo.forEach(prevKeyCodes, function(code){ keyCodes[code] = prev; });
			dojo.forEach(nextKeyCodes, function(code){ keyCodes[code] = next; });
			this.connect(this.domNode, "onkeypress", "_onContainerKeypress");
			this.connect(this.domNode, "onfocus", "_onContainerFocus");
		},

		startupKeyNavChildren: function(){
			// summary:
			//		Call in startup() to set child tabindexes to -1
			// tags:
			//		protected
			dojo.forEach(this.getChildren(), dojo.hitch(this, "_startupChild"));
		},

		addChild: function(/*dijit._Widget*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Add a child to our _Container
			dijit._KeyNavContainer.superclass.addChild.apply(this, arguments);
			this._startupChild(widget);
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		focusFirstChild: function(){
			// summary:
			//		Focus the first focusable child in the container.
			// tags:
			//		protected
			var child = this._getFirstFocusableChild();
			if(child){ // edge case: Menu could be empty or hidden
				this.focusChild(child);
			}
		},

		focusNext: function(){
			// summary:
			//		Focus the next widget
			// tags:
			//		protected
			var child = this._getNextFocusableChild(this.focusedChild, 1);
			this.focusChild(child);
		},

		focusPrev: function(){
			// summary:
			//		Focus the last focusable node in the previous widget
			//		(ex: go to the ComboButton icon section rather than button section)
			// tags:
			//		protected
			var child = this._getNextFocusableChild(this.focusedChild, -1);
			this.focusChild(child, true);
		},

		focusChild: function(/*dijit._Widget*/ widget, /*Boolean*/ last){
			// summary:
			//		Focus widget.
			// widget:
			//		Reference to container's child widget
			// last:
			//		If true and if widget has multiple focusable nodes, focus the
			//		last one instead of the first one
			// tags:
			//		protected
			
			if(this.focusedChild && widget !== this.focusedChild){
				this._onChildBlur(this.focusedChild);
			}
			widget.focus(last ? "end" : "start");
			this.focusedChild = widget;
		},

		_startupChild: function(/*dijit._Widget*/ widget){
			// summary:
			//		Setup for each child widget
			// description:
			//		Sets tabIndex=-1 on each child, so that the tab key will 
			//		leave the container rather than visiting each child.
			// tags:
			//		private
			
			widget.attr("tabIndex", "-1");
			
			this.connect(widget, "_onFocus", function(){
				// Set valid tabIndex so tabbing away from widget goes to right place, see #10272
				widget.attr("tabIndex", this.tabIndex);
			});
			this.connect(widget, "_onBlur", function(){
				widget.attr("tabIndex", "-1");
			});
		},

		_onContainerFocus: function(evt){
			// summary:
			//		Handler for when the container gets focus
			// description:
			//		Initially the container itself has a tabIndex, but when it gets
			//		focus, switch focus to first child...
			// tags:
			//		private

			// Note that we can't use _onFocus() because switching focus from the
			// _onFocus() handler confuses the focus.js code
			// (because it causes _onFocusNode() to be called recursively)

			// focus bubbles on Firefox,
			// so just make sure that focus has really gone to the container
			if(evt.target !== this.domNode){ return; }

			this.focusFirstChild();

			// and then set the container's tabIndex to -1,
			// (don't remove as that breaks Safari 4)
			// so that tab or shift-tab will go to the fields after/before
			// the container, rather than the container itself
			dojo.attr(this.domNode, "tabIndex", "-1");
		},

		_onBlur: function(evt){
			// When focus is moved away the container, and it's descendant (popup) widgets,
			// then restore the container's tabIndex so that user can tab to it again.
			// Note that using _onBlur() so that this doesn't happen when focus is shifted
			// to one of my child widgets (typically a popup)
			if(this.tabIndex){
				dojo.attr(this.domNode, "tabIndex", this.tabIndex);
			}
			this.inherited(arguments);
		},

		_onContainerKeypress: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then
			//		it's handled here.
			// tags:
			//		private
			if(evt.ctrlKey || evt.altKey){ return; }
			var func = this._keyNavCodes[evt.charOrCode];
			if(func){
				func();
				dojo.stopEvent(evt);
			}
		},

		_onChildBlur: function(/*dijit._Widget*/ widget){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			// tags:
			//		protected
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused
			return this._getNextFocusableChild(null, 1);	// dijit._Widget
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable child, compared
			//		to "child"
			// child: Widget
			//		The current widget
			// dir: Integer
			//		* 1 = after
			//		* -1 = before
			if(child){
				child = this._getSiblingOfChild(child, dir);
			}
			var children = this.getChildren();
			for(var i=0; i < children.length; i++){
				if(!child){
					child = children[(dir>0) ? 0 : (children.length-1)];
				}
				if(child.isFocusable()){
					return child;	// dijit._Widget
				}
				child = this._getSiblingOfChild(child, dir);
			}
			// no focusable child found
			return null;	// dijit._Widget
		}
	}
);

}

if(!dojo._hasResource["dijit.MenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuItem"] = true;
dojo.provide("dijit.MenuItem");





dojo.declare("dijit.MenuItem",
		[dijit._Widget, dijit._Templated, dijit._Contained],
		{
		// summary:
		//		A line item in a Menu Widget

		// Make 3 columns
		// icon, label, and expand arrow (BiDi-dependent) indicating sub-menu
		templateString: dojo.cache("dijit", "templates/MenuItem.html", "<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" waiRole=\"menuitem\" tabIndex=\"-1\"\r\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\r\n\t<td class=\"dijitReset\" waiRole=\"presentation\">\r\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon\" dojoAttachPoint=\"iconNode\">\r\n\t</td>\r\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode\"></td>\r\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\r\n\t<td class=\"dijitReset dijitMenuArrowCell\" waiRole=\"presentation\">\r\n\t\t<div dojoAttachPoint=\"arrowWrapper\" style=\"visibility: hidden\">\r\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuExpand\">\r\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\r\n\t\t</div>\r\n\t</td>\r\n</tr>\r\n"),

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			label: { node: "containerNode", type: "innerHTML" },
			iconClass: { node: "iconNode", type: "class" }
		}),

		// label: String
		//		Menu text
		label: '',

		// iconClass: String
		//		Class to apply to DOMNode to make it display an icon.
		iconClass: "",

		// accelKey: String
		//		Text for the accelerator (shortcut) key combination.
		//		Note that although Menu can display accelerator keys there
		//		is no infrastructure to actually catch and execute these
		//		accelerators.
		accelKey: "",

		// disabled: Boolean
		//		If true, the menu item is disabled.
		//		If false, the menu item is enabled.
		disabled: false,

		_fillContent: function(/*DomNode*/ source){
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			if(source && !("label" in this.params)){
				this.attr('label', source.innerHTML);
			}
		},

		postCreate: function(){
			dojo.setSelectable(this.domNode, false);
			var label = this.id+"_text";
			dojo.attr(this.containerNode, "id", label);
			if(this.accelKeyNode){
				dojo.attr(this.accelKeyNode, "id", this.id + "_accel");
				label += " " + this.id + "_accel";
			}
			dijit.setWaiState(this.domNode, "labelledby", label);
		},

		_onHover: function(){
			// summary:
			//		Handler when mouse is moved onto menu item
			// tags:
			//		protected
			dojo.addClass(this.domNode, 'dijitMenuItemHover');
			this.getParent().onItemHover(this);
		},

		_onUnhover: function(){
			// summary:
			//		Handler when mouse is moved off of menu item,
			//		possibly to a child menu, or maybe to a sibling
			//		menuitem or somewhere else entirely.
			// tags:
			//		protected

			// if we are unhovering the currently selected item
			// then unselect it
			dojo.removeClass(this.domNode, 'dijitMenuItemHover');
			this.getParent().onItemUnhover(this);
		},

		_onClick: function(evt){
			// summary:
			//		Internal handler for click events on MenuItem.
			// tags:
			//		private
			this.getParent().onItemClick(this, evt);
			dojo.stopEvent(evt);
		},

		onClick: function(/*Event*/ evt){
			// summary:
			//		User defined function to handle clicks
			// tags:
			//		callback
		},

		focus: function(){
			// summary:
			//		Focus on this MenuItem
			try{
				if(dojo.isIE == 8){
					// needed for IE8 which won't scroll TR tags into view on focus yet calling scrollIntoView creates flicker (#10275)
					this.containerNode.focus();
				}
				dijit.focus(this.focusNode);
			}catch(e){
				// this throws on IE (at least) in some scenarios
			}
		},

		_onFocus: function(){
			// summary:
			//		This is called by the focus manager when focus
			//		goes to this MenuItem or a child menu.
			// tags:
			//		protected
			this._setSelected(true);
			this.getParent()._onItemFocus(this);

			this.inherited(arguments);
		},

		_setSelected: function(selected){
			// summary:
			//		Indicate that this node is the currently selected one
			// tags:
			//		private

			/***
			 * TODO: remove this method and calls to it, when _onBlur() is working for MenuItem.
			 * Currently _onBlur() gets called when focus is moved from the MenuItem to a child menu.
			 * That's not supposed to happen, but the problem is:
			 * In order to allow dijit.popup's getTopPopup() to work,a sub menu's popupParent
			 * points to the parent Menu, bypassing the parent MenuItem... thus the
			 * MenuItem is not in the chain of active widgets and gets a premature call to
			 * _onBlur()
			 */

			dojo.toggleClass(this.domNode, "dijitMenuItemSelected", selected);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.   Use attr('label', ...) instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit.MenuItem.setLabel() is deprecated.  Use attr('label', ...) instead.", "", "2.0");
			this.attr("label", content);
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.   Use attr('disabled', bool) instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit.Menu.setDisabled() is deprecated.  Use attr('disabled', bool) instead.", "", "2.0");
			this.attr('disabled', disabled);
		},
		_setDisabledAttr: function(/*Boolean*/ value){
			// summary:
			//		Hook for attr('disabled', ...) to work.
			//		Enable or disable this menu item.
			this.disabled = value;
			dojo[value ? "addClass" : "removeClass"](this.domNode, 'dijitMenuItemDisabled');
			dijit.setWaiState(this.focusNode, 'disabled', value ? 'true' : 'false');
		},
		_setAccelKeyAttr: function(/*String*/ value){
			// summary:
			//		Hook for attr('accelKey', ...) to work.
			//		Set accelKey on this menu item.
			this.accelKey=value;

			this.accelKeyNode.style.display=value?"":"none";
			this.accelKeyNode.innerHTML=value;
			//have to use colSpan to make it work in IE
			dojo.attr(this.containerNode,'colSpan',value?"1":"2");
		}
	});

}

if(!dojo._hasResource["dijit.PopupMenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.PopupMenuItem"] = true;
dojo.provide("dijit.PopupMenuItem");



dojo.declare("dijit.PopupMenuItem",
		dijit.MenuItem,
		{
		_fillContent: function(){
			// summary:
			//		When Menu is declared in markup, this code gets the menu label and
			//		the popup widget from the srcNodeRef.
			// description:
			//		srcNodeRefinnerHTML contains both the menu item text and a popup widget
			//		The first part holds the menu item text and the second part is the popup
			// example:
			// |	<div dojoType="dijit.PopupMenuItem">
			// |		<span>pick me</span>
			// |		<popup> ... </popup>
			// |	</div>
			// tags:
			//		protected

			if(this.srcNodeRef){
				var nodes = dojo.query("*", this.srcNodeRef);
				dijit.PopupMenuItem.superclass._fillContent.call(this, nodes[0]);

				// save pointer to srcNode so we can grab the drop down widget after it's instantiated
				this.dropDownContainer = this.srcNodeRef;
			}
		},

		startup: function(){
			if(this._started){ return; }
			this.inherited(arguments);

			// we didn't copy the dropdown widget from the this.srcNodeRef, so it's in no-man's
			// land now.  move it to dojo.doc.body.
			if(!this.popup){
				var node = dojo.query("[widgetId]", this.dropDownContainer)[0];
				this.popup = dijit.byNode(node);
			}
			dojo.body().appendChild(this.popup.domNode);

			this.popup.domNode.style.display="none";
			if(this.arrowWrapper){
				dojo.style(this.arrowWrapper, "visibility", "");
			}
			dijit.setWaiState(this.focusNode, "haspopup", "true");
		},

		destroyDescendants: function(){
			if(this.popup){
				// Destroy the popup, unless it's already been destroyed.  This can happen because
				// the popup is a direct child of <body> even though it's logically my child.
				if(!this.popup._destroyed){
					this.popup.destroyRecursive();
				}
				delete this.popup;
			}
			this.inherited(arguments);
		}
	});


}

if(!dojo._hasResource["dijit.CheckedMenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.CheckedMenuItem"] = true;
dojo.provide("dijit.CheckedMenuItem");



dojo.declare("dijit.CheckedMenuItem",
		dijit.MenuItem,
		{
		// summary:
		//		A checkbox-like menu item for toggling on and off

		templateString: dojo.cache("dijit", "templates/CheckedMenuItem.html", "<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" waiRole=\"menuitemcheckbox\" tabIndex=\"-1\"\r\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\r\n\t<td class=\"dijitReset\" waiRole=\"presentation\">\r\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon dijitCheckedMenuItemIcon\" dojoAttachPoint=\"iconNode\">\r\n\t\t<span class=\"dijitCheckedMenuItemIconChar\">&#10003;</span>\r\n\t</td>\r\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode,labelNode\"></td>\r\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\r\n\t<td class=\"dijitReset dijitMenuArrowCell\" waiRole=\"presentation\">\r\n\t</td>\r\n</tr>\r\n"),

		// checked: Boolean
		//		Our checked state
		checked: false,
		_setCheckedAttr: function(/*Boolean*/ checked){
			// summary:
			//		Hook so attr('checked', bool) works.
			//		Sets the class and state for the check box.
			dojo.toggleClass(this.domNode, "dijitCheckedMenuItemChecked", checked);
			dijit.setWaiState(this.domNode, "checked", checked);
			this.checked = checked;
		},

		onChange: function(/*Boolean*/ checked){
			// summary:
			//		User defined function to handle check/uncheck events
			// tags:
			//		callback
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Clicking this item just toggles its state
			// tags:
			//		private
			if(!this.disabled){
				this.attr("checked", !this.checked);
				this.onChange(this.checked);
			}
			this.inherited(arguments);
		}
	});

}

if(!dojo._hasResource["dijit.MenuSeparator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuSeparator"] = true;
dojo.provide("dijit.MenuSeparator");





dojo.declare("dijit.MenuSeparator",
		[dijit._Widget, dijit._Templated, dijit._Contained],
		{
		// summary:
		//		A line between two menu items

		templateString: dojo.cache("dijit", "templates/MenuSeparator.html", "<tr class=\"dijitMenuSeparator\">\r\n\t<td colspan=\"4\">\r\n\t\t<div class=\"dijitMenuSeparatorTop\"></div>\r\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\r\n\t</td>\r\n</tr>\r\n"),

		postCreate: function(){
			dojo.setSelectable(this.domNode, false);
		},

		isFocusable: function(){
			// summary:
			//		Override to always return false
			// tags:
			//		protected

			return false; // Boolean
		}
	});


}

if(!dojo._hasResource["dijit.Menu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Menu"] = true;
dojo.provide("dijit.Menu");





dojo.declare("dijit._MenuBase",
	[dijit._Widget, dijit._Templated, dijit._KeyNavContainer],
{
	// summary:
	//		Base class for Menu and MenuBar

	// parentMenu: [readonly] Widget
	//		pointer to menu that displayed me
	parentMenu: null,

	// popupDelay: Integer
	//		number of milliseconds before hovering (without clicking) causes the popup to automatically open.
	popupDelay: 500,

	startup: function(){
		if(this._started){ return; }

		dojo.forEach(this.getChildren(), function(child){ child.startup(); });
		this.startupKeyNavChildren();

		this.inherited(arguments);
	},

	onExecute: function(){
		// summary:
		//		Attach point for notification about when a menu item has been executed.
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them, because they are about to execute the onClick handler.   In
		//		general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	onCancel: function(/*Boolean*/ closeAll){
		// summary:
		//		Attach point for notification about when the user cancels the current menu
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them.  In general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	_moveToPopup: function(/*Event*/ evt){
		// summary:
		//		This handles the right arrow key (left arrow key on RTL systems),
		//		which will either open a submenu, or move to the next item in the
		//		ancestor MenuBar
		// tags:
		//		private

		if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){
			this.focusedChild._onClick(evt);
		}else{
			var topMenu = this._getTopMenu();
			if(topMenu && topMenu._isMenuBar){
				topMenu.focusNext();
			}
		}
	},

	_onPopupHover: function(/*Event*/ evt){
		// summary:
		//		This handler is called when the mouse moves over the popup.
		// tags:
		//		private

		// if the mouse hovers over a menu popup that is in pending-close state,
		// then stop the close operation.
		// This can't be done in onItemHover since some popup targets don't have MenuItems (e.g. ColorPicker)
		if(this.currentPopup && this.currentPopup._pendingClose_timer){
			var parentMenu = this.currentPopup.parentMenu;
			// highlight the parent menu item pointing to this popup
			if(parentMenu.focusedChild){
				parentMenu.focusedChild._setSelected(false);
			}
			parentMenu.focusedChild = this.currentPopup.from_item;
			parentMenu.focusedChild._setSelected(true);
			// cancel the pending close
			this._stopPendingCloseTimer(this.currentPopup);
		}
	},

	onItemHover: function(/*MenuItem*/ item){
		// summary:
		//		Called when cursor is over a MenuItem.
		// tags:
		//		protected

		// Don't do anything unless user has "activated" the menu by:
		//		1) clicking it
		//		2) opening it from a parent menu (which automatically focuses it)
		if(this.isActive){
			this.focusChild(item);
			if(this.focusedChild.popup && !this.focusedChild.disabled && !this.hover_timer){
				this.hover_timer = setTimeout(dojo.hitch(this, "_openPopup"), this.popupDelay);
			}
		}
		// if the user is mixing mouse and keyboard navigation,
		// then the menu may not be active but a menu item has focus,
		// but it's not the item that the mouse just hovered over.
		// To avoid both keyboard and mouse selections, use the latest.
		if(this.focusedChild){
			this.focusChild(item);
		}
		this._hoveredChild = item;
	},

	_onChildBlur: function(item){
		// summary:
		//		Called when a child MenuItem becomes inactive because focus
		//		has been removed from the MenuItem *and* it's descendant menus.
		// tags:
		//		private
		this._stopPopupTimer();
		item._setSelected(false);
		// Close all popups that are open and descendants of this menu
		var itemPopup = item.popup;
		if(itemPopup){
			this._stopPendingCloseTimer(itemPopup);
			itemPopup._pendingClose_timer = setTimeout(function(){
				itemPopup._pendingClose_timer = null;
				if(itemPopup.parentMenu){
					itemPopup.parentMenu.currentPopup = null;
				}
				dijit.popup.close(itemPopup); // this calls onClose
			}, this.popupDelay);
		}
	},

	onItemUnhover: function(/*MenuItem*/ item){
		// summary:
		//		Callback fires when mouse exits a MenuItem
		// tags:
		//		protected

		if(this.isActive){
			this._stopPopupTimer();
		}
		if(this._hoveredChild == item){ this._hoveredChild = null; }
	},

	_stopPopupTimer: function(){
		// summary:
		//		Cancels the popup timer because the user has stop hovering
		//		on the MenuItem, etc.
		// tags:
		//		private
		if(this.hover_timer){
			clearTimeout(this.hover_timer);
			this.hover_timer = null;
		}
	},

	_stopPendingCloseTimer: function(/*dijit._Widget*/ popup){
		// summary:
		//		Cancels the pending-close timer because the close has been preempted
		// tags:
		//		private
		if(popup._pendingClose_timer){
			clearTimeout(popup._pendingClose_timer);
			popup._pendingClose_timer = null;
		}
	},

	_stopFocusTimer: function(){
		// summary:
		//		Cancels the pending-focus timer because the menu was closed before focus occured
		// tags:
		//		private
		if(this._focus_timer){
			clearTimeout(this._focus_timer);
			this._focus_timer = null;
		}
	},

	_getTopMenu: function(){
		// summary:
		//		Returns the top menu in this chain of Menus
		// tags:
		//		private
		for(var top=this; top.parentMenu; top=top.parentMenu);
		return top;
	},

	onItemClick: function(/*dijit._Widget*/ item, /*Event*/ evt){
		// summary:
		//		Handle clicks on an item.
		// tags:
		//		private
		if(item.disabled){ return false; }

		// this can't be done in _onFocus since the _onFocus events occurs asynchronously
		if(typeof this.isShowingNow == 'undefined'){ // non-popup menu
			this._markActive();
		}

		this.focusChild(item);

		if(item.popup){
			this._openPopup();
		}else{
			// before calling user defined handler, close hierarchy of menus
			// and restore focus to place it was when menu was opened
			this.onExecute();

			// user defined handler for click
			item.onClick(evt);
		}
	},

	_openPopup: function(){
		// summary:
		//		Open the popup to the side of/underneath the current menu item
		// tags:
		//		protected

		this._stopPopupTimer();
		var from_item = this.focusedChild;
		if(!from_item){ return; } // the focused child lost focus since the timer was started
		var popup = from_item.popup;
		if(popup.isShowingNow){ return; }
		if(this.currentPopup){
			this._stopPendingCloseTimer(this.currentPopup);
			dijit.popup.close(this.currentPopup);
		}
		popup.parentMenu = this;
		popup.from_item = from_item; // helps finding the parent item that should be focused for this popup
		var self = this;
		dijit.popup.open({
			parent: this,
			popup: popup,
			around: from_item.domNode,
			orient: this._orient || (this.isLeftToRight() ?
									{'TR': 'TL', 'TL': 'TR', 'BR': 'BL', 'BL': 'BR'} :
									{'TL': 'TR', 'TR': 'TL', 'BL': 'BR', 'BR': 'BL'}),
			onCancel: function(){ // called when the child menu is canceled
				// set isActive=false (_closeChild vs _cleanUp) so that subsequent hovering will NOT open child menus
				// which seems aligned with the UX of most applications (e.g. notepad, wordpad, paint shop pro)
				self.focusChild(from_item);	// put focus back on my node
				self._cleanUp();			// close the submenu (be sure this is done _after_ focus is moved)
				from_item._setSelected(true); // oops, _cleanUp() deselected the item
				self.focusedChild = from_item;	// and unset focusedChild
			},
			onExecute: dojo.hitch(this, "_cleanUp")
		});

		this.currentPopup = popup;
		// detect mouseovers to handle lazy mouse movements that temporarily focus other menu items
		popup.connect(popup.domNode, "onmouseenter", dojo.hitch(self, "_onPopupHover")); // cleaned up when the popped-up widget is destroyed on close

		if(popup.focus){
			// If user is opening the popup via keyboard (right arrow, or down arrow for MenuBar),
			// if the cursor happens to collide with the popup, it will generate an onmouseover event
			// even though the mouse wasn't moved.   Use a setTimeout() to call popup.focus so that
			// our focus() call overrides the onmouseover event, rather than vice-versa.  (#8742)
			popup._focus_timer = setTimeout(dojo.hitch(popup, function(){
				this._focus_timer = null;
				this.focus();
			}), 0);
		}
	},

	_markActive: function(){
		// summary:
		//              Mark this menu's state as active.
		//		Called when this Menu gets focus from:
		//			1) clicking it (mouse or via space/arrow key)
		//			2) being opened by a parent menu.
		//		This is not called just from mouse hover.
		//		Focusing a menu via TAB does NOT automatically set isActive
		//		since TAB is a navigation operation and not a selection one.
		//		For Windows apps, pressing the ALT key focuses the menubar
		//		menus (similar to TAB navigation) but the menu is not active
		//		(ie no dropdown) until an item is clicked.
		this.isActive = true;
		dojo.addClass(this.domNode, "dijitMenuActive");
		dojo.removeClass(this.domNode, "dijitMenuPassive");
	},

	onOpen: function(/*Event*/ e){
		// summary:
		//		Callback when this menu is opened.
		//		This is called by the popup manager as notification that the menu
		//		was opened.
		// tags:
		//		private

		this.isShowingNow = true;
		this._markActive();
	},

	_markInactive: function(){
		// summary:
		//		Mark this menu's state as inactive.
		this.isActive = false; // don't do this in _onBlur since the state is pending-close until we get here
		dojo.removeClass(this.domNode, "dijitMenuActive");
		dojo.addClass(this.domNode, "dijitMenuPassive");
	},

	onClose: function(){
		// summary:
		//		Callback when this menu is closed.
		//		This is called by the popup manager as notification that the menu
		//		was closed.
		// tags:
		//		private

		this._stopFocusTimer();
		this._markInactive();
		this.isShowingNow = false;
		this.parentMenu = null;
	},

	_closeChild: function(){
		// summary:
		//		Called when submenu is clicked or focus is lost.  Close hierarchy of menus.
		// tags:
		//		private
		this._stopPopupTimer();
		if(this.focusedChild){ // unhighlight the focused item
			this.focusedChild._setSelected(false);
			this.focusedChild._onUnhover();
			this.focusedChild = null;
		}
		if(this.currentPopup){
			// Close all popups that are open and descendants of this menu
			dijit.popup.close(this.currentPopup);
			this.currentPopup = null;
		}
	},

	_onItemFocus: function(/*MenuItem*/ item){
		// summary:
		//		Called when child of this Menu gets focus from:
		//			1) clicking it
		//			2) tabbing into it
		//			3) being opened by a parent menu.
		//		This is not called just from mouse hover.
		if(this._hoveredChild && this._hoveredChild != item){
			this._hoveredChild._onUnhover(); // any previous mouse movement is trumped by focus selection
		}
	},

	_onBlur: function(){
		// summary:
		//		Called when focus is moved away from this Menu and it's submenus.
		// tags:
		//		protected
		this._cleanUp();
		this.inherited(arguments);
	},

	_cleanUp: function(){
		// summary:
		//		Called when the user is done with this menu.  Closes hierarchy of menus.
		// tags:
		//		private

		this._closeChild(); // don't call this.onClose since that's incorrect for MenuBar's that never close
		if(typeof this.isShowingNow == 'undefined'){ // non-popup menu doesn't call onClose
			this._markInactive();
		}
	}
});

dojo.declare("dijit.Menu",
	dijit._MenuBase,
	{
	// summary
	//		A context menu you can assign to multiple elements

	// TODO: most of the code in here is just for context menu (right-click menu)
	// support.  In retrospect that should have been a separate class (dijit.ContextMenu).
	// Split them for 2.0

	constructor: function(){
		this._bindings = [];
	},

	templateString: dojo.cache("dijit", "templates/Menu.html", "<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" waiRole=\"menu\" tabIndex=\"${tabIndex}\" dojoAttachEvent=\"onkeypress:_onKeyPress\">\r\n\t<tbody class=\"dijitReset\" dojoAttachPoint=\"containerNode\"></tbody>\r\n</table>\r\n"),

	// targetNodeIds: [const] String[]
	//		Array of dom node ids of nodes to attach to.
	//		Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.
	targetNodeIds: [],

	// contextMenuForWindow: [const] Boolean
	//		If true, right clicking anywhere on the window will cause this context menu to open.
	//		If false, must specify targetNodeIds.
	contextMenuForWindow: false,

	// leftClickToOpen: [const] Boolean
	//		If true, menu will open on left click instead of right click, similiar to a file menu.
	leftClickToOpen: false,

	// refocus: Boolean
	// 		When this menu closes, re-focus the element which had focus before it was opened.
	refocus: true,

	// _contextMenuWithMouse: [private] Boolean
	//		Used to record mouse and keyboard events to determine if a context
	//		menu is being opened with the keyboard or the mouse.
	_contextMenuWithMouse: false,

	postCreate: function(){
		if(this.contextMenuForWindow){
			this.bindDomNode(dojo.body());
		}else{
			// TODO: should have _setTargetNodeIds() method to handle initialization and a possible
			// later attr('targetNodeIds', ...) call.   There's also a problem that targetNodeIds[]
			// gets stale after calls to bindDomNode()/unBindDomNode() as it still is just the original list (see #9610)
			dojo.forEach(this.targetNodeIds, this.bindDomNode, this);
		}
		var k = dojo.keys, l = this.isLeftToRight();
		this._openSubMenuKey = l ? k.RIGHT_ARROW : k.LEFT_ARROW;
		this._closeSubMenuKey = l ? k.LEFT_ARROW : k.RIGHT_ARROW;
		this.connectKeyNavHandlers([k.UP_ARROW], [k.DOWN_ARROW]);
	},

	_onKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handle keyboard based menu navigation.
		// tags:
		//		protected

		if(evt.ctrlKey || evt.altKey){ return; }

		switch(evt.charOrCode){
			case this._openSubMenuKey:
				this._moveToPopup(evt);
				dojo.stopEvent(evt);
				break;
			case this._closeSubMenuKey:
				if(this.parentMenu){
					if(this.parentMenu._isMenuBar){
						this.parentMenu.focusPrev();
					}else{
						this.onCancel(false);
					}
				}else{
					dojo.stopEvent(evt);
				}
				break;
		}
	},

	// thanks burstlib!
	_iframeContentWindow: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns the window reference of the passed iframe
		// tags:
		//		private
		var win = dijit.getDocumentWindow(this._iframeContentDocument(iframe_el)) ||
			// Moz. TODO: is this available when defaultView isn't?
			this._iframeContentDocument(iframe_el)['__parent__'] ||
			(iframe_el.name && dojo.doc.frames[iframe_el.name]) || null;
		return win;	//	Window
	},

	_iframeContentDocument: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns a reference to the document object inside iframe_el
		// tags:
		//		protected
		var doc = iframe_el.contentDocument // W3
			|| (iframe_el.contentWindow && iframe_el.contentWindow.document) // IE
			|| (iframe_el.name && dojo.doc.frames[iframe_el.name] && dojo.doc.frames[iframe_el.name].document)
			|| null;
		return doc;	//	HTMLDocument
	},

	bindDomNode: function(/*String|DomNode*/ node){
		// summary:
		//		Attach menu to given node
		node = dojo.byId(node);

		var cn;	// Connect node

		// Support context menus on iframes.   Rather than binding to the iframe itself we need
		// to bind to the <body> node inside the iframe.
		if(node.tagName.toLowerCase() == "iframe"){
			var iframe = node,
				win = this._iframeContentWindow(iframe);
			cn = dojo.withGlobal(win, dojo.body);
		}else{
			
			// To capture these events at the top level, attach to <html>, not <body>.
			// Otherwise right-click context menu just doesn't work.
			cn = (node == dojo.body() ? dojo.doc.documentElement : node);
		}


		// "binding" is the object to track our connection to the node (ie, the parameter to bindDomNode())
		var binding = {
			node: node,
			iframe: iframe
		};

		// Save info about binding in _bindings[], and make node itself record index(+1) into
		// _bindings[] array.   Prefix w/_dijitMenu to avoid setting an attribute that may
		// start with a number, which fails on FF/safari.
		dojo.attr(node, "_dijitMenu" + this.id, this._bindings.push(binding));

		// Setup the connections to monitor click etc., unless we are connecting to an iframe which hasn't finished
		// loading yet, in which case we need to wait for the onload event first, and then connect
		var doConnects = dojo.hitch(this, function(cn){
			return [
				dojo.connect(cn, (this.leftClickToOpen)?"onclick":"oncontextmenu", this, function(evt){
					this._openMyself(evt, cn, iframe);
				}),
				dojo.connect(cn, "onkeydown", this, "_contextKey"),
				dojo.connect(cn, "onmousedown", this, "_contextMouse")
			];
		});
		binding.connects = cn ? doConnects(cn) : [];

		if(iframe){
			// Setup handler to [re]bind to the iframe when the contents are initially loaded,
			// and every time the contents change.
			// Need to do this b/c we are actually binding to the iframe's <body> node.
			// Note: can't use dojo.connect(), see #9609.

			binding.onloadHandler = dojo.hitch(this, function(){
				// want to remove old connections, but IE throws exceptions when trying to
				// access the <body> node because it's already gone, or at least in a state of limbo

				var win = this._iframeContentWindow(iframe);
					cn = dojo.withGlobal(win, dojo.body);
				binding.connects = doConnects(cn);
			});
			if(iframe.addEventListener){
				iframe.addEventListener("load", binding.onloadHandler, false);
			}else{
				iframe.attachEvent("onload", binding.onloadHandler);
			}
		}
	},

	unBindDomNode: function(/*String|DomNode*/ nodeName){
		// summary:
		//		Detach menu from given node

		var node;
		try{
			node = dojo.byId(nodeName);
		}catch(e){
			// On IE the dojo.byId() call will get an exception if the attach point was
			// the <body> node of an <iframe> that has since been reloaded (and thus the
			// <body> node is in a limbo state of destruction.
			return;
		}

		// node["_dijitMenu" + this.id] contains index(+1) into my _bindings[] array
		var attrName = "_dijitMenu" + this.id;
		if(node && dojo.hasAttr(node, attrName)){
			var bid = dojo.attr(node, attrName)-1, b = this._bindings[bid];
			dojo.forEach(b.connects, dojo.disconnect);

			// Remove listener for iframe onload events
			var iframe = b.iframe;
			if(iframe){
				if(iframe.removeEventListener){
					iframe.removeEventListener("load", b.onloadHandler, false);
				}else{
					iframe.detachEvent("onload", b.onloadHandler);
				}
			}

			dojo.removeAttr(node, attrName);
			delete this._bindings[bid];
		}
	},

	_contextKey: function(e){
		// summary:
		//		Code to handle popping up editor using F10 key rather than mouse
		// tags:
		//		private
		this._contextMenuWithMouse = false;
		if(e.keyCode == dojo.keys.F10){
			dojo.stopEvent(e);
			if(e.shiftKey && e.type == "keydown"){
				// FF: copying the wrong property from e will cause the system
				// context menu to appear in spite of stopEvent. Don't know
				// exactly which properties cause this effect.
				var _e = { target: e.target, pageX: e.pageX, pageY: e.pageY };
				_e.preventDefault = _e.stopPropagation = function(){};
				// IE: without the delay, focus work in "open" causes the system
				// context menu to appear in spite of stopEvent.
				window.setTimeout(dojo.hitch(this, function(){ this._openMyself(_e); }), 1);
			}
		}
	},

	_contextMouse: function(e){
		// summary:
		//		Helper to remember when we opened the context menu with the mouse instead
		//		of with the keyboard
		// tags:
		//		private
		this._contextMenuWithMouse = true;
	},

	_openMyself: function(/*Event*/ e, /*DomNode?*/ node, /*DomNode?*/ iframe){
		// summary:
		//		Internal function for opening myself when the user
		//		does a right-click or something similar.
		// node:
		//		The node that is being clicked
		// iframe:
		//		If an <iframe> is being clicked, iframe points to that iframe and node
		//		points to the iframe's body.
		// tags:
		//		private

		if(this.leftClickToOpen && e.button>0){
			return;
		}
		dojo.stopEvent(e);

		// Get coordinates.
		// If we are opening the menu with the mouse or on safari open
		// the menu at the mouse cursor
		// (Safari does not have a keyboard command to open the context menu
		// and we don't currently have a reliable way to determine
		// _contextMenuWithMouse on Safari)
		var x,y;
		if(dojo.isSafari || this._contextMenuWithMouse){
			x=e.pageX;
			y=e.pageY;

			if(iframe){
				// Event is on <body> node of an <iframe>, convert coordinates to match main document
				var od = e.target.ownerDocument,
					ifc = dojo.position(iframe, true),
					win = this._iframeContentWindow(iframe),
					scroll = dojo.withGlobal(win, "_docScroll", dojo);

				var cs = dojo.getComputedStyle(iframe),
					tp = dojo._toPixelValue,
					left = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingLeft)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderLeftWidth) : 0),
					top = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingTop)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderTopWidth) : 0);

				x += ifc.x + left - scroll.x;
				y += ifc.y + top - scroll.y;
			}
		}else{
			// otherwise open near e.target
			var coords = dojo.position(e.target, true);
			x = coords.x + 10;
			y = coords.y + 10;
		}

		var self=this;
		var savedFocus = dijit.getFocus(this);
		function closeAndRestoreFocus(){
			// user has clicked on a menu or popup
			if(self.refocus){
				dijit.focus(savedFocus);
			}
			dijit.popup.close(self);
		}
		dijit.popup.open({
			popup: this,
			x: x,
			y: y,
			onExecute: closeAndRestoreFocus,
			onCancel: closeAndRestoreFocus,
			orient: this.isLeftToRight() ? 'L' : 'R'
		});
		this.focus();

		this._onBlur = function(){
			this.inherited('_onBlur', arguments);
			// Usually the parent closes the child widget but if this is a context
			// menu then there is no parent
			dijit.popup.close(this);
			// don't try to restore focus; user has clicked another part of the screen
			// and set focus there
		};
	},

	uninitialize: function(){
 		dojo.forEach(this._bindings, function(b){ if(b){ this.unBindDomNode(b.node); } }, this);
 		this.inherited(arguments);
	}
}
);

// Back-compat (TODO: remove in 2.0)






}

if(!dojo._hasResource["dijit.form._FormSelectWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._FormSelectWidget"] = true;
dojo.provide("dijit.form._FormSelectWidget");




/*=====
dijit.form.__SelectOption = function(){
	// value: String
	//		The value of the option.  Setting to empty (or missing) will
	//		place a separator at that location
	// label: String
	//		The label for our option.  It can contain html tags.
	//  selected: Boolean
	//		Whether or not we are a selected option
	// disabled: Boolean
	//		Whether or not this specific option is disabled
	this.value = value;
	this.label = label;
	this.selected = selected;
	this.disabled = disabled;
}
=====*/

dojo.declare("dijit.form._FormSelectWidget", dijit.form._FormValueWidget, {
	// summary:
	//		Extends _FormValueWidget in order to provide "select-specific"
	//		values - i.e., those values that are unique to <select> elements.
	//		This also provides the mechanism for reading the elements from
	//		a store, if desired.

	// multiple: Boolean
	//		Whether or not we are multi-valued
	multiple: false,

	// options: dijit.form.__SelectOption[]
	//		The set of options for our select item.  Roughly corresponds to
	//      the html <option> tag.
	options: null,

	// store: dojo.data.api.Identity
	//		A store which, at the very least impelements dojo.data.api.Identity
	//		to use for getting our list of options - rather than reading them
	//		from the <option> html tags.
	store: null,

	// query: object
	//		A query to use when fetching items from our store
	query: null,

	// queryOptions: object
	//		Query options to use when fetching from the store
	queryOptions: null,

	// onFetch: Function
	//		A callback to do with an onFetch - but before any items are actually
	//		iterated over (i.e. to filter even futher what you want to add)
	onFetch: null,

	// sortByLabel: boolean
	//		Flag to sort the options returned from a store by the label of
	//		the store.
	sortByLabel: true,


	// loadChildrenOnOpen: boolean
	//		By default loadChildren is called when the items are fetched from the
	//		store.  This property allows delaying loadChildren (and the creation
	//		of the options/menuitems) until the user opens the click the button.
	//		dropdown
	loadChildrenOnOpen: false,

	getOptions: function(/* anything */ valueOrIdx){
		// summary:
		//		Returns a given option (or options).
		// valueOrIdx:
		//		If passed in as a string, that string is used to look up the option
		//		in the array of options - based on the value property.
		//		(See dijit.form.__SelectOption).
		//
		//		If passed in a number, then the option with the given index (0-based)
		//		within this select will be returned.
		//
		//		If passed in a dijit.form.__SelectOption, the same option will be
		//		returned if and only if it exists within this select.
		//
		//		If passed an array, then an array will be returned with each element
		//		in the array being looked up.
		//
		//		If not passed a value, then all options will be returned
		//
		// returns:
		//		The option corresponding with the given value or index.  null
		//		is returned if any of the following are true:
		//			- A string value is passed in which doesn't exist
		//			- An index is passed in which is outside the bounds of the array of options
		//			- A dijit.form.__SelectOption is passed in which is not a part of the select

		// NOTE: the compare for passing in a dijit.form.__SelectOption checks
		//		if the value property matches - NOT if the exact option exists
		// NOTE: if passing in an array, null elements will be placed in the returned
		//		array when a value is not found.
		var lookupValue = valueOrIdx, opts = this.options || [], l = opts.length;

		if(lookupValue === undefined){
			return opts; // dijit.form.__SelectOption[]
		}
		if(dojo.isArray(lookupValue)){
			return dojo.map(lookupValue, "return this.getOptions(item);", this); // dijit.form.__SelectOption[]
		}
		if(dojo.isObject(valueOrIdx)){
			// We were passed an option - so see if it's in our array (directly),
			// and if it's not, try and find it by value.
			if(!dojo.some(this.options, function(o, idx){
				if(o === lookupValue ||
					(o.value && o.value === lookupValue.value)){
					lookupValue = idx;
					return true;
				}
				return false;
			})){
				lookupValue = -1;
			}
		}
		if(typeof lookupValue == "string"){
			for(var i=0; i<l; i++){
				if(opts[i].value === lookupValue){
					lookupValue = i;
					break;
				}
			}
		}
		if(typeof lookupValue == "number" && lookupValue >= 0 && lookupValue < l){
			return this.options[lookupValue] // dijit.form.__SelectOption
		}
		return null; // null
	},

	addOption: function(/* dijit.form.__SelectOption, dijit.form.__SelectOption[] */ option){
		// summary:
		//		Adds an option or options to the end of the select.  If value
		//		of the option is empty or missing, a separator is created instead.
		//		Passing in an array of options will yield slightly better performance
		//		since the children are only loaded once.
		if(!dojo.isArray(option)){ option = [option]; }
		dojo.forEach(option, function(i){
			if(i && dojo.isObject(i)){
				this.options.push(i);
			}
		}, this);
		this._loadChildren();
	},

	removeOption: function(/* string, dijit.form.__SelectOption, number, or array */ valueOrIdx){
		// summary:
		//		Removes the given option or options.  You can remove by string
		//		(in which case the value is removed), number (in which case the
		//		index in the options array is removed), or select option (in
		//		which case, the select option with a matching value is removed).
		//		You can also pass in an array of those values for a slightly
		//		better performance since the children are only loaded once.
		if(!dojo.isArray(valueOrIdx)){ valueOrIdx = [valueOrIdx]; }
		var oldOpts = this.getOptions(valueOrIdx);
		dojo.forEach(oldOpts, function(i){
			// We can get null back in our array - if our option was not found.  In
			// that case, we don't want to blow up...
			if(i){
				this.options = dojo.filter(this.options, function(node, idx){
					return (node.value !== i.value);
				});
				this._removeOptionItem(i);
			}
		}, this);
		this._loadChildren();
	},

	updateOption: function(/* dijit.form.__SelectOption, dijit.form.__SelectOption[] */ newOption){
		// summary:
		//		Updates the values of the given option.  The option to update
		//		is matched based on the value of the entered option.  Passing
		//		in an array of new options will yeild better performance since
		//		the children will only be loaded once.
		if(!dojo.isArray(newOption)){ newOption = [newOption]; }
		dojo.forEach(newOption, function(i){
			var oldOpt = this.getOptions(i), k;
			if(oldOpt){
				for(k in i){ oldOpt[k] = i[k]; }
			}
		}, this);
		this._loadChildren();
	},

	setStore: function(/* dojo.data.api.Identity */ store,
						/* anything? */ selectedValue,
						/* Object? */ fetchArgs){
		// summary:
		//		Sets the store you would like to use with this select widget.
		//		The selected value is the value of the new store to set.  This
		//		function returns the original store, in case you want to reuse
		//		it or something.
		// store: dojo.data.api.Identity
		//		The store you would like to use - it MUST implement Identity,
		//		and MAY implement Notification.
		// selectedValue: anything?
		//		The value that this widget should set itself to *after* the store
		//		has been loaded
		// fetchArgs: Object?
		//		The arguments that will be passed to the store's fetch() function
		var oStore = this.store;
		fetchArgs = fetchArgs || {};
		if(oStore !== store){
			// Our store has changed, so update our notifications
			dojo.forEach(this._notifyConnections || [], dojo.disconnect);
			delete this._notifyConnections;
			if(store && store.getFeatures()["dojo.data.api.Notification"]){
				this._notifyConnections = [
					dojo.connect(store, "onNew", this, "_onNewItem"),
					dojo.connect(store, "onDelete", this, "_onDeleteItem"),
					dojo.connect(store, "onSet", this, "_onSetItem")
				];
			}
			this.store = store;
		}

		// Turn off change notifications while we make all these changes
		this._onChangeActive = false;

		// Remove existing options (if there are any)
		if(this.options && this.options.length){
			this.removeOption(this.options);
		}

		// Add our new options
		if(store){
			var cb = function(items){
				if(this.sortByLabel && !fetchArgs.sort && items.length){
					items.sort(dojo.data.util.sorter.createSortFunction([{
						attribute: store.getLabelAttributes(items[0])[0]
					}], store));
				}

				if(fetchArgs.onFetch){
					items = fetchArgs.onFetch(items);
				}
				// TODO: Add these guys as a batch, instead of separately
				dojo.forEach(items, function(i){
					this._addOptionForItem(i);
				}, this);

				// Set our value (which might be undefined), and then tweak
				// it to send a change event with the real value
				this._loadingStore = false;
				this.attr("value", (("_pendingValue" in this) ? this._pendingValue : selectedValue));
				delete this._pendingValue;

				if(!this.loadChildrenOnOpen){
					this._loadChildren();
				}else{
					this._pseudoLoadChildren(items);
				}
				this._fetchedWith = opts;
				this._lastValueReported = this.multiple ? [] : null;
				this._onChangeActive = true;
				this.onSetStore();
				this._handleOnChange(this.value);
			};
			var opts = dojo.mixin({onComplete:cb, scope: this}, fetchArgs);
			this._loadingStore = true;
			store.fetch(opts);
		}else{
			delete this._fetchedWith;
		}
		return oStore;	// dojo.data.api.Identity
	},

	_setValueAttr: function(/*anything*/ newValue, /*Boolean, optional*/ priorityChange){
		// summary:
		//		set the value of the widget.
		//		If a string is passed, then we set our value from looking it up.
		if(this._loadingStore){
			// Our store is loading - so save our value, and we'll set it when
			// we're done
			this._pendingValue = newValue;
			return;
		}
		var opts = this.getOptions() || [];
		if(!dojo.isArray(newValue)){
			newValue = [newValue];
		}
		dojo.forEach(newValue, function(i, idx){
			if(!dojo.isObject(i)){
				i = i + "";
			}
			if(typeof i === "string"){
				newValue[idx] = dojo.filter(opts, function(node){
					return node.value === i;
				})[0] || {value: "", label: ""};
			}
		}, this);

		// Make sure some sane default is set
		newValue = dojo.filter(newValue, function(i){ return i && i.value; });
		if(!this.multiple && (!newValue[0] || !newValue[0].value) && opts.length){
			newValue[0] = opts[0];
		}
		dojo.forEach(opts, function(i){
			i.selected = dojo.some(newValue, function(v){ return v.value === i.value; });
		});
		var val = dojo.map(newValue, function(i){ return i.value; }),
			disp = dojo.map(newValue, function(i){ return i.label; });

		this.value = this.multiple ? val : val[0];
		this._setDisplay(this.multiple ? disp : disp[0]);
		this._updateSelection();
		this._handleOnChange(this.value, priorityChange);
	},

	_getDisplayedValueAttr: function(){
		// summary:
		//		returns the displayed value of the widget
		var val = this.attr("value");
		if(!dojo.isArray(val)){
			val = [val];
		}
		var ret = dojo.map(this.getOptions(val), function(v){
			if(v && "label" in v){
				return v.label;
			}else if(v){
				return v.value;
			}
			return null;
		}, this);
		return this.multiple ? ret : ret[0];
	},

	_getValueDeprecated: false, // remove when _FormWidget:getValue is removed
	getValue: function(){
		// summary:
		//		get the value of the widget.
		return this._lastValue;
	},

	undo: function(){
		// summary:
		//		restore the value to the last value passed to onChange
		this._setValueAttr(this._lastValueReported, false);
	},

	_loadChildren: function(){
		// summary:
		//		Loads the children represented by this widget's options.
		//		reset the menu to make it "populatable on the next click
		if(this._loadingStore){ return; }
		dojo.forEach(this._getChildren(), function(child){
			child.destroyRecursive();
		});
		// Add each menu item
		dojo.forEach(this.options, this._addOptionItem, this);

		// Update states
		this._updateSelection();
	},

	_updateSelection: function(){
		// summary:
		//		Sets the "selected" class on the item for styling purposes
		this.value = this._getValueFromOpts();
		var val = this.value;
		if(!dojo.isArray(val)){
			val = [val];
		}
		if(val && val[0]){
			dojo.forEach(this._getChildren(), function(child){
				var isSelected = dojo.some(val, function(v){
					return child.option && (v === child.option.value);
				});
				dojo.toggleClass(child.domNode, this.baseClass + "SelectedOption", isSelected);
				dijit.setWaiState(child.domNode, "selected", isSelected);
			}, this);
		}
		this._handleOnChange(this.value);
	},

	_getValueFromOpts: function(){
		// summary:
		//		Returns the value of the widget by reading the options for
		//		the selected flag
		var opts = this.getOptions() || [];
		if(!this.multiple && opts.length){
			// Mirror what a select does - choose the first one
			var opt = dojo.filter(opts, function(i){
				return i.selected;
			})[0];
			if(opt && opt.value){
				return opt.value
			}else{
				opts[0].selected = true;
				return opts[0].value;
			}
		}else if(this.multiple){
			// Set value to be the sum of all selected
			return dojo.map(dojo.filter(opts, function(i){
				return i.selected;
			}), function(i){
				return i.value;
			}) || [];
		}
		return "";
	},

	// Internal functions to call when we have store notifications come in
	_onNewItem: function(/* item */ item, /* Object? */ parentInfo){
		if(!parentInfo || !parentInfo.parent){
			// Only add it if we are top-level
			this._addOptionForItem(item);
		}
	},
	_onDeleteItem: function(/* item */ item){
		var store = this.store;
		this.removeOption(store.getIdentity(item));
	},
	_onSetItem: function(/* item */ item){
		this.updateOption(this._getOptionObjForItem(item));
	},

	_getOptionObjForItem: function(item){
		// summary:
		//		Returns an option object based off the given item.  The "value"
		//		of the option item will be the identity of the item, the "label"
		//		of the option will be the label of the item.  If the item contains
		//		children, the children value of the item will be set
		var store = this.store, label = store.getLabel(item),
			value = (label ? store.getIdentity(item) : null);
		return {value: value, label: label, item:item}; // dijit.form.__SelectOption
	},

	_addOptionForItem: function(/* item */ item){
		// summary:
		//		Creates (and adds) the option for the given item
		var store = this.store;
		if(!store.isItemLoaded(item)){
			// We are not loaded - so let's load it and add later
			store.loadItem({item: item, onComplete: function(i){
				this._addOptionForItem(item);
			},
			scope: this});
			return;
		}
		var newOpt = this._getOptionObjForItem(item);
		this.addOption(newOpt);
	},

	constructor: function(/* Object */ keywordArgs){
		// summary:
		//		Saves off our value, if we have an initial one set so we
		//		can use it if we have a store as well (see startup())
		this._oValue = (keywordArgs || {}).value || null;
	},

	_fillContent: function(){
		// summary:
		//		Loads our options and sets up our dropdown correctly.  We
		//		don't want any content, so we don't call any inherit chain
		//		function.
		var opts = this.options;
		if(!opts){
			opts = this.options = this.srcNodeRef ? dojo.query(">",
						this.srcNodeRef).map(function(node){
							if(node.getAttribute("type") === "separator"){
								return { value: "", label: "", selected: false, disabled: false };
							}
							return { value: node.getAttribute("value"),
										label: String(node.innerHTML),
										selected: node.getAttribute("selected") || false,
										disabled: node.getAttribute("disabled") || false };
						}, this) : [];
		}
		if(!this.value){
			this.value = this._getValueFromOpts();
		}else if(this.multiple && typeof this.value == "string"){
			this.value = this.value.split(",");
		}
	},

	postCreate: function(){
		// summary:
		//		sets up our event handling that we need for functioning
		//		as a select
		dojo.setSelectable(this.focusNode, false);
		this.inherited(arguments);

		// Make our event connections for updating state
		this.connect(this, "onChange", "_updateSelection");
		this.connect(this, "startup", "_loadChildren");

		this._setValueAttr(this.value, null);
	},

	startup: function(){
		// summary:
		//		Connects in our store, if we have one defined
		this.inherited(arguments);
		var store = this.store, fetchArgs = {};
		dojo.forEach(["query", "queryOptions", "onFetch"], function(i){
			if(this[i]){
				fetchArgs[i] = this[i];
			}
			delete this[i];
		}, this);
		if(store && store.getFeatures()["dojo.data.api.Identity"]){
			// Temporarily set our store to null so that it will get set
			// and connected appropriately
			this.store = null;
			this.setStore(store, this._oValue, fetchArgs);
		}
	},

	destroy: function(){
		// summary:
		//		Clean up our connections
		dojo.forEach(this._notifyConnections || [], dojo.disconnect);
		this.inherited(arguments);
	},

	_addOptionItem: function(/* dijit.form.__SelectOption */ option){
		// summary:
		//		User-overridable function which, for the given option, adds an
		//		item to the select.  If the option doesn't have a value, then a
		//		separator is added in that place.  Make sure to store the option
		//		in the created option widget.
	},

	_removeOptionItem: function(/* dijit.form.__SelectOption */ option){
		// summary:
		//		User-overridable function which, for the given option, removes
		//		its item from the select.
	},

	_setDisplay: function(/*String or String[]*/ newDisplay){
		// summary:
		//		Overridable function which will set the display for the
		//		widget.  newDisplay is either a string (in the case of
		//		single selects) or array of strings (in the case of multi-selects)
	},

	_getChildren: function(){
		// summary:
		//		Overridable function to return the children that this widget contains.
		return [];
	},

	_getSelectedOptionsAttr: function(){
		// summary:
		//		hooks into this.attr to provide a mechanism for getting the
		//		option items for the current value of the widget.
		return this.getOptions(this.attr("value"));
	},

	_pseudoLoadChildren: function(/* item[] */ items){
		// summary:
		//		a function that will "fake" loading children, if needed, and
		//		if we have set to not load children until the widget opens.
		// items:
		//		An array of items that will be loaded, when needed
	},

	onSetStore: function(){
		// summary:
		//		a function that can be connected to in order to receive a
		//		notification that the store has finished loading and all options
		//		from that store are available
	}
});

}

if(!dojo._hasResource["dijit.form.Select"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Select"] = true;
dojo.provide("dijit.form.Select");







dojo.declare("dijit.form._SelectMenu", dijit.Menu, {
	// summary:
	//		An internally-used menu for dropdown that allows us to more
	//		gracefully overflow our menu
	buildRendering: function(){
		// summary:
		//		Stub in our own changes, so that our domNode is not a table
		//		otherwise, we won't respond correctly to heights/overflows
		this.inherited(arguments);
		var o = (this.menuTableNode = this.domNode);
		var n = (this.domNode = dojo.doc.createElement("div"));
		if(o.parentNode){
			o.parentNode.replaceChild(n, o);
		}
		dojo.removeClass(o, "dijitMenuTable");
		n.className = o.className + " dijitSelectMenu";
		o.className = "dijitReset dijitMenuTable";
		dijit.setWaiRole(o,"listbox");
		dijit.setWaiRole(n,"presentation");
		n.appendChild(o);
		this.tabIndex=null; // so tabindex=0 does not get set on domNode (role="presentation" AND tabindex is invalid)
	},
	resize: function(/*Object*/ mb){
		// summary:
		//		Overridden so that we are able to handle resizing our
		//		internal widget.  Note that this is not a "full" resize
		//		implementation - it only works correctly if you pass it a
		//		marginBox.
		//
		// mb: Object
		//		The margin box to set this dropdown to.
		if(mb){
			dojo.marginBox(this.domNode, mb);
			var w = dojo.contentBox(this.domNode).w;
			if(dojo.isMoz && this.domNode.scrollHeight > this.domNode.clientHeight){
				w--;
			}else if(dojo.isIE < 8 || (dojo.isIE && dojo.isQuirks)){
				// IE < 8 and IE8 in quirks mode doesn't need this additional
				// width of the scrollbar...it causes a horizontal scroll bar
				// (as well as continually expanding the dropdown each time
				// it is opened)
				w -= 16;
			}
			dojo.marginBox(this.menuTableNode, {w: w});
		}
	}
});

dojo.declare("dijit.form.Select", [dijit.form._FormSelectWidget, dijit._HasDropDown], {
	// summary:
	//		This is a "styleable" select box - it is basically a DropDownButton which
	//		can take a <select> as its input.

	baseClass: "dijitSelect",

	templateString: dojo.cache("dijit.form", "templates/Select.html", "<table class='dijit dijitReset dijitInline dijitLeft'\r\n\tdojoAttachPoint=\"_buttonNode,tableNode\" cellspacing='0' cellpadding='0' waiRole=\"presentation\"\r\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\"\r\n\t><tbody waiRole=\"presentation\"><tr waiRole=\"presentation\"\r\n\t\t><td class=\"dijitReset dijitStretch dijitButtonContents dijitButtonNode\" dojoAttachPoint=\"focusNode\"\r\n\t\t\twaiRole=\"combobox\" waiState=\"haspopup-true\"\r\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"  dojoAttachPoint=\"containerNode,_popupStateNode\"></span\r\n\t\t\t><input type=\"hidden\" ${nameAttrSetting} dojoAttachPoint=\"valueNode\" value=\"${value}\" waiState=\"hidden-true\" />\r\n\t\t</td><td class=\"dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton\"\r\n\t\t\t\tdojoAttachPoint=\"titleNode\" waiRole=\"presentation\"\r\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" waiRole=\"presentation\">&thinsp;</div\r\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" waiRole=\"presentation\">&#9660;</div\r\n\t\t></td\r\n\t></tr></tbody\r\n></table>\r\n"),

	// attributeMap: Object
	//		Add in our style to be applied to the focus node
	attributeMap: dojo.mixin(dojo.clone(dijit.form._FormSelectWidget.prototype.attributeMap),{style:"tableNode"}),

	// required: Boolean
	//		Can be true or false, default is false.
	required: false,

	// state: String
	//		Shows current state (ie, validation result) of input (Normal, Warning, or Error)
	state: "",

	//	tooltipPosition: String[]
	//		See description of dijit.Tooltip.defaultPosition for details on this parameter.
	tooltipPosition: [],

	// emptyLabel: string
	//		What to display in an "empty" dropdown
	emptyLabel: "",

	// _isLoaded: Boolean
	//		Whether or not we have been loaded
	_isLoaded: false,

	// _childrenLoaded: Boolean
	//		Whether or not our children have been loaded
	_childrenLoaded: false,

	_fillContent: function(){
		// summary:
		//		Set the value to be the first, or the selected index
		this.inherited(arguments);
		if(this.options.length && !this.value && this.srcNodeRef){
			var si = this.srcNodeRef.selectedIndex;
			this.value = this.options[si != -1 ? si : 0].value;
		}

		// Create the dropDown widget
		this.dropDown = new dijit.form._SelectMenu();
		dojo.addClass(this.dropDown.domNode, this.baseClass + "Menu");
	},

	_getMenuItemForOption: function(/*dijit.form.__SelectOption*/ option){
		// summary:
		//		For the given option, return the menu item that should be
		//		used to display it.  This can be overridden as needed
		if(!option.value){
			// We are a separator (no label set for it)
			return new dijit.MenuSeparator();
		}else{
			// Just a regular menu option
			var click = dojo.hitch(this, "_setValueAttr", option);
			var item = new dijit.MenuItem({
				option: option,
				label: option.label,
				onClick: click,
				disabled: option.disabled || false
			});
			dijit.setWaiRole(item.focusNode, "listitem");
			return item;
		}
	},

	_addOptionItem: function(/*dijit.form.__SelectOption*/ option){
		// summary:
		//		For the given option, add an option to our dropdown.
		//		If the option doesn't have a value, then a separator is added
		//		in that place.
		if(this.dropDown){
			this.dropDown.addChild(this._getMenuItemForOption(option));
		}
	},

	_getChildren: function(){
		if(!this.dropDown){
			return [];
		}
		return this.dropDown.getChildren();
	},

	_loadChildren: function(/*Boolean*/ loadMenuItems){
		// summary:
		//		Resets the menu and the length attribute of the button - and
		//		ensures that the label is appropriately set.
		//	loadMenuItems: Boolean
		//		actually loads the child menu items - we only do this when we are
		//		populating for showing the dropdown.

		if(loadMenuItems === true){
			// this.inherited destroys this.dropDown's child widgets (MenuItems).
			// Avoid this.dropDown (Menu widget) having a pointer to a destroyed widget (which will cause
			// issues later in _setSelected). (see #10296)
			if(this.dropDown){
				delete this.dropDown.focusedChild;
			}
			if(this.options.length){
				this.inherited(arguments);
			}else{
				// Drop down menu is blank but add one blank entry just so something appears on the screen
				// to let users know that they are no choices (mimicing native select behavior)
				dojo.forEach(this._getChildren(), function(child){ child.destroyRecursive(); });
				var item = new dijit.MenuItem({label: "&nbsp;"});
				this.dropDown.addChild(item);
			}
		}else{
			this._updateSelection();
		}

		var len = this.options.length;
		this._isLoaded = false;
		this._childrenLoaded = true;

		if(!this._loadingStore){
			// Don't call this if we are loading - since we will handle it later
			this._setValueAttr(this.value);
		}
	},

	_setValueAttr: function(value){
		this.inherited(arguments);
		dojo.attr(this.valueNode, "value", this.attr("value"));
	},

	_setDisplay: function(/*String*/ newDisplay){
		// summary:
		//		sets the display for the given value (or values)
		this.containerNode.innerHTML = '<span class="dijitReset dijitInline ' + this.baseClass + 'Label">' +
					(newDisplay || this.emptyLabel || "&nbsp;") +
					'</span>';
		dijit.setWaiState(this.focusNode, "valuenow", (newDisplay || this.emptyLabel || "&nbsp;") );
	},

	validate: function(/*Boolean*/ isFocused){
		// summary:
		//		Called by oninit, onblur, and onkeypress.
		// description:
		//		Show missing or invalid messages if appropriate, and highlight textbox field.
		//		Used when a select is initially set to no value and the user is required to
		//		set the value.
		
		var isValid = this.isValid(isFocused);
		this.state = isValid ? "" : "Error";
		this._setStateClass();
		dijit.setWaiState(this.focusNode, "invalid", isValid ? "false" : "true");
		var message = isValid ? "" : this._missingMsg;
		if(this._message !== message){
			this._message = message;
			dijit.hideTooltip(this.domNode);
			if(message){
				dijit.showTooltip(message, this.domNode, this.tooltipPosition);
			}
		}
		return isValid;
	},

	isValid: function(/*Boolean*/ isFocused){
		// summary:
		//		Whether or not this is a valid value.   The only way a Select
		//		can be invalid is when it's required but nothing is selected.
		return (!this.required || !(/^\s*$/.test(this.value)));
	},

	reset: function(){
		// summary:
		//		Overridden so that the state will be cleared.
		this.inherited(arguments);
		dijit.hideTooltip(this.domNode);
		this.state = "";
		this._setStateClass();
		delete this._message;
	},

	postMixInProperties: function(){
		// summary:
		//		set the missing message
		this.inherited(arguments);
		this._missingMsg = dojo.i18n.getLocalization("dijit.form", "validate",
									this.lang).missingMessage;
	},

	postCreate: function(){
		this.inherited(arguments);
		if(this.tableNode.style.width){
			dojo.addClass(this.domNode, this.baseClass + "FixedWidth");
		}
	},

	isLoaded: function(){
		return this._isLoaded;
	},

	loadDropDown: function(/*Function*/ loadCallback){
		// summary:
		//		populates the menu
		this._loadChildren(true);
		this._isLoaded = true;
		loadCallback();
	},

	uninitialize: function(preserveDom){
		if(this.dropDown && !this.dropDown._destroyed){
			this.dropDown.destroyRecursive(preserveDom);
			delete this.dropDown;
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["dojox.form.PasswordValidator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.form.PasswordValidator"] = true;
dojo.provide("dojox.form.PasswordValidator");






dojo.declare("dojox.form._ChildTextBox", dijit.form.ValidationTextBox, {
	// summary:
	//		A class that is shared between all our children - extends 
	//		ValidationTextBox and provides some shared functionality
	//
	// containerWidget: widget
	//		Our parent (the PasswordValidator)
	containerWidget: null,
	
	// type: string
	//		Don't override this - we are all "password" types
	type: "password",
	
	reset: function(){
		// summary:
		//		Force-set to empty string (we don't save passwords EVER)...and 
		//		since _OldPWBox overrides _setValueAttr to check for empty string, 
		//		call our parent class directly (not this.inherited())
		dijit.form.ValidationTextBox.prototype._setValueAttr.call(this, "", true);
		this._hasBeenBlurred = false;
	},
	
	postCreate: function(){
		// summary:
		//		We want to remove the "name" attribute from our focus node if
		//		we don't have one set - this prevents all our extra values
		//		from being posted on submit
		this.inherited(arguments);
		if(!this.name){
			dojo.removeAttr(this.focusNode, "name");
		}
		this.connect(this.focusNode, "onkeypress", "_onChildKeyPress");
	},
	
	_onChildKeyPress: function(e){
		// Check if we pressed <enter> - if so, set our blur value so that
		// the parent widget will be updated correctly.
		if(e && e.keyCode == dojo.keys.ENTER){
			this._setBlurValue();
		}
	}
});



dojo.declare("dojox.form._OldPWBox", dojox.form._ChildTextBox, {
	// summary:
	//		A class representing our "old password" box.
	//
	// _isPWValid: boolean
	//		Whether or not the password is valid
	_isPWValid: false,
	
	_setValueAttr: function(/* anything */ newVal, /* boolean? */ priority){
		// summary:
		//		Updates _isPWValid if this isn't our initial update by calling
		//		our PasswordValidator's pwCheck function
		if(newVal === ""){
			newVal = dojox.form._OldPWBox.superclass.attr.call(this, "value");
		}
		if(priority !== null){
			//  Priority is passed in as null, explicitly when this is an 
			//	update (not initially set).  We want to check our password now.
			this._isPWValid = this.containerWidget.pwCheck(newVal);
		}
		this.inherited(arguments);
		// Trigger the containerWidget to recheck its value, if needed
		this.containerWidget._childValueAttr(this.containerWidget._inputWidgets[1].attr("value"));
	},

	isValid: function(/* boolean */ isFocused){
		// Take into account the isPWValid setting
		return this.inherited("isValid", arguments) && this._isPWValid;
	},

	_update: function(/* event */ e){
		// Only call validate() if we've been blurred or else we get popups 
		// too early.
		if(this._hasBeenBlurred){ this.validate(true); }
		this._onMouse(e);
	},

	_getValueAttr: function(){
		if(this.containerWidget._started && this.containerWidget.isValid()){
			return this.inherited(arguments);
		}
		return "";
	},

	_setBlurValue: function(){
		// TextBox._setBlurValue calls this._setValueAttr(this.attr('value'), ...)
		// Because we are overridding _getValueAttr to return "" when the containerWidget
		// is not valid, TextBox._setBlurValue will cause OldPWBox's value to be set to ""
		//
		// So, we directly call ValidationTextBox._getValueAttr to bypass our _getValueAttr
		var value = dijit.form.ValidationTextBox.prototype._getValueAttr.call(this);
		this._setValueAttr(value, (this.isValid ? this.isValid() : true));
	}
});


dojo.declare("dojox.form._NewPWBox", dojox.form._ChildTextBox, {
	// summary:
	//		A class representing our new password textbox

	// required: boolean
	//		Whether or not this widget is required (default: true)
	required: true,
	
	onChange: function(){
		// summary:
		//		Validates our verify box - to make sure that a change to me is
		//		reflected there
		this.containerWidget._inputWidgets[2].validate(false);
		this.inherited(arguments);
	}
});

dojo.declare("dojox.form._VerifyPWBox", dojox.form._ChildTextBox, {
	// summary:
	//		A class representing our verify textbox

	isValid: function(isFocused){
		// summary:
		//		Validates that we match the "real" password
		return this.inherited("isValid", arguments) &&
			(this.attr("value") == this.containerWidget._inputWidgets[1].attr("value"));
	}
});

dojo.declare("dojox.form.PasswordValidator", dijit.form._FormValueWidget, {
	// summary:
	//		A password validation widget that simplifies the "old/new/verify" 
	//		style of requesting passwords.  You will probably want to override
	//		this class and implement your own pwCheck function.
	//
	// required: boolean
	//		Whether or not it is required for form submission
	required: true,
	
	// inputWidgets: TextBox[]
	//		An array of text boxes that are our components
	_inputWidgets: null,

	// oldName: string?
	//		The name to send our old password as (when form is posted)
	oldName: "",
	
	templateString: dojo.cache("dojox.form", "resources/PasswordValidator.html", "<div dojoAttachPoint=\"containerNode\">\r\n\t<input type=\"hidden\" name=\"${name}\" value=\"\" dojoAttachPoint=\"focusNode\" />\r\n</div>\r\n"),
	
	_hasBeenBlurred: false,

	isValid: function(/* boolean */ isFocused){
		// summary: we are valid if ALL our children are valid
		return dojo.every(this._inputWidgets, function(i){
			if(i && i._setStateClass){ i._setStateClass(); }
			return (!i || i.isValid());
		});
	},

	validate: function(/* boolean */ isFocused){
		// summary: Validating this widget validates all our children
		return dojo.every(dojo.map(this._inputWidgets, function(i){
			if(i && i.validate){
				i._hasBeenBlurred = (i._hasBeenBlurred || this._hasBeenBlurred);
				return i.validate();
			}
			return true;
		}, this), "return item;");
	},

	reset: function(){
		// summary: Resetting this widget resets all our children
		this._hasBeenBlurred = false;
		dojo.forEach(this._inputWidgets, function(i){
			if(i && i.reset){ i.reset(); }
		}, this);
	},

	_createSubWidgets: function(){
		// summary:
		//		Turns the inputs inside this widget into "real" validation
		//		widgets - and sets up the needed connections.
		var widgets = this._inputWidgets,
			msg = dojo.i18n.getLocalization("dojox.form", "PasswordValidator", 
																	this.lang);
		dojo.forEach(widgets, function(i, idx){
			if(i){
				var p = {containerWidget: this}, c;
				if(idx === 0){
					p.name = this.oldName;
					p.invalidMessage = msg.badPasswordMessage;
					c = dojox.form._OldPWBox;
				}else if(idx === 1){
					p.required = this.required;
					c = dojox.form._NewPWBox;
				}else if(idx === 2){
					p.invalidMessage = msg.nomatchMessage;
					c = dojox.form._VerifyPWBox;
				}
				widgets[idx] = new c(p, i);
			}
		}, this);	
	},

	pwCheck: function(/* string */ password){ 
		// summary:
		//		Overridable function for validation of the old password box.
		//
		//		This function is called and passed the old password.  Return
		//		true if it's OK to continue, and false if it is not.
		//		
		//		IMPORTANT SECURITY NOTE:  Do NOT EVER EVER EVER check this in
		//									HTML or JavaScript!!!
		//
		//		You will probably want to override this function to callback 
		//		to a server to verify the password (the callback will need to 
		//		be syncronous) - and it's probably a good idea to validate
		//		it again on form submission before actually doing
		//		anything destructive - that's why the "oldName" value 
		//		is available.
		//
		//		And don't just fetch the password from the server 
		//		either :)  Send the test password (probably hashed, for
		//		security) and return from the server a status instead.
		//				
		//		Again - DON'T BE INSECURE!!!  Security is left as an exercise 
		//		for the reader :)
		return false; 
	},

	postCreate: function(){
		//	summary:
		//		Sets up the correct widgets.  You *MUST* specify one child
		//		text box (a simple HTML <input> element) with pwType="new" 
		//		*and* one child text box with pwType="verify".  You *MAY* 
		//		specify a third child text box with pwType="old" in order to 
		//		prompt the user to enter in their old password before the 
		//		widget returns that it is valid.
		
		this.inherited(arguments);
		
		// Turn my inputs into the correct stuff....
		var widgets = this._inputWidgets = [];
		dojo.forEach(["old","new","verify"], function(i){
			widgets.push(dojo.query("input[pwType=" + i + "]", 
									this.containerNode)[0]);
		}, this);
		if (!widgets[1] || !widgets[2]){
			throw new Error("Need at least pwType=\"new\" and pwType=\"verify\"");
		}
		if (this.oldName && !widgets[0]){
			throw new Error("Need to specify pwType=\"old\" if using oldName");
		}
		this.containerNode = this.domNode;
		this._createSubWidgets();
		this.connect(this._inputWidgets[1], "_setValueAttr", "_childValueAttr");
		this.connect(this._inputWidgets[2], "_setValueAttr", "_childValueAttr");		
	},
	
	_childValueAttr: function(v){
		this.attr("value", this.isValid() ? v : "");
	},
	
	_setDisabledAttr: function(value){
		this.inherited(arguments);
		dojo.forEach(this._inputWidgets, function(i){
			if(i && i.attr){ i.attr("disabled", value);}
		});
	},
	
	_setRequiredAttribute: function(value){
		this.required = value;
		dojo.attr(this.focusNode, "required", value);
		dijit.setWaiState(this.focusNode, "required", value);
		this._refreshState();
		dojo.forEach(this._inputWidgets, function(i){
			if(i && i.attr){ i.attr("required", value);}
		});
	},

	_setValueAttr: function(v){
		this.inherited(arguments);
		dojo.attr(this.focusNode, "value", v);
	},
	
	_getValueAttr: function(){
		// Make sure we don't return undefined....
		return this.inherited(arguments)||"";
	},
	
	focus: function(){
		// summary: 
		//		places focus on the first invalid input widget - if all
		//		input widgets are valid, the first widget is focused.
		var f = false;
		dojo.forEach(this._inputWidgets, function(i){
			if(i && !i.isValid() && !f){
				i.focus();
				f = true;
			}
		});
		if(!f){ this._inputWidgets[1].focus(); }
	}
});

}

if(!dojo._hasResource["dijit.InlineEditBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.InlineEditBox"] = true;
dojo.provide("dijit.InlineEditBox");










dojo.declare("dijit.InlineEditBox",
	dijit._Widget,
	{
	// summary:
	//		An element with in-line edit capabilitites
	//
	// description:
	//		Behavior for an existing node (`<p>`, `<div>`, `<span>`, etc.) so that
	// 		when you click it, an editor shows up in place of the original
	//		text.  Optionally, Save and Cancel button are displayed below the edit widget.
	//		When Save is clicked, the text is pulled from the edit
	//		widget and redisplayed and the edit widget is again hidden.
	//		By default a plain Textarea widget is used as the editor (or for
	//		inline values a TextBox), but you can specify an editor such as
	//		dijit.Editor (for editing HTML) or a Slider (for adjusting a number).
	//		An edit widget must support the following API to be used:
	//			- displayedValue or value as initialization parameter,
	//			and available through attr('displayedValue') / attr('value')
	//			- void focus()
	//			- DOM-node focusNode = node containing editable text

	// editing: [readonly] Boolean
	//		Is the node currently in edit mode?
	editing: false,

	// autoSave: Boolean
	//		Changing the value automatically saves it; don't have to push save button
	//		(and save button isn't even displayed)
	autoSave: true,

	// buttonSave: String
	//		Save button label
	buttonSave: "",

	// buttonCancel: String
	//		Cancel button label
	buttonCancel: "",

	// renderAsHtml: Boolean
	//		Set this to true if the specified Editor's value should be interpreted as HTML
	//		rather than plain text (ex: `dijit.Editor`)
	renderAsHtml: false,

	// editor: String
	//		Class name for Editor widget
	editor: "dijit.form.TextBox",

	// editorWrapper: String
	//		Class name for widget that wraps the editor widget, displaying save/cancel
	//		buttons.
	editorWrapper: "dijit._InlineEditor",

	// editorParams: Object
	//		Set of parameters for editor, like {required: true}
	editorParams: {},

	onChange: function(value){
		// summary:
		//		Set this handler to be notified of changes to value.
		// tags:
		//		callback
	},

	onCancel: function(){
		// summary:
		//		Set this handler to be notified when editing is cancelled.
		// tags:
		//		callback
	},

	// width: String
	//		Width of editor.  By default it's width=100% (ie, block mode).
	width: "100%",

	// value: String
	//		The display value of the widget in read-only mode
	value: "",

	// noValueIndicator: [const] String
	//		The text that gets displayed when there is no value (so that the user has a place to click to edit)
	noValueIndicator: "<span style='font-family: wingdings; text-decoration: underline;'>&nbsp;&nbsp;&nbsp;&nbsp;&#x270d;&nbsp;&nbsp;&nbsp;&nbsp;</span>",

	constructor: function(){
		// summary:
		//		Sets up private arrays etc.
		// tags:
		//		private
		this.editorParams = {};
	},

	postMixInProperties: function(){
		this.inherited(arguments);

		// save pointer to original source node, since Widget nulls-out srcNodeRef
		this.displayNode = this.srcNodeRef;

		// connect handlers to the display node
		var events = {
			ondijitclick: "_onClick",
			onmouseover: "_onMouseOver",
			onmouseout: "_onMouseOut",
			onfocus: "_onMouseOver",
			onblur: "_onMouseOut"
		};
		for(var name in events){
			this.connect(this.displayNode, name, events[name]);
		}
		dijit.setWaiRole(this.displayNode, "button");
		if(!this.displayNode.getAttribute("tabIndex")){
			this.displayNode.setAttribute("tabIndex", 0);
		}

		this.attr('value', this.value || this.displayNode.innerHTML);
	},

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated.   Use attr('disable', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.setDisabled() is deprecated.  Use attr('disabled', bool) instead.", "", "2.0");
		this.attr('disabled', disabled);
	},

	_setDisabledAttr: function(/*Boolean*/ disabled){
		// summary:
		//		Hook to make attr("disabled", ...) work.
		//		Set disabled state of widget.
		this.disabled = disabled;
		dijit.setWaiState(this.domNode, "disabled", disabled);
		if(disabled){
			this.displayNode.removeAttribute("tabIndex");
		}else{
			this.displayNode.setAttribute("tabIndex", 0);
		}
	},

	_onMouseOver: function(){
		// summary:
		//		Handler for onmouseover event.
		// tags:
		//		private
		dojo.addClass(this.displayNode, this.disabled ? "dijitDisabledClickableRegion" : "dijitClickableRegion");
	},

	_onMouseOut: function(){
		// summary:
		//		Handler for onmouseout event.
		// tags:
		//		private
		dojo.removeClass(this.displayNode, this.disabled ? "dijitDisabledClickableRegion" : "dijitClickableRegion");
	},

	_onClick: function(/*Event*/ e){
		// summary:
		//		Handler for onclick event.
		// tags:
		//		private
		if(this.disabled){ return; }
		if(e){ dojo.stopEvent(e); }
		this._onMouseOut();

		// Since FF gets upset if you move a node while in an event handler for that node...
		setTimeout(dojo.hitch(this, "edit"), 0);
	},

	edit: function(){
		// summary:
		//		Display the editor widget in place of the original (read only) markup.
		// tags:
		//		private

		if(this.disabled || this.editing){ return; }
		this.editing = true;

		// save some display node values that can be restored later
		this._savedPosition = dojo.style(this.displayNode, "position") || "static";
		this._savedOpacity = dojo.style(this.displayNode, "opacity") || "1";
		this._savedTabIndex = dojo.attr(this.displayNode, "tabIndex") || "0";

		if(this.wrapperWidget){
			this.wrapperWidget.editWidget.attr("displayedValue" in this.editorParams ? "displayedValue" : "value", this.value);
		}else{
			// Placeholder for edit widget
			// Put place holder (and eventually editWidget) before the display node so that it's positioned correctly
			// when Calendar dropdown appears, which happens automatically on focus.
			var placeholder = dojo.create("span", null, this.domNode, "before");

			// Create the editor wrapper (the thing that holds the editor widget and the save/cancel buttons)
			var ewc = dojo.getObject(this.editorWrapper);
			this.wrapperWidget = new ewc({
				value: this.value,
				buttonSave: this.buttonSave,
				buttonCancel: this.buttonCancel,
				tabIndex: this._savedTabIndex,
				editor: this.editor,
				inlineEditBox: this,
				sourceStyle: dojo.getComputedStyle(this.displayNode),
				save: dojo.hitch(this, "save"),
				cancel: dojo.hitch(this, "cancel")
			}, placeholder);
		}
		var ww = this.wrapperWidget;

		if(dojo.isIE){
			dijit.focus(dijit.getFocus()); // IE (at least 8) needs help with tab order changes
		}
		// to avoid screen jitter, we first create the editor with position:absolute, visibility:hidden,
		// and then when it's finished rendering, we switch from display mode to editor
		// position:absolute releases screen space allocated to the display node
		// opacity:0 is the same as visibility:hidden but is still focusable
		// visiblity:hidden removes focus outline

		dojo.style(this.displayNode, { position: "absolute", opacity: "0", display: "none" }); // makes display node invisible, display style used for focus-ability
		dojo.style(ww.domNode, { position: this._savedPosition, visibility: "visible", opacity: "1" });
		dojo.attr(this.displayNode, "tabIndex", "-1"); // needed by WebKit for TAB from editor to skip displayNode

		// Replace the display widget with edit widget, leaving them both displayed for a brief time so that
		// focus can be shifted without incident.  (browser may needs some time to render the editor.)
		setTimeout(dojo.hitch(this, function(){
			ww.focus(); // both nodes are showing, so we can switch focus safely
			ww._resetValue = ww.getValue();
		}), 0);
	},

	_onBlur: function(){
		// summary:
		//		Called when focus moves outside the InlineEditBox.
		//		Performs garbage collection.
		// tags:
		//		private

		this.inherited(arguments);
		if(!this.editing){
			setTimeout(dojo.hitch(this, function(){
				if(this.wrapperWidget){
					this.wrapperWidget.destroy();
					delete this.wrapperWidget;
				}
			}), 0);
		}
	},

	_showText: function(/*Boolean*/ focus){
		// summary:
		//		Revert to display mode, and optionally focus on display node
		// tags:
		//		private

		var ww = this.wrapperWidget;
		dojo.style(ww.domNode, { position: "absolute", visibility: "hidden", opacity: "0" }); // hide the editor from mouse/keyboard events
		dojo.style(this.displayNode, { position: this._savedPosition, opacity: this._savedOpacity, display: "" }); // make the original text visible
		dojo.attr(this.displayNode, "tabIndex", this._savedTabIndex);
		if(focus){
			dijit.focus(this.displayNode);
		}
	},

	save: function(/*Boolean*/ focus){
		// summary:
		//		Save the contents of the editor and revert to display mode.
		// focus: Boolean
		//		Focus on the display mode text
		// tags:
		//		private

		if(this.disabled || !this.editing){ return; }
		this.editing = false;

		var ww = this.wrapperWidget;
		var value = ww.getValue();
		this.attr('value', value); // display changed, formatted value

		// tell the world that we have changed
		setTimeout(dojo.hitch(this, "onChange", value), 0); // setTimeout prevents browser freeze for long-running event handlers

		this._showText(focus); // set focus as needed
	},

	setValue: function(/*String*/ val){
		// summary:
		//		Deprecated.   Use attr('value', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.setValue() is deprecated.  Use attr('value', ...) instead.", "", "2.0");
		return this.attr("value", val);
	},

	_setValueAttr: function(/*String*/ val){
		// summary:
		// 		Hook to make attr("value", ...) work.
		//		Inserts specified HTML value into this node, or an "input needed" character if node is blank.

		this.value = val = dojo.trim(val);
		if(!this.renderAsHtml){
			val = val.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;").replace(/\n/g, "<br>");
		}
		this.displayNode.innerHTML = val || this.noValueIndicator;
	},

	getValue: function(){
		// summary:
		//		Deprecated.   Use attr('value') instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.getValue() is deprecated.  Use attr('value') instead.", "", "2.0");
		return this.attr("value");
	},

	cancel: function(/*Boolean*/ focus){
		// summary:
		//		Revert to display mode, discarding any changes made in the editor
		// tags:
		//		private

		if(this.disabled || !this.editing){ return; }
		this.editing = false;

		// tell the world that we have no changes
		setTimeout(dojo.hitch(this, "onCancel"), 0); // setTimeout prevents browser freeze for long-running event handlers

		this._showText(focus);
	}
});

dojo.declare(
	"dijit._InlineEditor",
	 [dijit._Widget, dijit._Templated],
{
	// summary:
	// 		Internal widget used by InlineEditBox, displayed when in editing mode
	//		to display the editor and maybe save/cancel buttons.  Calling code should
	//		connect to save/cancel methods to detect when editing is finished
	//
	//		Has mainly the same parameters as InlineEditBox, plus these values:
	//
	// style: Object
	//		Set of CSS attributes of display node, to replicate in editor
	//
	// value: String
	//		Value as an HTML string or plain text string, depending on renderAsHTML flag

	templateString: dojo.cache("dijit", "templates/InlineEditBox.html", "<span dojoAttachPoint=\"editNode\" waiRole=\"presentation\" style=\"position: absolute; visibility:hidden\" class=\"dijitReset dijitInline\"\r\n\tdojoAttachEvent=\"onkeypress: _onKeyPress\"\r\n\t><span dojoAttachPoint=\"editorPlaceholder\"></span\r\n\t><span dojoAttachPoint=\"buttonContainer\"\r\n\t\t><button class='saveButton' dojoAttachPoint=\"saveButton\" dojoType=\"dijit.form.Button\" dojoAttachEvent=\"onClick:save\" label=\"${buttonSave}\"></button\r\n\t\t><button class='cancelButton' dojoAttachPoint=\"cancelButton\" dojoType=\"dijit.form.Button\" dojoAttachEvent=\"onClick:cancel\" label=\"${buttonCancel}\"></button\r\n\t></span\r\n></span>\r\n"),
	widgetsInTemplate: true,

	postMixInProperties: function(){
		this.inherited(arguments);
		this.messages = dojo.i18n.getLocalization("dijit", "common", this.lang);
		dojo.forEach(["buttonSave", "buttonCancel"], function(prop){
			if(!this[prop]){ this[prop] = this.messages[prop]; }
		}, this);
	},

	postCreate: function(){
		// Create edit widget in place in the template
		var cls = dojo.getObject(this.editor);

		// Copy the style from the source
		// Don't copy ALL properties though, just the necessary/applicable ones
		var srcStyle = this.sourceStyle;
		var editStyle = "line-height:" + srcStyle.lineHeight + ";";
		dojo.forEach(["Weight","Family","Size","Style"], function(prop){
			editStyle += "font-"+prop+":"+srcStyle["font"+prop]+";";
		}, this);
		dojo.forEach(["marginTop","marginBottom","marginLeft", "marginRight"], function(prop){
			this.domNode.style[prop] = srcStyle[prop];
		}, this);
		var width = this.inlineEditBox.width;
		if(width == "100%"){
			// block mode
			editStyle += "width:100%;";
			this.domNode.style.display = "block";
		}else{
			// inline-block mode
			editStyle += "width:" + (width + (Number(width) == width ? "px" : "")) + ";";
		}
		var editorParams = this.inlineEditBox.editorParams;
		editorParams.style = editStyle;
		editorParams[ "displayedValue" in cls.prototype ? "displayedValue" : "value"] = this.value;
		var ew = this.editWidget = new cls(editorParams, this.editorPlaceholder);

		if(this.inlineEditBox.autoSave){
			// Hide the save/cancel buttons since saving is done by simply tabbing away or
			// selecting a value from the drop down list
			this.buttonContainer.style.display="none";

			// Selecting a value from a drop down list causes an onChange event and then we save
			this.connect(ew, "onChange", "_onChange");

			// ESC and TAB should cancel and save.  Note that edit widgets do a stopEvent() on ESC key (to
			// prevent Dialog from closing when the user just wants to revert the value in the edit widget),
			// so this is the only way we can see the key press event.
			this.connect(ew, "onKeyPress", "_onKeyPress");
		}else{
			// If possible, enable/disable save button based on whether the user has changed the value
			if("intermediateChanges" in cls.prototype){
				ew.attr("intermediateChanges", true);
				this.connect(ew, "onChange", "_onIntermediateChange");
				this.saveButton.attr("disabled", true);
			}
		}
	},

	_onIntermediateChange: function(val){
		// summary:
		//		Called for editor widgets that support the intermediateChanges=true flag as a way
		//		to detect when to enable/disabled the save button
		this.saveButton.attr("disabled", (this.getValue() == this._resetValue) || !this.enableSave());
	},

	destroy: function(){
		this.editWidget.destroy(true); // let the parent wrapper widget clean up the DOM
		this.inherited(arguments);
	},

	getValue: function(){
		// summary:
		//		Return the [display] value of the edit widget
		var ew = this.editWidget;
		return String(ew.attr("displayedValue" in ew ? "displayedValue" : "value"));
	},

	_onKeyPress: function(e){
		// summary:
		//		Handler for keypress in the edit box in autoSave mode.
		// description:
		//		For autoSave widgets, if Esc/Enter, call cancel/save.
		// tags:
		//		private

		if(this.inlineEditBox.autoSave && this.inlineEditBox.editing){
			if(e.altKey || e.ctrlKey){ return; }
			// If Enter/Esc pressed, treat as save/cancel.
			if(e.charOrCode == dojo.keys.ESCAPE){
				dojo.stopEvent(e);
				this.cancel(true); // sets editing=false which short-circuits _onBlur processing
			}else if(e.charOrCode == dojo.keys.ENTER && e.target.tagName == "INPUT"){
				dojo.stopEvent(e);
				this._onChange(); // fire _onBlur and then save
			}

			// _onBlur will handle TAB automatically by allowing
			// the TAB to change focus before we mess with the DOM: #6227
			// Expounding by request:
			// 	The current focus is on the edit widget input field.
			//	save() will hide and destroy this widget.
			//	We want the focus to jump from the currently hidden
			//	displayNode, but since it's hidden, it's impossible to
			//	unhide it, focus it, and then have the browser focus
			//	away from it to the next focusable element since each
			//	of these events is asynchronous and the focus-to-next-element
			//	is already queued.
			//	So we allow the browser time to unqueue the move-focus event
			//	before we do all the hide/show stuff.
		}
	},

	_onBlur: function(){
		// summary:
		//		Called when focus moves outside the editor
		// tags:
		//		private

		this.inherited(arguments);
		if(this.inlineEditBox.autoSave && this.inlineEditBox.editing){
			if(this.getValue() == this._resetValue){
				this.cancel(false);
			}else if(this.enableSave()){
				this.save(false);
			}
		}
	},

	_onChange: function(){
		// summary:
		//		Called when the underlying widget fires an onChange event,
		//		such as when the user selects a value from the drop down list of a ComboBox,
		//		which means that the user has finished entering the value and we should save.
		// tags:
		//		private

		if(this.inlineEditBox.autoSave && this.inlineEditBox.editing && this.enableSave()){
			dojo.style(this.inlineEditBox.displayNode, { display: "" });
			dijit.focus(this.inlineEditBox.displayNode); // fires _onBlur which will save the formatted value
		}
	},

	enableSave: function(){
		// summary:
		//		User overridable function returning a Boolean to indicate
		// 		if the Save button should be enabled or not - usually due to invalid conditions
		// tags:
		//		extension
		return (
			this.editWidget.isValid
			? this.editWidget.isValid()
			: true
		);
	},

	focus: function(){
		// summary:
		//		Focus the edit widget.
		// tags:
		//		protected

		this.editWidget.focus();
		setTimeout(dojo.hitch(this, function(){
			if(this.editWidget.focusNode.tagName == "INPUT"){
				dijit.selectInputText(this.editWidget.focusNode);
			}
		}), 0);
	}
});

}

if(!dojo._hasResource["com.copacabana.DeclarativeTemplate"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.DeclarativeTemplate"] = true;
dojo.provide("com.copacabana.DeclarativeTemplate");


dojo.declare("com.copacabana.DeclarativeTemplate", null, {

buildRendering: function(){
	console.log('buildRendering');
	
		if(!this.srcNodeRef || this.srcNodeRef.children.length==0){

			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			// Lookup cached version of template, and download to cache if it
			// isn't there already.  Returns either a DomNode or a string, depending on
			// whether or not the template contains ${foo} replacement parameters.
			var cached = dijit._Templated.getCachedTemplate(this.templatePath, this.templateString, this._skipNodeCache);

			var node;
			if(dojo.isString(cached)){
				node = dojo._toDom(this._stringRepl(cached));
				if(node.nodeType != 1){
					// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
					throw new Error("Invalid template: " + cached);
				}
			}else{
				// if it's a node, all we have to do is clone it
				node = cached.cloneNode(true);
			}

			this.domNode = node;

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(node);

			if(this.widgetsInTemplate){
				// Make sure dojoType is used for parsing widgets in template.
				// The dojo.parser.query could be changed from multiversion support.
				var parser = dojo.parser, qry, attr;
				if(parser._query != "[dojoType]"){
					qry = parser._query;
					attr = parser._attrName;
					parser._query = "[dojoType]";
					parser._attrName = "dojoType";
				}

				// Store widgets that we need to start at a later point in time
				var cw = (this._startupWidgets = dojo.parser.parse(node, {
					noStart: !this._earlyTemplatedStartup,
					inherited: {dir: this.dir, lang: this.lang}
				}));

				// Restore the query.
				if(qry){
					parser._query = qry;
					parser._attrName = attr;
				}

				this._supportingWidgets = dijit.findWidgets(node);

				this._attachTemplateNodes(cw, function(n,p){
					return n[p];
				});
			}

			this._fillContent(this.srcNodeRef);
		
		}else{
			this.initializeWithExistingDom();
		}
	},
	existingDom:false,
	initializeWithExistingDom:function(){
		this.existingDom=true;
		this.domNode=this.srcNodeRef;
		
	}

});

}

if(!dojo._hasResource["com.copacabana.RoundedButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.RoundedButton"] = true;
dojo.provide("com.copacabana.RoundedButton");








//I18N


 
//

dojo.declare("com.copacabana.RoundedButton", 	
		[dijit._Widget, dijit._Templated, dijit._Container], {
	//i18nStrings: dojo.i18n.getLocalization("com.copacabana", "PlatesListWidgetStrings"),
	templateString:"<div class=\"roundedInputDojo ${inputType}\" style=\"display:inline;cursor:pointer; height:${height}px;width:${width}px;\" dojoAttachEvent=\"onclick:onToolButtonClick\">\t\r\n\t<img src=\"${backgroundImage}\" height=\"${height}\" width=\"${width}\" style=\"cursor: pointer;\"/>\r\n\t<input  type=\"${inputType}\" \r\n\t\tstyle=\"height:${height}px;width:${width}px;cursor: pointer;left:${leftCss};top:${topCss}\"\r\n\t\tname=\"${inputName}\"\r\n\t\tclass=\"${cssClass}\"\r\n\t\tvalue=\"${inputValue}\" />\r\n</div>\r\n",
	constructor : function() {
	
	},
	onClickUp:function(evt){
		console.log("asdfasf");
	},
	height:20,
	leftCss:"-110px" ,
	topCss:"-5px;",
	height:20,
	width:100,
	inputType:"text",
	cssClass:"",
	inputName:"",
	inputValue:"",
	clickAction:null,
	//backgroundImage:"/resources/img/campo250px.png",
	backgroundImage:"/resources/img/botao100px.png",
	

	postMixInProperties : function() {
		this.inherited(arguments);
	},

	postCreate : function() {
		this.inherited(arguments);	
		this.panels = dojo.query(".widgetPanel", this.domNode);
		this.panels.forEach(function(item,idx,arr){
			item.buttonIcon = dojo.attr(item, "buttonIcon");
			item.buttonText = dojo.attr(item, "buttonText");
		});

	},
	onToolButtonClick:function(evt){
		this.clickAction(evt);
	},
	
	headerNode:null,
	resultsNode:null,
	startup : function() {
		try {
			dojo.parser.parse(this.domNode);
			
//			this.headerNode = dojo.query(".resultadoMensagem",this.domNode)[0];
//			this.resultsNode = dojo.query(".resultsList",this.domNode)[0];
//			this.imageNode =  document.createElement('img');
//			this.imageNode.src = dojo.moduleUrl("com.copacabana", "images/loader.gif");
//			this.imageNode.alt="executing search";
//			this.imageNode.title="executing search";
			
		} catch (e) {
console.error("rounded button start",e);
		}
	}
	
});

}

if(!dojo._hasResource["com.copacabana.MessageWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.MessageWidget"] = true;
dojo.provide("com.copacabana.MessageWidget");









dojo.declare("com.copacabana.MessageWidget",
		[ dijit._Widget, dijit._Templated ], {
			errorType:1,
			i18nString : null,
			title : "",
			url : null,
			templateString:"<div >\r\n\r\n</div>\r\n",
			constructor : function() {
			},

			postMixInProperties : function() {
				this.inherited(arguments);
			},
			textNode : null,
			dialog:null,
			postCreate : function() {
				this.inherited(arguments);
				dojo.parser.parse(this.domNode);
				//this.dialog = dijit.byId('msgDialog');				
				//this.textNode=dojo.query(".msgPlace",this.dialog.domNode)[0];
			},

			startup : function() {
			},
			callback:function(val,e){
				console.log(val,e);
			},
			
			
			promptInputCallback:function(mouseEvent,errorDialog,inputText,callbackFn) {
				var text = inputText.attr('value');				
				errorDialog.hide();
				errorDialog.destroyRecursive();
				if (window.event){
					e = window.event;
				}else{
					e=mouseEvent;
				}

				var srcEl = mouseEvent.srcElement? mouseEvent.srcElement : mouseEvent.target; //IE or Firefox
				console.log(srcEl.id,callbackFn);				
				callbackFn(text);				
			},
			
			promptInputMsg:function(question,callbackFn,title,initialValue){
				var errorDialog = this.createDialog(title);
				
				var questionDiv = dojo.create('div', { innerHTML: question });
				errorDialog.containerNode.appendChild(questionDiv);
				if(!initialValue){
					initialValue='';	
				}
				var inputText = new dijit.form.TextBox({ name: 'input' ,className:'textInput',value:initialValue});
				errorDialog.containerNode.appendChild(inputText.domNode);
				var fct = dojo.hitch(this,function(mouseEvent){
					this.promptInputCallback(mouseEvent,errorDialog,inputText,callbackFn);
				});
				var yesButton = new dijit.form.Button({ label: "Ok", id: 'ok', onClick:  fct});
				errorDialog.containerNode.appendChild(yesButton.domNode);
				errorDialog.show();
			},	
			
			promptMsg:function(question,possibleVals,callbackFn,title){
				//var errorDialog = new dijit.Dialog({ id: 'queryDialog', title: title });
				var errorDialog = this.createDialog(title);
				var callback = function(mouseEvent) {
					errorDialog.hide();
					errorDialog.destroyRecursive();
					if (window.event){
						e = window.event;
					}else{
						e=mouseEvent;
					}
					var srcEl = mouseEvent.srcElement? mouseEvent.srcElement : mouseEvent.target; //IE or Firefox
					console.log(srcEl);
					var id=srcEl.id;
					if(id=='yes_label'){
						id='yes';
					}else{
						if(id=='no_label'){
							id='no';
						}	
					}
					callbackFn( id, e);
				};
				var questionDiv = dojo.create('div', { innerHTML: question });
				errorDialog.containerNode.appendChild(questionDiv);
				for ( var i = 0; i < possibleVals.length; i++) {
					var questionItem = possibleVals[i];
					var yesButton = new dijit.form.Button({ label: questionItem.label, id: questionItem.id, onClick: callback });
					errorDialog.containerNode.appendChild(yesButton.domNode);
				}
				errorDialog.show();
			},		
			counter:0,
			createDialog:function(title){
				
				var errorDialog = new dijit.Dialog({ id: 'showMsgDialog'+(this.id), title: '',onHide:function(){this.destroyRecursive();}});

				
				return errorDialog;
			},
			showMsg:function(text,type){
				
				var errorDialog = this.createDialog('');
				var closeCallback = function(mouseEvent) {
					console.log('close',mouseEvent);
					errorDialog.hide();
					errorDialog.destroyRecursive();
				};
				var questionDiv = dojo.create('div', { innerHTML: text });
				var yesButton = new dijit.form.Button({ label: 'Ok', id: 'ok', onClick: closeCallback });
				errorDialog.containerNode.appendChild(questionDiv);
				errorDialog.containerNode.appendChild(yesButton.domNode);				
				errorDialog.show();
			

					
			},
			destroyRecursive : function() {
				try{
				console.log("destroying");
				dojo.forEach(this.getDescendants(), function(widget) {
					console.log("destroying . ",widget);
					widget.destroyRecursive();
				});
				this.inherited(arguments);
				
					this.dialog.destroy();
				}catch(e){
					
					console.error("messageW",e);
				}
			}
			

		});

}

if(!dojo._hasResource["com.copacabana.util"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.util"] = true;
dojo.provide("com.copacabana.util");



com.copacabana.util.moneyFormatter=function(value,sym){
	var symbol = 'R$ ';
	if(sym){
		symbol=sym;
	}
	return dojo.currency.format(value,{
		currency:'BRL',
		symbol:symbol,
		places:2
	});
};

com.copacabana.util.checkValidForm=function(cssclass,domNode) {
	if (!cssclass) {
		cssclass = ".mandatory";
	}
	var reqs = dojo.query(cssclass,domNode);	
	for ( var i = 0; i < reqs.length; i++) {
		try {
			var dreq = dijit.byNode(reqs[i]);
			if (!dreq.isValid()) {
				console.log(dreq);
				dijit.showTooltip("* Campo obrigat&oacute;rio", reqs[i]);
				return false;
			}
		} catch (e) {
			console.log(e);
		}

	}
	return true;
};
com.copacabana.util.myErrorDom=null;
com.copacabana.util.checkValidFormAdv=function(cssclass,domNode) {
	if(com.copacabana.util.myErrorDom!=null){
		dijit.hideTooltip(com.copacabana.util.myErrorDom);
		com.copacabana.util.myErrorDom=null;
	}
	if (!cssclass) {
		cssclass = ".mandatory";
	}
	var reqs = dojo.query(cssclass,domNode);	
	for ( var i = 0; i < reqs.length; i++) {
		try {
			var dreq = dijit.byNode(reqs[i]);
			if (!dreq.isValid()) {
				dijit.showTooltip("* Campo obrigat&oacute;rio", reqs[i]);
				com.copacabana.util.myErrorDom=reqs[i];
				return false;
			}
		} catch (e) {
			console.log(e);
		}

	}
	return true;
};

com.copacabana.util.parseTime=function(fullDate){
	
	var p = fullDate.lastIndexOf(' ');
	var time = fullDate.substring(p+1); 
	return time;
};
com.copacabana.util.parseDate=function(fullDate){
	
	var p = fullDate.lastIndexOf(' ');
	var date = fullDate.substring(0,p); 
	return date;
};

com.copacabana.util.trimNumber=function (s) {
	  while (s.substr(0,1) == '0' && s.length>1) { s = s.substr(1,9999); }
	  return s;
	}

com.copacabana.util.getElapsedTime=function(/*str in format HH:MM*/time,dateTimeStr,refDateStr) {
	var d = new Date();
	if(refDateStr){
		d=com.copacabana.util.getDate(refDateStr);
	}
	if(dateTimeStr){
		//check if it's waiting longer than the max limit of time
		var rdate=com.copacabana.util.getDate(dateTimeStr);	
		//console.log("date: "+ dateTimeStr+"="+ rdate);		
				
		var maxDiff = new Date();
		var maxHours = 3;
		maxDiff.setTime(maxDiff.getTime()-maxHours*60*60*1000);
		//console.log("Max:"+maxDiff);
		
		if(rdate<maxDiff){
			return '+ de '+maxHours+'h';
		}
	
	}
	var minDiff = dojo.date.difference(d,rdate,'minute');
	minDiff*=-1;
	var hours = 0;
	if(minDiff>=60){
		hours = parseInt(minDiff/60);
		minDiff = minDiff - (60*hours);
	}
//	var hour = d.getHours();
//	var minute = d.getMinutes();
//	
//	var a = time.split(":");
//	
//	
//	var pHour=(parseInt(com.copacabana.util.trimNumber(a[0])));
//	var pMinute=(parseInt(com.copacabana.util.trimNumber(a[1])));
//	if(hour<pHour){
//		hour+=24;
//	}
//	
//	var hourDiff = hour-pHour;
//	var mmStr=(((minute)-pMinute));
//	//if(hourDiff>0){
//		//hourDiff--;
//		if(mmStr<0){
//			mmStr+=60;
//		}
//	//}
	
	if(minDiff<10){
		minDiff="0"+minDiff;
	}
	return hours+":"+minDiff;
	
}
com.copacabana.util.getDate=function(dateTimeStr){
	var dateStr = com.copacabana.util.parseDate(dateTimeStr);
	var dateA=dateStr.split('/');
	
	var day = parseInt(com.copacabana.util.trimNumber(dateA[0]));
	var month = parseInt(com.copacabana.util.trimNumber(dateA[1]));
	var year = parseInt(com.copacabana.util.trimNumber(dateA[2]));
	
	var timeStr = com.copacabana.util.parseTime(dateTimeStr);
	var timeA=timeStr.split(":");
	var hour = parseInt(com.copacabana.util.trimNumber(timeA[0]));
	var minute = parseInt(com.copacabana.util.trimNumber(timeA[1]));
	return new Date(year, month-1, day, hour, minute, 0, 0);

}
var dialogAjax=null;

com.copacabana.util.showLoading=function(txt){
	if(dialogAjax==null){
		dialogAjax = new dijit.Dialog({			
			templateString:null,			
			templateString:"<div class=\"dijitDialog\" tabindex=\"-1\" waiRole=\"dialog\" waiState=\"labelledby-${id}_title\"  style=\"width:233px;height:32px;\">\r\n    <div dojoAttachPoint=\"titleBar\" class=\"dijitDialogTitleBar\" style=\"display:none\">\r\n    <span dojoAttachPoint=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\">${title}</span>\r\n    <span dojoAttachPoint=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" dojoAttachEvent=\"onclick: onCancel\">\r\n        <span dojoAttachPoint=\"closeText\" class=\"closeText\">x</span>\r\n    </span>\r\n    </div>\r\n        <div dojoAttachPoint=\"containerNode\" class=\"dijitDialogPaneContent\" style=\"text-align:center;background-repeat:no-repeat;background-image: url('/resources/img/barra_vermelha.png');color: white;font-size: medium;font-weight: bold;\"><img src='/resources/img/loading.gif' style=\"float: left;\"></img><span dojoAttachPoint=\"loadingtxt\" style=\"color:white\">a</span></div>\r\n</div>\r\n",
			duration:500				
		});		
	}
	if(txt && txt.length>0){
		dialogAjax.loadingtxt.innerHTML=txt;
	}else{
		dialogAjax.loadingtxt.innerHTML="Carregando...";
	}
	
	dialogAjax.show();
};
com.copacabana.util.hideLoading=function(){
	dialogAjax.hide();	
};

com.copacabana.util.cleanNode=function(node){
	try{
	while(node.hasChildNodes()){
		node.removeChild(node.childNodes[0]);
	}}
	catch (e) {
console.log('Failed to clean Ndoe '+node,e);
	}
};
com.copacabana.util.closeWarning=function(id){
	var url = "/msgRead.do?id=" + id;
	dijit.hideTooltip(dojo.byId('msgHandler'));
	var xhrArgs = {
		url : url,
		handleAs : "text",
		load : function(data) {
			
		},
		error : function(error) {
			console.log("failed to change msg status." ,error);
		}
	}
	var deferred = dojo.xhrGet(xhrArgs);
	
};
com.copacabana.util.acceptTerms=function(id){
	var url = "/msgRead.do?id=" + id;
	dialogs[id].hide();
	//dialogs[id].shutdown();
	var xhrArgs = {
		url : url,
		handleAs : "text",
		load : function(data) {
			
		},
		error : function(error) {
			console.log("failed to change msg status." ,error);
		}
	}
	var deferred = dojo.xhrGet(xhrArgs);	

}
var dialogs=[];
com.copacabana.util.warning=function(id,msgText,msgType){
	var msgPos=dojo.byId('msgHandler');
	
	if(msgPos==null){  
		msgPos = dojo.create('div',{id:'msgHandler',style:{zIndex:-100,height:'50%',position:'absolute',top:'0px',width:'50%'}},dojo.body());
	}
	
	
	if(msgType){
		switch (msgType) {
		case "CONFIRM_EMAIL":
			msgText+='<div onClick="com.copacabana.util.closeWarning(\''+id+'\')" class="closeButton">Fechar</div>'
			dijit.showTooltip(msgText, msgPos,['after']);
			break;
		case "NORMAL":
			msgText+='<div onClick="com.copacabana.util.closeWarning(\''+id+'\')" class="closeButton">Fechar</div>'
			dijit.showTooltip(msgText, msgPos,['after']);
			break;
		case "ACCEPT_TERMS":
			msgText+='<div onClick="com.copacabana.util.acceptTerms(\''+id+'\')" class="closeButton">Aceitar</div>'
			var options = {
					title : 'Termos de uso do site ComendoBem',
					style : 'width: 600px;height:460px;',
					closable:false,
					content: msgText,
					onHide:com.copacabana.util.refuseTerms
						
			};
			var dialog = new dijit.Dialog(options);
			dialog.onClose=com.copacabana.util.refuseTerms;
			dialog.onUnload=com.copacabana.util.refuseTerms;
			dialog.show();
			dialogs[id]=dialog;
			
			break;

		default:
			break;
		}
	} else {
		
		dijit.showTooltip(msgText, msgpos);
		
	}
};
com.copacabana.util.refuseTerms=function(id){	
	var msg = new com.copacabana.MessageWidget();
	msg.showMsg('O site ComendoBem s&oacute; pode ser acessado se voc&ecirc; concordar com os termos de uso, caso contr&aacute;rio contacte o ComendoBem.');	
	return false;	
};
com.copacabana.util.blink =function(node){
    dojo.fadeOut ({
                    node:node,
                    duration:3000
                 }).play();
    	dojo.fadeIn ({
                    node:node,
                    duration:3000
                 }).play()
   };
   
com.copacabana.util.createFacebookButtonCurrent=function(parentNode,urlArg){
	var url = window.location;
	if(urlArg){
		url=urlArg;
	}
	var fullurl ='http://www.facebook.com/plugins/like.php?href='+url;
	fullurl+='&locale=pt_BR&';
	fullurl+='layout=button_count&show_faces=true&width=110&action=recommend&colorscheme=light&height=21';
	
	var style={border: '0px none', overflow: 'hidden', width: '120px', height: '21px'};
	var allowtransparency="true"; 
	var scrolling="no";
	var frameborder="0";
	
	var args = {src:fullurl, style:style,allowtransparency:allowtransparency,scrolling:scrolling,frameborder:frameborder,width:120};
	var button = dojo.create('iframe',args,parentNode);
	return button;
   //<iframe src="http://www.facebook.com/plugins/like.php?href=http://www.comendobem.com.br&amp;layout=button_count&amp;show_faces=false&amp;width=450&amp;action=recommend&amp;colorscheme=light&amp;locale=pt_BR&amp;ref=aaa&amp;height=21" style="border: medium none; overflow: hidden; width: 450px; height: 21px;" allowtransparency="true" scrolling="no" frameborder="0"></iframe>
};

com.copacabana.util.phoneFormat=function(){ 
	
	//return '\\(?[0]?\\d{2}\\)?\\s?\\d{4}[\\-,\\.]?\\d{4}';
	return '(\\(?[0]?\\d{2,3}\\)?\\s?)?\\d{4}[\\-,\\.,\\s]?\\d{4}'; 
	
	
};
com.copacabana.util.emailFormat=function(){ 
	
	return '\\b[a-z0-9._%-]+@[a-z0-9.-]+\\.[a-z]{2,4}\\b';
};

com.copacabana.util.cepFormat=function(){ 
	
	return '[0-9]{2}\.?[0-9]{3}\\-?[0-9]{0,3}';
}

com.copacabana.util.isCpfValid=function(cpf){
	
	cpf=cpf.replace(/\./g,'');
	cpf=cpf.replace(/\-/g,'');
		
	if (cpf.length != 11 || cpf == "00000000000" || cpf == "11111111111" || cpf == "22222222222" || cpf == "33333333333" || cpf == "44444444444" || cpf == "55555555555" || cpf == "66666666666" || cpf == "77777777777" || cpf == "88888888888" || cpf == "99999999999"){
		return false;
	}
	var soma = 0;
	for (i=0; i < 9; i ++)
		soma += parseInt(cpf.charAt(i)) * (10 - i);
	var resto = 11 - (soma % 11);
	if (resto == 10 || resto == 11)
		resto = 0;
	if (resto != parseInt(cpf.charAt(9)))
		return false;
	soma = 0;
	for (i = 0; i < 10; i ++)
		soma += parseInt(cpf.charAt(i)) * (11 - i);
	resto = 11 - (soma % 11);
	if (resto == 10 || resto == 11)
		resto = 0;
	if (resto != parseInt(cpf.charAt(10)))
		return false;
	return true;

};

com.copacabana.util.cacheFoodCat=function(items,request){
	var store=request.store;
	var dataitems =[];
	for ( var i = 0; i < items.length; i++) {
		
	
		dataitems.push({
				id:store.getValue(items[i], "id"),
				isMainCategory:store.getValue(items[i], "isMainCategory"),
				imgUrl:store.getValue(items[i], "imgUrl"),
				name:store.getValue(items[i], "name"),
				description:store.getValue(items[i], "description")
		}
		);
		
	}
	console.log("caching categories",dataitems);
	
	//dojo.cookie('foodCatCache',dojo.toJson(dataitems),{expire:1});
};
com.copacabana.util.loadFoodCats=function(){
//	try{
//		var cache = dojo.fromJson(dojo.cookie('foodCatCache'));
//		console.log(cache);
//		if(cache!=null){
//			console.log("categories cache hit!",dataitems);
//			return new dojo.data.ItemFileReadStore(
//					{
//						data:{
//							identifier:"id", 
//							label: "name", 
//							items: cache
//						}
//					});	
//		}
//	}catch (e) {
//		
//	}
	dojo.cookie('foodCatCache',{},{expire:-1});
	var ifstore= new dojo.data.ItemFileReadStore({
        url: "/listFoodCategoriesItemFileReadStore.do"
    });	
	var sort = [{attribute: "name", descending: true}];
	ifstore.fetch({onComplete: com.copacabana.util.cacheFoodCat, onError: function(err){console.error(err)},sort:sort});
	
	
	return ifstore;	
};
com.copacabana.util.showFollowUs=function(){
	/*if(dojo.cookie("hasShownToday")=="TRUE"){
		//return;	
	}
	dojo.cookie("hasShownToday", "TRUE", {
        expires: 1
    });
	var msgPos=dojo.byId('followHandler');
	msgPos=dojo.create('div',{id:'followHandler',style:{marginTop:"-60px", marginLeft:"190px"}},dojo.byId('logo'));
	console.log('a0')
	//'<a href="http://twitter.com/share" class="twitter-share-button" data-text="Gostei de fazer pedidos pela internet usando o ComendoBem" data-count="horizontal" data-via="comendobem_camp">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>'
	msgText='<div style="height:20px"><a href="http://twitter.com/share" class="twitter-share-button" data-url="www.comendobem.com.br" data-text="Encontrei o Maghalita no http://www.comendobem.com/" data-count="horizontal" data-via="comendobem_camp">Tweet</a><ul class="followUsList" style="float:none"><li class="btnLabel">Compartilhe: </li><li style="float: left;"><a href="http://twitter.com/share" class="twitter-share-button" data-url="www.comendobem.com.br" data-text="Encontrei o Maghalita no http://www.comendobem.com/" data-count="horizontal" data-via="comendobem_camp">Tweet</a></li><li style="float: left;"><a  rel="nofollow" class="addBtn facebookBtn" href="http://www.facebook.com/share.php?u=http://www.comendobem.com.br/" onclick="window.open(this.href,\'fb\',\'location=1,status=1,scrollbars=1,width=900,height=400\'); return false;"></a></li></ul></div>';
	//dijit.showTooltip(dojo.byId('tuit').innerHTML, msgPos,['after']);*/	
};
com.copacabana.util.showSuccessAction=function(txt){
	if(!txt){
		txt="Dados salvos";
	}
	com.copacabana.util.showLoading(txt);
	setTimeout(com.copacabana.util.hideLoading,1000);
}

com.copacabana.util.toolTip=null;
com.copacabana.util.showTimedMessage=function(txt,dom,time,position){
	com.copacabana.util.hideTimedMessage();
	com.copacabana.util.toolTip=dom;
	if(!position){
		position=['after'];
	}
	dijit.showTooltip(txt,dom,position);
	setTimeout(com.copacabana.util.hideTimedMessage,time);
};
com.copacabana.util.hideTimedMessage=function(){
	if(com.copacabana.util.toolTip!=null){
		dijit.hideTooltip(com.copacabana.util.toolTip);
	}
};
com.copacabana.util.startPasswordRegen=function(email,callback,errorCallback){
var xhrArgs = {
		content: {email:email},
		url:'/dispararGeracaoSenha.do',
		handleAs: "text",
		load : function(response) {					
			callback(response);
		},
		error: function(response) {
			 errorCallback(response);			
		}
};
//
var deferred = dojo.xhrPost(xhrArgs);
};
com.copacabana.util.sendPasswordReminder=function(email,callback,errorCallback){
	var xhrArgs = {
			content: {email:email},
			url:'/lembreteSenha.do',
			handleAs: "text",
			load : function(response) {					
				callback(response);
			},
			error: function(response) {
				 errorCallback(response);			
			}
	};
	//
	var deferred = dojo.xhrPost(xhrArgs);
};
com.copacabana.util.executeLogin=function(uname,pwd,isFacebook,fbuser,successCallback,errorCallback){
	var counter=0;
	var pwdEncoded = new com.copacabana.Cripter().encode(pwd);
	var dataToServer = {login:uname,password:pwdEncoded,isMD5:true,isFacebook:isFacebook};
	if(fbuser!=null){
		dataToServer.fbuser=dojo.toJson(fbuser)
	}

	var xhrArgs = {
		content: dataToServer,
		url:'/authenticateNoSSL.do',
		handleAs: "json",
		load : function(response){successCallback(response)},
		error: function(response) {							
			if(!response.sessionId || response.sessionId==sessionId){				
					if(response.authStatus=='MUSTRETRY' && this.counter<3){
						counter++;
						//panel.innerHTML="Contactando facebook...";									
						//executeLogin(null);
					}else{
						counter=0;
						logging=false;
						//com.copacabana.util.cleanNode(panel);
						//panel.innerHTML="Problemas no servidor, por favor tente novamente.";
						//console.error("Erro ao executar login...",response);
						errorCallback();
					}								
			}else{				
				counter=0;
				//panel.innerHTML="Sess&atilde;o expirada recarregando...";
				sessionId = response.sessionId;
				com.copacabana.util.executeLogin(uname,pwd,isFacebook,fbuser,successCallback,errorCallback);
				//executeLogin(null);
			}
			
		}
	};

var deferred = dojo.xhrPost(xhrArgs);
};
com.copacabana.util.deliveryRangeCache={};
com.copacabana.util.loadDeliveryRange=function(restId,callback,errorFct){
	if(com.copacabana.util.deliveryRangeCache[restId]!=null){
		callback(com.copacabana.util.deliveryRangeCache[restId]);
	}else{
		var url = "/listDeliveryRangeForRestaurant.do?key="	+restId;
		var xhrArgs = {
			url : url,
			handleAs : "text",
			load : function(data){
				var entity = dojo.fromJson(data);
				com.copacabana.util.deliveryRangeCache[restId]=entity;
				callback(entity);
			},
			error : function(error) {
					console.error("Failed to load delivery Range ",error);
					errorFct(error);
				}
		};
		var deferred = dojo.xhrPost(xhrArgs);	
	}
	
};

}

if(!dojo._hasResource["com.copacabana.ClientOrderWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.ClientOrderWidget"] = true;
dojo.provide("com.copacabana.ClientOrderWidget");










  






//I18N


 


dojo.declare("com.copacabana.ClientOrderWidget", [
		dijit._Widget, dijit._Templated ], {
	i18nStrings: null,
	templateString:"<div id=\"pedidoWrapper\" style=\"right: 0px;\">\r\n\r\n<div class=\"canto cantoSupEsq\"></div>\r\n<div class=\"canto cantoInfEsq\"></div>\r\n\r\n<h2>Seu Pedido</h2>\r\n\r\n<ul class=\"orderList\">\t\r\n</ul>\r\n<form action=\"/placeOrder.do\" method=\"post\" dojoType=\"dijit.form.Form\" class=\"orderForm\">\r\n<input type=\"hidden\" class=\"orderData\" name=\"orderData\" dojoType=\"dijit.form.TextBox\"/>\r\n</form>\r\n<p>Prato:<br />\r\n<span class=\"itemSelecionado\">&nbsp;</span><br />\r\nCusto: <span class=\"valorUnitario\"> 0,00</span><br />\r\n\r\n</p>\r\n<hr />\r\n<p><div class=\"dropdownButtonContainer\" style=\"background: #C8C8C8 none repeat scroll 0 0;margin-top:2px;margin-bottom:2px;margin-left:3px;margin-right:3px; font-size:x-small;\">\r\n</div>\r\n\t<br/>\r\nTotal de Pratos: <span class=\"totalPratos\">0</span><br />\r\nSub-Total: <br /><span class=\"subTotal\">0,00</span><br />\r\n</p>\r\n\r\n<div class=\"confirmarPedido\" > <img alt=\"Confirmar Pedido\" style=\"cursor: pointer;\" alt=\"Confirmar Pedido\"\r\n\tsrc=\"/resources/img/btConfirmar.png\" dojoAttachEvent=\"onclick:confirmOrder\"/> </div>\r\n\r\n</div>\r\n",
	constructor : function() {
		this.id="pedidoWrapper";	
	},
	connections:[],
	destroyRecursive : function() {
		console.log("destroyingOrder..");
		while(this.connections.length>0) {
			dojo.disconnect(this.connections.pop());
		}
		
		this.plateList=[];
		var i =0;
		dojo.forEach(this.getDescendants(), function(widget) {
			console.log("destroyingOrder.."+(i++));
			widget.destroyRecursive();
		});
		this.inherited(arguments);
	},
	
	postMixInProperties : function() {
		this.inherited(arguments);
	},

	postCreate : function() {
		this.inherited(arguments);
		this.i18nStrings= dojo.i18n.getLocalization("com.copacabana", "ClientOrderWidgetStrings");
	},
	rest:null,
	setRestaurant:function(rest){
		this.rest=rest;
	},
	dropDown:null,
	dialog:null,
	startup : function() {
		try {
			dojo.parser.parse(this.domNode);
			console.log('starting up');
			this.dropDown=dojo.query(".dropdownButtonContainer",this.domNode)[0];
			this.dialog = new dijit.TooltipDialog({
				content: '<p>'+this.i18nStrings.obsText+'</p><textarea dojoType="dijit.form.SimpleTextarea" cols="30" rows="4" class="observationArea"  name="observation"></textarea>'	            
	        });

			var button = new dijit.form.DropDownButton({
	            label: "<span>"+this.i18nStrings.obsTitle+"</span>",
	            dropDown: this.dialog,
	            style:"background: #C8C8C8 none repeat scroll 0 0;margin-top:2px;margin-bottom:2px;margin-left:3px;margin-right:3px; font-size:x-small;"
	        });
			
	        this.dropDown.appendChild(button.domNode);
	        this.plateList=[];
			
		} catch (e) {
			console.log(e);
			console.log(e.message);
		}
	},
	obsdialog:null,
	
	addFractionPlate:function(plate1,plate2,qty,title,cost){
		var plate = {
			id:plate1.id+"|"+plate2.id,
			title:title,
			price:cost,
			firstHalf:plate1,
			secondHalf:plate2,
			isFraction:true
		};
		
		if(this.plateList[plate.id]!=null){
			var v = this.plateList[plate.id];
			qty=v.qty+qty;		
			this.removeIt(plate.id,v.qty);			                       
		}
		
		var item = document.createElement("li");
		item.setAttribute("class","order_"+plate.id);
		item.setAttribute("plateId",plate.id);
		item.setAttribute("firstHalfId",plate1.id);
		item.setAttribute("secondHalfId",plate2.id);
		item.setAttribute("qty",qty);
		var label = document.createTextNode(qty+" "+plate.title);
		item.appendChild(label);
		var removeNode = document.createElement("span");
		removeNode.setAttribute("title",this.i18nStrings.removeLabel);		
		var fctRemove = dojo.hitch(this,function(evt){
			this.removeIt(plate.id,qty);
		});
		this.connections.push(dojo.connect(removeNode, "onclick", this, fctRemove,false));
		var fctShowCurrentItemData = dojo.hitch(this,function(evt){			
			this.showCurrentItemData(plate);
		});
		this.connections.push(dojo.connect(item, "onclick", this, fctShowCurrentItemData,false));

		removeNode.appendChild(document.createTextNode("X"));
		item.appendChild(removeNode);
		
		this.plateList[plate.id]={plate:plate,qty:qty};
		(dojo.query(".orderList", this.domNode)[0]).appendChild(item);
		this.updateOrderData();
		
	},
	
	
	addPlate:function(plate,qty){
		
		if(this.plateList[plate.id]!=null){
			var v = this.plateList[plate.id];
			qty=v.qty+qty;		
			this.removeIt(plate.id,v.qty);
			                       
		}
		plate.isFraction=false;
		var item = document.createElement("li");
		item.setAttribute("class","order_"+plate.id);
		item.setAttribute("plateId",plate.id);
		item.setAttribute("qty",qty);
		var label = document.createTextNode(qty+" "+plate.title);
		item.appendChild(label);
		var removeNode = document.createElement("span");
		removeNode.setAttribute("title",this.i18nStrings.removeLabel);		
		var fctRemove = dojo.hitch(this,function(evt){
			this.removeIt(plate.id,qty);
		});
		this.connections.push(dojo.connect(removeNode, "onclick", this, fctRemove,false));
		var fctShowCurrentItemData = dojo.hitch(this,function(evt){
			
			this.showCurrentItemData(plate);
		});
		this.connections.push(dojo.connect(item, "onclick", this, fctShowCurrentItemData,false));

		removeNode.appendChild(document.createTextNode("X"));
		item.appendChild(removeNode);
		
		this.plateList[plate.id]={plate:plate,qty:qty};
		(dojo.query(".orderList", this.domNode)[0]).appendChild(item);
		this.updateOrderData();
		
	},
	lastPanel:null,
	showCurrentItemData:function(plate){
		
		if(this.lastPanel && this.lastPanel!=null){			
			dojo.style(this.lastPanel,"backgroundColor","white");
		}
		var panel=this.getNode("order_"+plate.id,(dojo.query(".orderList", this.domNode)[0]));

		this.lastPanel=panel;
		
		dojo.style(panel,"backgroundColor","silver");
		(dojo.query(".itemSelecionado", this.domNode)[0]).innerHTML=plate.title;
		(dojo.query(".valorUnitario", this.domNode)[0]).innerHTML=com.copacabana.util.moneyFormatter(plate.price);
		
	},
	plateList:[],
	confirmOrder:function(){
		com.copacabana.util.showLoading();
		try{
			console.log("dialog",this.dialog.domNode);			
			console.log(dojo.query(".observationArea",this.dialog.domNode)[0].value);
			}catch(e){
				console.log(e);
			}
		
		var orderData ={plates:[],observation:dojo.query(".observationArea",this.dialog.domNode)[0].value};
		for ( var p in this.plateList) {
			var plateObj = this.plateList[p];
			
			if(plateObj!=null){				
				orderData.restaurant={
						id:this.rest.id,
						name:this.rest.name,
						acceptablePayments:this.rest.acceptablePayments,
						warning:this.rest.warning,
						warningDate:this.rest.warningDate
				}
				plateObj.plate.restaurant=null;
				//orderData.restaurant=plateObj.plate.restaurant;
				//TODO maybe reduce the bandwidth used by filtering fieldss
				//orderData.plates.push({id:plateObj.plate.id,qty:plateObj.qty});
				
				var pp = {
						qty:plateObj.qty,
						name:plateObj.plate.title,
						price:plateObj.plate.price,
						plate:plateObj.plate.id,
						isFraction:plateObj.plate.isFraction					
					};
				if(plateObj.plate.isFraction==true){
					pp.fractionKeys=[];
					pp.fractionKeys.push(plateObj.plate.firstHalf.id);
					pp.fractionKeys.push(plateObj.plate.secondHalf.id);					
				}
				orderData.plates.push(pp);
				
//				orderData.plates.push({
//					qty:plateObj.qty,
//					name:plateObj.plate.title,
//					price:plateObj.plate.price,
//					plate:plateObj.plate
//				});
			}			
		}
		
		if(!orderData.plates|| orderData.plates.length==0){
			com.copacabana.util.hideLoading();
			var msg = new com.copacabana.MessageWidget();
			msg.showMsg(this.i18nStrings.atLeastOneItem,msg.errorType);
			
			return;
		}
		dijit.byNode(dojo.query(".orderData",this.domNode)[0]).attr("value",dojo.toJson(orderData));
		dijit.byNode(dojo.query(".orderForm", this.domNode)[0]).submit();
		
	},
	getNode:function(nodeClassName,domNode){
		var node = dojo.query("."+nodeClassName,domNode )[0];
		try{
			if (!node) {
				console.log('IE bug, cannot find node:'+node);
				for (var i = 0; i < (domNode).childNodes.length; i++) {
					var classS = (domNode).childNodes[i].getAttribute('class');
					if (classS == nodeClassName) {
						node = (domNode).childNodes[i];
					}
				}
			}
			console.log('node',node);
		}catch (e) {			
			console.log(e);
		}
			return node;
	},
	removeIt:function(id,qty){
		console.log("remove:"+id);				
		this.plateList[id]=null;		
		var node = this.getNode("order_"+id,(dojo.query(".orderList", this.domNode)[0]));
		(dojo.query(".orderList", this.domNode)[0]).removeChild(node);		
		this.updateOrderData();
	},
	updateOrderData:function(){
		var totalItems=0;
		var totalCost=0;
		for ( var p in this.plateList) {
			var plateObj = this.plateList[p];
			if(plateObj!=null){
				totalItems++;
				totalCost+=plateObj.qty*plateObj.plate.price;
			}			
		}
		dojo.query(".totalPratos", this.domNode)[0].innerHTML=totalItems;
		dojo.query(".subTotal" , this.domNode)[0].innerHTML=com.copacabana.util.moneyFormatter(totalCost);
	}

});

}

if(!dojo._hasResource["com.copacabana.AddressPaneWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.AddressPaneWidget"] = true;
dojo.provide("com.copacabana.AddressPaneWidget");










// I18N





dojo.declare(
				"com.copacabana.AddressPaneWidget",
				[ dijit._Widget, dijit._Templated ],
				{
					i18nStrings : null,
					templateString:"\r\n<div class=\"endereco\">\r\n<h2 class=\"addressTitle\">${address.name}</h2>\r\n\r\n<form  action=\"/addAddressToUser.do\" method=\"post\"\r\n\tdojoType=\"dijit.form.Form\"  class=\"addressForm\"> \r\n<input type=\"hidden\" name=\"address.id\" class=\"addressId\" dojoType=\"dijit.form.TextBox\"/>\r\n\r\n<table border=\"0\" class=\"addressFields\">\r\n<tr><td>\r\n<label for=\"street\">Endere&ccedil;o:</label>\r\n</td><td>\r\n<input\r\n\ttype=\"text\" class=\"required\" name=\"address.street\" dojoType=\"dijit.form.ValidationTextBox\" required=\"true\" class=\"required\" trim=\"true\" properCase=\"true\"\r\n\tstyle=\"height: 20px; width: 255px;\" value=\"${address.street}\" /> <span\tclass=\"required\">*</span> \r\n</td></tr>\r\n\r\n<tr><td>\r\n<label for=\"number\">N&uacute;mero:</label> </td> <td><input dojoType=\"dijit.form.ValidationTextBox\" required=\"true\" class=\"required\" trim=\"true\"\r\n\ttype=\"text\"  name=\"address.number\" value=\"${address.number}\"\r\n\tstyle=\"height: 20px; width: 65px;\" /> <span class=\"required\">*</span></td>\r\n\t</tr>\r\n\t<tr><td>\r\n\t<label for=\"additionalInfo\">Complemento:</label></td><td>  <input dojoType=\"dijit.form.ValidationTextBox\" required=\"false\" trim=\"true\" class=\"required\"\r\n\ttype=\"text\" value=\"${address.additionalInfo}\" name=\"address.additionalInfo\" style=\"height: 20px; width: 75px;\" />\r\n</td></tr>\r\n\r\n<tr><td>\r\n<label for=\"city\">Cidade:</label> \r\n</td><td>\r\n<select dojoType=\"dijit.form.FilteringSelect\"\r\n\t\t\tclass=\"citySelection required\" autoComplete=\"true\" required=\"true\"\r\n\t\t\tinvalidMessage=\"Cidade inv&aacute;lida\"  name=\"address.city.k\" ></select><span class=\"required\">*</span> \r\n</td></tr>\r\n\r\n<tr><td>\r\n<label for=\"neighborhood\">Bairro:</label> \r\n</td><td>\r\n<select dojoType=\"dijit.form.FilteringSelect\"\r\n\t\t\tclass=\"neighSelection required\" name=\"address.neighborhood\" autoComplete=\"true\" required=\"true\" \r\n\t\t\tinvalidMessage=\"Bairro inv&aacute;lido\"></select><span class=\"required\">*</span> \r\n</td></tr>\r\n\r\n<tr><td>\r\n<label for=\"phone\">Telefone:</label> \r\n</td><td>\r\n<input dojoType=\"dijit.form.ValidationTextBox\" required=\"true\" class=\"required\" \r\ntrim=\"true\"\ttype=\"text\" class=\"required\" name=\"address.phone\" value=\"${address.phone}\" regExpGen=\"com.copacabana.util.phoneFormat\" invalidMessage=\"Telefone inv&aacute;lido. Utilize o seguinte formato (DDD) NNNN-NNNN\"\r\n\tstyle=\"height: 20px; width: 212px;\" /> <span class=\"required\">*</span> \r\n</td></tr>\r\n\r\n<tr><td>\r\n<label for=\"zip\">CEP:</label>\r\n</td><td>\r\n<input dojoType=\"dijit.form.ValidationTextBox\" required=\"false\"  class=\"required\"\r\n\ttype=\"text\" name=\"address.zipCode\" value=\"${address.zipCode}\"\r\n\tstyle=\"height: 20px; width: 165px;\" />  \r\n</td></tr>\r\n\r\n</table>\r\n\r\n</form>\r\n<button baseClass=\"orangeButton\" dojoType=\"dijit.form.Button\" dojoAttachEvent=\"onclick:createAddress\" class=\"persist\">Salvar</button>&nbsp;\r\n<button baseClass=\"orangeButton\" dojoType=\"dijit.form.Button\" dojoAttachEvent=\"onclick:deleteAddress\" class=\"apagar\" >Apagar</button>\r\n \r\n<form action=\"/addAddressToUser.do\" method=\"post\" dojoType=\"dijit.form.Form\" class=\"updateUserForm\">\t\r\n</form>\r\n<form action=\"/deleteAddress.do\" method=\"post\" dojoType=\"dijit.form.Form\" class=\"deleteAddresForm\">\t\r\n</form>\r\n\r\n</div>\r\n",
					constructor : function(address, clientId) {
						this.address = address;
						this.address.name = address.street;
						if (!this.address.phone) {
							this.address.phone = "";
						}
						if (!this.address.zipCode) {
							this.address.zipCode = "";
						}
						this.clientId = clientId;

					},
					clientId : null,
					destroyRecursive : function() {
						dojo.forEach(this.getDescendants(), function(widget) {

							widget.destroyRecursive();
						});
						this.inherited(arguments);
					},
					address : null,

					postMixInProperties : function() {
						this.inherited(arguments);
					},

					postCreate : function() {
						this.inherited(arguments);
						this.i18nStrings=dojo.i18n.getLocalization("com.copacabana",
						"AddressPaneWidgetStrings");
					},

					startup : function() {
						try {
							dojo.parser.parse(this.domNode);

							this.loadCities();							
							
							dijit.byNode(dojo.query(".addressId", this.domNode)[0]).attr("value",this.address.id);
							dijit.byNode(dojo.query(".addressForm",this.domNode)[0]).attr('value', this.address);
							console.log(dijit.byNode(dojo.query(".apagar",this.domNode)[0]));
							dojo.connect(dijit.byNode(dojo.query(".apagar",this.domNode)[0]), "onClick", dojo.hitch(this,this.deleteAddress));
							
							dojo.connect(dijit.byNode(dojo.query(".persist",this.domNode)[0]), "onClick", dojo.hitch(this,this.createAddress));
							
							
						} catch (e) {
							console.error('error starting up address',e);
						}
					},
					allNeighbors:null,
					loadNeighborhood : function() {
						if(this.allNeighbors==null){
							this.allNeighbors = new dojo.data.ItemFileReadStore( {
								url : "/listNeighborsItemFileReadStore.do"
							});	
						}
						dijit.byNode(dojo
								.query(".neighSelection", this.domNode)[0]).store = this.allNeighbors;

					},
					allCitiesStore:null,
					loadCities : function() {
						
						try {
							if(this.allCitiesStore==null){
								this.allCitiesStore= new dojo.data.ItemFileReadStore( {
									url : "/listCitiesItemFileReadStore.do"
								});
							}
							dijit.byNode(dojo.query(".citySelection",this.domNode)[0]).store = this.allCitiesStore;
							dojo.connect(dijit.byNode(dojo.query(".citySelection", this.domNode)[0]),"onChange", dojo.hitch(this,this.onCityUpdate));
							console.log("setting city:" + this.address.neighborhood.city.id);
							dijit.byNode(dojo.query(".citySelection",this.domNode)[0]).attr("value", this.address.neighborhood.city.id);
							dijit.byNode(dojo.query(".neighSelection",this.domNode)[0]).attr("value", this.address.neighborhood.id);
						} catch (e) {
							console.error('error loading cities',e);
						}
					},
					onCityUpdate : function() {
						try {
							var citySelected=dijit.byNode(
									dojo.query(".citySelection",
											this.domNode)[0]).attr(
									"value");
							if(citySelected){
								var stateStore = new dojo.data.ItemFileReadStore( {
									url : "/listNeighborsByCity.do?key="
											+ citySelected
								});
	
								dijit
										.byNode(
												dojo.query(".neighSelection",
														this.domNode)[0]).reset();
								dijit.byNode(dojo.query(".neighSelection",
										this.domNode)[0]).store = stateStore;
								if (this.startingYet === true) {
									dijit.byNode(
											dojo.query(".neighSelection",
													this.domNode)[0]).attr("value",
											this.address.neighborhood.id);
									this.startingYet = false;
								}
							}
						} catch (e) {
							console.error('Error on city update',e);
						}
					},
					startingYet : true,
					updateData : function(data) {
						this.address.name = data.street;
						this.address.id = data.id;
						dojo.query(".addressTitle", this.domNode)[0].innerHTML = this.address.name;
						dijit.byNode(dojo.query(".addressId", this.domNode)[0]).attr("value", data.id);
					},
					createAddress : function() {
						if(!com.copacabana.util.checkValidForm(".required")){				
			    	  		return;
			    	  	}
						com.copacabana.util.showLoading();
						var fct = function(data) {
							com.copacabana.util.hideLoading();
							var entity = data;							
							this.updateData(data);
						}
						if (this.address.id && this.address.id != "") {							
							fct = function(data) {
								com.copacabana.util.hideLoading();
								var entity = data;								
								this.updateData(data);

							}
						}

						var xhrArgs = {
							form : dojo.query(".addressForm", this.domNode)[0],
							handleAs : "json",
							load : dojo.hitch(this, fct),
							error : function(error) {
								com.copacabana.util.hideLoading();
								var msg = new com.copacabana.MessageWidget();
		                     	msg.showMsg("Erro ao salvar endere&ccedil;o. Por favor tente novamente");
								console.log("Form error ", error);
							}
						};
						// Call the asynchronous xhrPost
						console.log("sending");
						var deferred = dojo.xhrPost(xhrArgs);
					},
					updateUser : function(data) {
						var form = dojo.query(".updateUserForm", this.domNode)[0];// dojo.byId("updateUserForm")
						if (this.userNode != null) {
							form.removeChild(this.userNode);
						}
						if (this.addressIdNode != null) {
							form.removeChild(this.addressIdNode);
						}
						com.copacabana.util.showLoading();
						this.userNode = document.createElement("input");
						this.userNode.setAttribute("name", "id");
						this.userNode.setAttribute("value", this.clientId);
						this.userNode.setAttribute("type", "hidden");
						form.appendChild(this.userNode);
						this.addressIdNode = document.createElement("input");
						this.addressIdNode.setAttribute("name",
								"addresses[0].k");
						this.addressIdNode.setAttribute("value", data.id);
						this.addressIdNode.setAttribute("type", "hidden");
						form.appendChild(this.addressIdNode);

						var xhrArgs = {
							form : form,
							handleAs : "text",
							load : dojo.hitch(this, function(data) {
								console.log('updated');
								com.copacabana.util.hideLoading();
								var entity = data;

							}),
							error : function(error) {
								// We'll 404 in the demo, but that's okay. We
							// don't have a 'postIt' service on the
							// docs server.
							com.copacabana.util.hideLoading();
							console.log("Form error ", error);
						}
						};
						// Call the asynchronous xhrPost
						console.log("sending");
						var deferred = dojo.xhrPost(xhrArgs);
					},
					deleteNode : null,
					deleteAddress : function(event){
						if (event) {
							// Stop the submit event since we want to control form submission.
							event.preventDefault();
							event.stopPropagation();
							dojo.stopEvent(event);
						}
						if(this.address.id==null || this.address.id==""){
							this.domNode.innerHTML = "";
							return;
						}
						com.copacabana.util.showLoading();
						var form = dojo
								.query(".deleteAddresForm", this.domNode)[0];// dojo.byId("updateUserForm")
						if (this.deleteNode != null) {
							form.removeChild(this.deleteNode);
						}
						this.deleteNode = document.createElement("input");
						this.deleteNode.setAttribute("name", "id");
						this.deleteNode.setAttribute("value", this.address.id);
						this.deleteNode.setAttribute("type", "hidden");
						form.appendChild(this.deleteNode);

						var xhrArgs = {
							form : form,
							handleAs : "text",
							load : dojo.hitch(this, function(data) {
								com.copacabana.util.hideLoading();
								var entity = data;
								this.domNode.innerHTML = "";
							}),
							error : function(error) {
								com.copacabana.util.hideLoading();
								// We'll 404 in the demo, but that's okay. We
							// don't have a 'postIt' service on the
							// docs server.
							console.log("Form error ", error);
						}
						};
						// Call the asynchronous xhrPost
						console.log("sending");
						var deferred = dojo.xhrPost(xhrArgs);
					}

				});

}

if(!dojo._hasResource["com.copacabana.FoodCategoryRestaurantResultWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.FoodCategoryRestaurantResultWidget"] = true;
dojo.provide("com.copacabana.FoodCategoryRestaurantResultWidget");








dojo.declare("com.copacabana.FoodCategoryRestaurantResultWidget", [ dijit._Widget,
		dijit._Templated ], {
	i18nString : null,
	title : "",
	formattedName:"",
	maxlength:18,
	templateString:"<div>\r\n<div class=\"restItem\" style=\"background-color: white;\" dojoAttachEvent=\"onclick:execute\">\r\n<a href=\"/${rest.uniqueUrlName}\" onclick=\"return false;\"  style=\"overflow: hidden; display: inline-block; width: 130px;height: 20px;color:#605D5D;\">${formattedName}</a>\r\n<span class=\"${rest.isOpenStatusCSS}\">${statusLabel}</span></div>\r\n</div>\r\n",
	constructor : function(args) {
		this.rest=args.rest;
		this.formattedName=this.rest.name;
		if(this.formattedName.length>this.maxlength){
			this.formattedName=this.formattedName.substr(0,this.maxlength-3)+"..."
		}
		
		if(this.rest.siteStatus=='TEMPUNAVAILABLE'){
			this.rest.isOpenStatusCSS="notActive";
			this.statusLabel="indisp.";
		}else if (this.rest.siteStatus!='ACTIVE'){
			this.rest.isOpenStatusCSS="notActive";
			this.statusLabel="breve";
		}else{
			if(this.rest.isOpen){
				this.rest.isOpenStatusCSS="aberto";
				this.statusLabel="aberto";
			}else{
				this.rest.isOpenStatusCSS="fechado";
				this.statusLabel="fechado";
			}
		}
//		if(this.rest.currentDelay>300){
//			this.rest.isOpenStatusCSS="notActive";
//			this.statusLabel="indisp.";
//		}else if(this.rest.siteStatus!='ACTIVE'){
//			this.rest.isOpenStatusCSS="notActive";
//			this.statusLabel="breve";
//		}else{
//			if(this.rest.isOpen){
//				this.rest.isOpenStatusCSS="aberto";
//				this.statusLabel="aberto";
//			}else{
//				this.rest.isOpenStatusCSS="fechado";
//				this.statusLabel="fechado";
//			}
//		}
		
	},
	statusLabel:'fechado',
	rest : {},
	postMixInProperties : function() {
		this.inherited(arguments);
	},

	postCreate : function() {
		this.inherited(arguments);
		dojo.parser.parse(this.domNode);

	},

	startup : function() {

	},
	execute:function(){
		dojo.publish("onOpenRestaurant",[this.rest]);
		return false;
	},
	voidExecution:function(){
		return false;
	}
	

});

}

if(!dojo._hasResource["com.copacabana.HighLightWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.HighLightWidget"] = true;
dojo.provide("com.copacabana.HighLightWidget");








dojo.declare("com.copacabana.HighLightWidget", [ dijit._Widget,
		dijit._Templated ],
		{
			i18nString : null,
			title : "",
			url : null,
			templateString:"<div class=\"quadrado\" \r\n\tstyle=\"overflow: hidden; color: #605D5D; font-family: verdana, arial, sans-serif; font-size: small;\">\r\n<h2><div class=\"textNode\" style=\"margin: 5px; font-size: 1em; font-weight: normal; font-family: verdana,arial,sans-serif; color: rgb(96, 93, 93);\"></div></h2>\r\n<a href=\"\" border=0 class=\"linkNode\"><img alt=\"loading...\" src=\"\" class=\"imgNode\" border=\"0\" width=\"50\"></a>\r\n<div class=\"description\"></div>\r\n</div>\r\n",
			constructor : function() {
			},

			postMixInProperties : function() {
				this.inherited(arguments);
			},
			textNode : null,
			imageNode : null,
			postCreate : function() {				
				this.inherited(arguments);
				dojo.parser.parse(this.domNode);
				try{
				console.log('high');
				this.imageNode = dojo.query(".imgNode", this.domNode)[0];
				this.imageNode.src = dojo.moduleUrl("com.copacabana",
						"images/loader.gif");
				this.textNode = dojo.query(".textNode", this.domNode)[0];
				
				this.textNode.innerHTML = this.title;
				this.linkNode = dojo.query(".linkNode", this.domNode)[0];
				}catch (e) {
console.error('ee',e);
				}

			},
			failedToLoadHighlight:function(response){
				try{
					var errorData =dojo.fromJson(response.responseText);
					console.log(errorData);
					this.imageNode.style.display='none';
				}catch(e){}
			},
			linkNode:null,
			object:null,
			setContent:function(obj){
				this.object=obj;
			},
			createSection:function(objeto){
				this.imageNode.width=240;
				this.imageNode.src='';							
				this.imageNode.src = objeto.imageUrl;							
				this.imageNode.alt=objeto.imageAlt;
				this.imageNode.title=objeto.imageAlt;	
				this.linkNode.href=objeto.url;
				this.linkNode.target='_blank';
				if(objeto.title && objeto.title!=''){
					this.textNode.innerHTML =objeto.title; 
				}
				if(objeto.description && objeto.description!=''){
					dojo.query(".description", this.domNode)[0].innerHTML=objeto.description;
				}
			},
			startup : function() {
				try {
					
					if(!this.object || this.object==null){
						dojo.xhr("GET", {
							url : this.url,
							handle : 'json',
							load : dojo.hitch(this,function(response) {
								try{
									var objeto = dojo.fromJson(response);
									this.createSection(objeto);
								}catch (e) {
									// TODO: handle exception
									console.error("highlightnode",e);
									
								}
								
							}),
							error:dojo.hitch(this,"failedToLoadHighlight")
								
						});
					}
					else{
						this.createSection(this.object);
					}
				} catch (e) {
					console.error("highlight start ",e);
				}
			}
		});

}

if(!dojo._hasResource["dojox.embed.Flash"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.embed.Flash"] = true;
dojo.provide("dojox.embed.Flash");

(function(){
	/*******************************************************
		dojox.embed.Flash

		Base functionality to insert a flash movie into
		a document on the fly.

		Usage:
		var movie=new dojox.embed.Flash({ args }, containerNode);
	 ******************************************************/
	var fMarkup, fVersion;
	var minimumVersion = 9; // anything below this will throw an error (may overwrite)
	var keyBase = "dojox-embed-flash-", keyCount=0;
	var _baseKwArgs = {
		expressInstall: false,
		width: 320,
		height: 240,
		swLiveConnect: "true",
		allowScriptAccess: "sameDomain",
		allowNetworking:"all",
		style: null,
		redirect: null
	};

	function prep(kwArgs){
		// console.warn("KWARGS:", kwArgs)
		kwArgs = dojo.delegate(_baseKwArgs, kwArgs);

		if(!("path" in kwArgs)){
			console.error("dojox.embed.Flash(ctor):: no path reference to a Flash movie was provided.");
			return null;
		}

		if(!("id" in kwArgs)){
			kwArgs.id = (keyBase + keyCount++);
		}
		return kwArgs;
	}

	if(dojo.isIE){
		fMarkup = function(kwArgs){
			kwArgs = prep(kwArgs);
			if(!kwArgs){ return null; }
			
			var p;
			var path = kwArgs.path;
			if(kwArgs.vars){
				var a = [];
				for(p in kwArgs.vars){
					a.push(p + '=' + kwArgs.vars[p]);
				}
				kwArgs.params.FlashVars = a.join("&");
				delete kwArgs.vars;
			}
			// FIXME: really? +'s?
			var s = '<object id="' + kwArgs.id + '" '
				+ 'classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" '
				+ 'width="' + kwArgs.width + '" '
				+ 'height="' + kwArgs.height + '"'
				+ ((kwArgs.style)?' style="' + kwArgs.style + '"':'')
				+ '>'
				+ '<param name="movie" value="' + path + '" />';
			if(kwArgs.params){
				for(p in kwArgs.params){
					s += '<param name="' + p + '" value="' + kwArgs.params[p] + '" />';
				}
			}
			s += '</object>';
			return { id: kwArgs.id, markup: s };
		};

		fVersion = (function(){
			var testVersion = 10, testObj = null;
			while(!testObj && testVersion > 7){
				try {
					testObj = new ActiveXObject("ShockwaveFlash.ShockwaveFlash." + testVersion--);
				}catch(e){ }
			}
			if(testObj){
				var v = testObj.GetVariable("$version").split(" ")[1].split(",");
				return {
					major: (v[0]!=null) ? parseInt(v[0]) : 0, 
					minor: (v[1]!=null) ? parseInt(v[1]) : 0, 
					rev: (v[2]!=null) ? parseInt(v[2]) : 0 
				};
			}
			return { major: 0, minor: 0, rev: 0 };
		})();

		//	attach some cleanup for IE, thanks to deconcept :)
		dojo.addOnUnload(function(){
			var dummy = function(){};
			var objs = dojo.query("object").
				reverse().
				style("display", "none").
				forEach(function(i){
					for(var p in i){
						if((p != "FlashVars") && dojo.isFunction(i[p])){
							try{
								i[p] = dummy;
							}catch(e){}
						}
					}
				});
		});

		//	TODO: ...and double check this fix; is IE really firing onbeforeunload with any kind of href="#" link?
		/*
		var beforeUnloadHandle = dojo.connect(dojo.global, "onbeforeunload", function(){
			try{
				if(__flash_unloadHandler){ __flash_unloadHandler=function(){ }; }
				if(__flash_savedUnloadHandler){ __flash_savedUnloadHandler=function(){ }; }
			} catch(e){ }
			dojo.disconnect(beforeUnloadHandle);
		});
		*/
	} else {
		//	*** Sane browsers branch ******************************************************************
		fMarkup = function(kwArgs){
			kwArgs = prep(kwArgs);
			if(!kwArgs){ return null; }
			
			var p;
			var path = kwArgs.path;
			if(kwArgs.vars){
				var a = [];
				for(p in kwArgs.vars){
					a.push(p + '=' + kwArgs.vars[p]);
				}
				kwArgs.params.flashVars = a.join("&");
				delete kwArgs.vars;
			}
			var s = '<embed type="application/x-shockwave-flash" '
				+ 'src="' + path + '" '
				+ 'id="' + kwArgs.id + '" '
				+ 'width="' + kwArgs.width + '" '
				+ 'height="' + kwArgs.height + '"'
				+ ((kwArgs.style)?' style="' + kwArgs.style + '" ':'')
				+ 'swLiveConnect="'+kwArgs.swLiveConnect+'" '
				+ 'allowScriptAccess="' +kwArgs.allowScriptAccess+  '" '
				+ 'allowNetworking="' +kwArgs.allowNetworking+  '" '
				
				+ 'pluginspage="' + window.location.protocol + '//www.adobe.com/go/getflashplayer" ';
			if(kwArgs.params){
				for(p in kwArgs.params){
					s += ' ' + p + '="' + kwArgs.params[p] + '"';
				}
			}
			s += ' />';
			return { id: kwArgs.id, markup: s };
		};

		fVersion=(function(){
			var plugin = navigator.plugins["Shockwave Flash"];
			if(plugin && plugin.description){
				var v = plugin.description.replace(/([a-zA-Z]|\s)+/, "").replace(/(\s+r|\s+b[0-9]+)/, ".").split(".");
				return { 
					major: (v[0]!=null) ? parseInt(v[0]) : 0, 
					minor: (v[1]!=null) ? parseInt(v[1]) : 0, 
					rev: (v[2]!=null) ? parseInt(v[2]) : 0 
				};
			}
			return { major: 0, minor: 0, rev: 0 };
		})();
	}


	/*=====
	dojox.embed.__flashArgs = function(path, id, width, height, style, params, vars, expressInstall, redirect){
		//	path: String
		//		The URL of the movie to embed.
		//	id: String?
		//		A unique key that will be used as the id of the created markup.  If you don't
		//		provide this, a unique key will be generated.
		//	width: Number?
		//		The width of the embedded movie; the default value is 320px.
		//	height: Number?
		//		The height of the embedded movie; the default value is 240px
		//	minimumVersion: Number ?
		//		The minimum targeted version of the Flash Player (defaults to 9) 
		//	style: String?
		//		Any CSS style information (i.e. style="background-color:transparent") you want
		//		to define on the markup.
		//	params: Object?
		//		A set of key/value pairs that you want to define in the resultant markup.
		//	vars: Object?
		//		A set of key/value pairs that the Flash movie will interpret as FlashVars.
		//	expressInstall: Boolean?
		//		Whether or not to include any kind of expressInstall info. Default is false.
		//	redirect: String?
		//		A url to redirect the browser to if the current Flash version is not supported.
		this.id=id;
		this.path=path;
		this.width=width;
		this.minimumVersion=minimumVersion;
		this.height=height;
		this.style=style;
		this.params=params;
		this.vars=vars;
		this.expressInstall=expressInstall;
		this.redirect=redirect;
	}
	=====*/

	//	the main entry point
	dojox.embed.Flash = function(/*dojox.embed.__flashArgs*/ kwArgs, /*DOMNode*/ node){
		//	summary:
		//		Creates a wrapper object around a Flash movie.  Wrapper object will
		//		insert the movie reference in node; when the browser first starts
		//		grabbing the movie, onReady will be fired; when the movie has finished
		//		loading, it will fire onLoad.
		//
		//		If your movie uses ExternalInterface, you should use the onLoad event
		//		to do any kind of proxy setup (see dojox.embed.Flash.proxy); this seems
		//		to be the only consistent time calling EI methods are stable (since the
		//		Flash movie will shoot several methods into the window object before
		//		EI callbacks can be used properly).
		//
		//	arguments:
		//		kwArgs: dojox.embed.__flashArgs
		//			See dojox.embed.__flashArgs
		//
		//		node:	DomNode
		//			The node where the embed object will be placed
		//
		// 	properties:
		//		id: String
		//			The ID of the internal embed/object tag.  Can be used to get a reference to
		//			the movie itself.
		//		movie: HTMLObject
		//			A reference to the Flash movie itself.
		//
		//	example:
		//		Embed a flash movie in a document using the new operator, and get a reference to it.
		//	|	var movie = new dojox.embed.Flash({
		//	|		path: "path/to/my/movie.swf",
		//	|		width: 400,
		//	|		height: 300
		//	|	}, myWrapperNode, "testLoaded");
		//
		//	example:
		//		Embed a flash movie in a document without using the new operator.
		//	|	var movie = dojox.embed.Flash({
		//	|		path: "path/to/my/movie.swf",
		//	|		width: 400,
		//	|		height: 300,
		//	|		style: "position:absolute;top:0;left:0"
		//	|	}, myWrapperNode, "testLoaded");
		//
		// File can only be run from a server, due to SWF dependency.
		if(location.href.toLowerCase().indexOf("file://")>-1){
			throw new Error("dojox.embed.Flash can't be run directly from a file. To instatiate the required SWF correctly it must be run from a server, like localHost.");
		}
		this.available = dojox.embed.Flash.available;
		this.minimumVersion = kwArgs.minimumVersion || minimumVersion;
		//console.log("AVAILABLE:", this);
		this.id = null;
		this.movie = null;
		this.domNode = null;
		if(node){
			node = dojo.byId(node);
		}
		// setTimeout Fixes #8743 - creating double SWFs
		// also allows time for code to attach to onError
		setTimeout(dojo.hitch(this, function(){
			if(kwArgs.expressInstall || this.available && this.available >= this.minimumVersion){
				if(kwArgs && node){
					this.init(kwArgs, node);
				}else{
					this.onError("embed.Flash was not provided with the proper arguments.");
				}
			}else{
				if(!this.available){
					this.onError("Flash is not installed.");
				}else{
					this.onError("Flash version detected: "+this.available+" is out of date. Minimum required: "+this.minimumVersion);
				}
			}
		}), 100);
	};

	dojo.extend(dojox.embed.Flash, {
		onReady: function(/*HTMLObject*/ movie){
			console.warn("embed.Flash.movie.onReady:", movie)
			//	summary:
			//		Stub function for you to attach to when the movie reference is first
			//		pushed into the document.
		},
		onLoad: function(/*HTMLObject*/ movie){
			console.warn("embed.Flash.movie.onLoad:", movie)
			//	summary:
			//		Stub function for you to attach to when the movie has finished downloading
			//		and is ready to be manipulated.
		},
		onError: function(msg){
			
		},
		_onload: function(){
			// summary:
			//	Internal. Cleans up before calling onLoad. 
			clearInterval(this._poller);
			delete this._poller;
			delete this._pollCount;
			delete this._pollMax;
			this.onLoad(this.movie);
		},
		init: function(/*dojox.embed.__flashArgs*/ kwArgs, /*DOMNode?*/ node){
			console.log("embed.Flash.movie.init")
			//	summary
			//		Initialize (i.e. place and load) the movie based on kwArgs.
			this.destroy();		//	ensure we are clean first.
			node = dojo.byId(node || this.domNode);
			if(!node){ throw new Error("dojox.embed.Flash: no domNode reference has been passed."); }
			
			// vars to help determine load status
			var p = 0, testLoaded=false;
			this._poller = null; this._pollCount = 0; this._pollMax = 15; this.pollTime = 100;
			
			if(dojox.embed.Flash.initialized){
				
				this.id = dojox.embed.Flash.place(kwArgs, node);
				this.domNode = node;

				setTimeout(dojo.hitch(this, function(){
					this.movie = this.byId(this.id, kwArgs.doc);
					this.onReady(this.movie);
					
					this._poller = setInterval(dojo.hitch(this, function(){
						
						// catch errors if not quite ready.
						try{
							p = this.movie.PercentLoaded();
						}catch(e){
							/* squelch */
							console.warn("this.movie.PercentLoaded() failed");
						}
						
						if(p == 100){
							// if percent = 100, movie is fully loaded and we're communicating
							this._onload();
						
						}else if(p==0 && this._pollCount++ > this._pollMax){
							// after several attempts, we're not past zero.
							// FIXME: What if we get stuck on 33% or something?
							clearInterval(this._poller);
							throw new Error("Building SWF failed.");
						}
					}), this.pollTime);
				}), 1);
			}
		},
		_destroy: function(){
			//	summary
			//		Kill the movie and reset all the properties of this object.
			try{
				this.domNode.removeChild(this.movie);
			}catch(e){}
			this.id = this.movie = this.domNode = null;
		},
		destroy: function(){
			//	summary
			//		Public interface for destroying all the properties in this object.
			//		Will also clean all proxied methods.
			if(!this.movie){ return; }
			
			//	remove any proxy functions
			var test = dojo.delegate({ 
				id: true,
				movie: true,
				domNode: true,
				onReady: true,
				onLoad: true 
			});
			for(var p in this){
				if(!test[p]){
					delete this[p];
				}
			}

			//	poll the movie
			if(this._poller){
				//	wait until onLoad to destroy
				dojo.connect(this, "onLoad", this, "_destroy");
			} else {
				this._destroy();
			}
		},
		byId: function (movieName, doc){
			// 	summary:
			//		Gets Flash movie by id.
			//	description:
			//		Probably includes methods for outdated
			//		browsers, but this should catch all cases.
			// arguments:
			//		movieName: String
			//			The name of the SWF
			//		doc: Object
			//			The document, if not current window
			//			(not fully supported)
			//	example:
			//	| var movie = dojox.embed.Flash.byId("myId");
			//
			doc = doc || document;
			if(doc.embeds[movieName]){
				return doc.embeds[movieName];
			}
			if(doc[movieName]){
				return doc[movieName];
			}
			if(window[movieName]){
				return window[movieName];
			}
			if(document[movieName]){
				return document[movieName];
			}
			return null;
		}
	});
	
	//	expose information through the constructor function itself.
	dojo.mixin(dojox.embed.Flash, {
		//	summary:
		//		A singleton object used internally to get information
		//		about the Flash player available in a browser, and
		//		as the factory for generating and placing markup in a
		//		document.
		//
		//	minSupported: Number
		//		The minimum supported version of the Flash Player, defaults to 8.
		//	available: Number
		//		Used as both a detection (i.e. if(dojox.embed.Flash.available){ })
		//		and as a variable holding the major version of the player installed.
		//	supported: Boolean
		//		Whether or not the Flash Player installed is supported by dojox.embed.
		//	version: Object
		//		The version of the installed Flash Player; takes the form of
		//		{ major, minor, rev }.  To get the major version, you'd do this:
		//		var v=dojox.embed.Flash.version.major;
		//	initialized: Boolean
		//		Whether or not the Flash engine is available for use.
		//	onInitialize: Function
		//		A stub you can connect to if you are looking to fire code when the 
		//		engine becomes available.  A note: DO NOT use this event to
		//		place a movie in a document; it will usually fire before DOMContentLoaded
		//		is fired, and you will get an error.  Use dojo.addOnLoad instead.
		minSupported : 8,
		available: fVersion.major,
		supported: (fVersion.major >= fVersion.required),
		minimumRequired: fVersion.required,
		version: fVersion,
		initialized: false,
		onInitialize: function(){
			dojox.embed.Flash.initialized = true;
		},
		__ie_markup__: function(kwArgs){
			return fMarkup(kwArgs);
		},
		proxy: function(/*dojox.embed.Flash*/ obj, /*Array|String*/ methods){
			//	summary:
			//		Create the set of passed methods on the dojox.embed.Flash object
			//		so that you can call that object directly, as opposed to having to
			//		delve into the internal movie to do this.  Intended to make working
			//		with Flash movies that use ExternalInterface much easier to use.
			//
			//	example:
			//		Create "setMessage" and "getMessage" methods on foo.
			//	|	var foo = new dojox.embed.Flash(args, someNode);
			//	|	dojo.connect(foo, "onLoad", dojo.hitch(foo, function(){
			//	|		dojox.embed.Flash.proxy(this, [ "setMessage", "getMessage" ]);
			//	|		this.setMessage("dojox.embed.Flash.proxy is pretty cool...");
			//	|		console.log(this.getMessage());
			//	|	}));
			dojo.forEach((dojo.isArray(methods) ? methods : [ methods ]), function(item){
				this[item] = dojo.hitch(this, function(){
					return (function(){
						return eval(this.movie.CallFunction(
							'<invoke name="' + item + '" returntype="javascript">'
							+ '<arguments>'
							+ dojo.map(arguments, function(item){
								// FIXME: 
								//		investigate if __flash__toXML will
								//		accept direct application via map()
								//		(e.g., does it ignore args past the
								//		first? or does it blow up?)
								return __flash__toXML(item);
							}).join("")
							+ '</arguments>'
							+ '</invoke>'
						));
					}).apply(this, arguments||[]);
				});
			}, obj);
		}
	});

	if(dojo.isIE){
		//	Ugh!
		if(dojo._initFired){
			var e = document.createElement("script");
			e.type = "text/javascript";
			e.src = dojo.moduleUrl("dojox", "embed/IE/flash.js");
			document.getElementsByTagName("head")[0].appendChild(e);
		}else{
			//	we can use document.write.  What a kludge.
			document.write('<scr'+'ipt type="text/javascript" src="' + dojo.moduleUrl("dojox", "embed/IE/flash.js") + '">'
				+ '</scr'+'ipt>');
		}
	}else{
		dojox.embed.Flash.place = function(kwArgs, node){
			var o = fMarkup(kwArgs);
			node = dojo.byId(node);
			if(!node){ 
				node = dojo.doc.createElement("div");
				node.id = o.id+"-container";
				dojo.body().appendChild(node);
			}
			if(o){
				node.innerHTML = o.markup;
				return o.id;
			}
			return null;
		}
		dojox.embed.Flash.onInitialize();
	}
})();

}

if(!dojo._hasResource["dojo.io.iframe"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.io.iframe"] = true;
dojo.provide("dojo.io.iframe");

/*=====
dojo.declare("dojo.io.iframe.__ioArgs", dojo.__IoArgs, {
	constructor: function(){
		//	summary:
		//		All the properties described in the dojo.__ioArgs type, apply
		//		to this type. The following additional properties are allowed
		//		for dojo.io.iframe.send():
		//	method: String?
		//		The HTTP method to use. "GET" or "POST" are the only supported
		//		values.  It will try to read the value from the form node's
		//		method, then try this argument. If neither one exists, then it
		//		defaults to POST.
		//	handleAs: String?
		//		Specifies what format the result data should be given to the
		//		load/handle callback. Valid values are: text, html, xml, json,
		//		javascript. IMPORTANT: For all values EXCEPT html and xml, The
		//		server response should be an HTML file with a textarea element.
		//		The response data should be inside the textarea element. Using an
		//		HTML document the only reliable, cross-browser way this
		//		transport can know when the response has loaded. For the html
		//		handleAs value, just return a normal HTML document.  NOTE: xml
		//		is now supported with this transport (as of 1.1+); a known issue
		//		is if the XML document in question is malformed, Internet Explorer
		//		will throw an uncatchable error.
		//	content: Object?
		//		If "form" is one of the other args properties, then the content
		//		object properties become hidden form form elements. For
		//		instance, a content object of {name1 : "value1"} is converted
		//		to a hidden form element with a name of "name1" and a value of
		//		"value1". If there is not a "form" property, then the content
		//		object is converted into a name=value&name=value string, by
		//		using dojo.objectToQuery().
		this.method = method;
		this.handleAs = handleAs;
		this.content = content;
	}
});
=====*/

dojo.io.iframe = {
	// summary: 
	//		Sends an Ajax I/O call using and Iframe (for instance, to upload files)
	
	create: function(/*String*/fname, /*String*/onloadstr, /*String?*/uri){
		//	summary:
		//		Creates a hidden iframe in the page. Used mostly for IO
		//		transports.  You do not need to call this to start a
		//		dojo.io.iframe request. Just call send().
		//	fname: String
		//		The name of the iframe. Used for the name attribute on the
		//		iframe.
		//	onloadstr: String
		//		A string of JavaScript that will be executed when the content
		//		in the iframe loads.
		//	uri: String
		//		The value of the src attribute on the iframe element. If a
		//		value is not given, then dojo/resources/blank.html will be
		//		used.
		if(window[fname]){ return window[fname]; }
		if(window.frames[fname]){ return window.frames[fname]; }
		var cframe = null;
		var turi = uri;
		if(!turi){
			if(dojo.config["useXDomain"] && !dojo.config["dojoBlankHtmlUrl"]){
				console.warn("dojo.io.iframe.create: When using cross-domain Dojo builds,"
					+ " please save dojo/resources/blank.html to your domain and set djConfig.dojoBlankHtmlUrl"
					+ " to the path on your domain to blank.html");
			}
			turi = (dojo.config["dojoBlankHtmlUrl"]||dojo.moduleUrl("dojo", "resources/blank.html"));
		}
		var ifrstr = dojo.isIE ? '<iframe name="'+fname+'" src="'+turi+'" onload="'+onloadstr+'">' : 'iframe';
		cframe = dojo.doc.createElement(ifrstr);
		with(cframe){
			name = fname;
			setAttribute("name", fname);
			id = fname;
		}
		dojo.body().appendChild(cframe);
		window[fname] = cframe;
	
		with(cframe.style){
			if(!(dojo.isSafari < 3)){
				//We can't change the src in Safari 2.0.3 if absolute position. Bizarro.
				position = "absolute";
			}
			left = top = "1px";
			height = width = "1px";
			visibility = "hidden";
		}

		if(!dojo.isIE){
			this.setSrc(cframe, turi, true);
			cframe.onload = new Function(onloadstr);
		}

		return cframe;
	},

	setSrc: function(/*DOMNode*/iframe, /*String*/src, /*Boolean*/replace){
		//summary:
		//		Sets the URL that is loaded in an IFrame. The replace parameter
		//		indicates whether location.replace() should be used when
		//		changing the location of the iframe.
		try{
			if(!replace){
				if(dojo.isWebKit){
					iframe.location = src;
				}else{
					frames[iframe.name].location = src;
				}
			}else{
				// Fun with DOM 0 incompatibilities!
				var idoc;
				//WebKit > 521 corresponds with Safari 3, which started with 522 WebKit version.
				if(dojo.isIE || dojo.isWebKit > 521){
					idoc = iframe.contentWindow.document;
				}else if(dojo.isSafari){
					idoc = iframe.document;
				}else{ //  if(d.isMozilla){
					idoc = iframe.contentWindow;
				}
	
				//For Safari (at least 2.0.3) and Opera, if the iframe
				//has just been created but it doesn't have content
				//yet, then iframe.document may be null. In that case,
				//use iframe.location and return.
				if(!idoc){
					iframe.location = src;
					return;
				}else{
					idoc.location.replace(src);
				}
			}
		}catch(e){ 
			console.log("dojo.io.iframe.setSrc: ", e); 
		}
	},

	doc: function(/*DOMNode*/iframeNode){
		//summary: Returns the document object associated with the iframe DOM Node argument.
		var doc = iframeNode.contentDocument || // W3
			(
				(
					(iframeNode.name) && (iframeNode.document) && 
					(dojo.doc.getElementsByTagName("iframe")[iframeNode.name].contentWindow) &&
					(dojo.doc.getElementsByTagName("iframe")[iframeNode.name].contentWindow.document)
				)
			) ||  // IE
			(
				(iframeNode.name)&&(dojo.doc.frames[iframeNode.name])&&
				(dojo.doc.frames[iframeNode.name].document)
			) || null;
		return doc;
	},

	send: function(/*dojo.io.iframe.__ioArgs*/args){
		//summary: 
		//		Function that sends the request to the server.
		//		This transport can only process one send() request at a time, so if send() is called
		//multiple times, it will queue up the calls and only process one at a time.
		if(!this["_frame"]){
			this._frame = this.create(this._iframeName, dojo._scopeName + ".io.iframe._iframeOnload();");
		}

		//Set up the deferred.
		var dfd = dojo._ioSetArgs(
			args,
			function(/*Deferred*/dfd){
				//summary: canceller function for dojo._ioSetArgs call.
				dfd.canceled = true;
				dfd.ioArgs._callNext();
			},
			function(/*Deferred*/dfd){
				//summary: okHandler function for dojo._ioSetArgs call.
				var value = null;
				try{
					var ioArgs = dfd.ioArgs;
					var dii = dojo.io.iframe;
					var ifd = dii.doc(dii._frame);
					var handleAs = ioArgs.handleAs;

					//Assign correct value based on handleAs value.
					value = ifd; //html
					if(handleAs != "html"){
						if(handleAs == "xml"){
							//	FF, Saf 3+ and Opera all seem to be fine with ifd being xml.  We have to
							//	do it manually for IE.  Refs #6334.
							if(dojo.isIE){
								dojo.query("a", dii._frame.contentWindow.document.documentElement).orphan();
								var xmlText=(dii._frame.contentWindow.document).documentElement.innerText;
								xmlText=xmlText.replace(/>\s+</g, "><");
								xmlText=dojo.trim(xmlText);
								//Reusing some code in base dojo for handling XML content.  Simpler and keeps
								//Core from duplicating the effort needed to locate the XML Parser on IE.
								var fauxXhr = { responseText: xmlText };
								value = dojo._contentHandlers["xml"](fauxXhr); // DOMDocument
							}
						}else{
							value = ifd.getElementsByTagName("textarea")[0].value; //text
							if(handleAs == "json"){
								value = dojo.fromJson(value); //json
							}else if(handleAs == "javascript"){
								value = dojo.eval(value); //javascript
							}
						}
					}
				}catch(e){
					value = e;
				}finally{
					ioArgs._callNext();				
				}
				return value;
			},
			function(/*Error*/error, /*Deferred*/dfd){
				//summary: errHandler function for dojo._ioSetArgs call.
				dfd.ioArgs._hasError = true;
				dfd.ioArgs._callNext();
				return error;
			}
		);

		//Set up a function that will fire the next iframe request. Make sure it only
		//happens once per deferred.
		dfd.ioArgs._callNext = function(){
			if(!this["_calledNext"]){
				this._calledNext = true;
				dojo.io.iframe._currentDfd = null;
				dojo.io.iframe._fireNextRequest();
			}
		}

		this._dfdQueue.push(dfd);
		this._fireNextRequest();
		
		//Add it the IO watch queue, to get things like timeout support.
		dojo._ioWatch(
			dfd,
			function(/*Deferred*/dfd){
				//validCheck
				return !dfd.ioArgs["_hasError"];
			},
			function(dfd){
				//ioCheck
				return (!!dfd.ioArgs["_finished"]);
			},
			function(dfd){
				//resHandle
				if(dfd.ioArgs._finished){
					dfd.callback(dfd);
				}else{
					dfd.errback(new Error("Invalid dojo.io.iframe request state"));
				}
			}
		);

		return dfd;
	},

	_currentDfd: null,
	_dfdQueue: [],
	_iframeName: dojo._scopeName + "IoIframe",

	_fireNextRequest: function(){
		//summary: Internal method used to fire the next request in the bind queue.
		try{
			if((this._currentDfd)||(this._dfdQueue.length == 0)){ return; }
			//Find next deferred, skip the canceled ones.
			do{
				var dfd = this._currentDfd = this._dfdQueue.shift();
			} while(dfd && dfd.canceled && this._dfdQueue.length);

			//If no more dfds, cancel.
			if(!dfd || dfd.canceled){
				this._currentDfd =  null;
				return;
			}

			var ioArgs = dfd.ioArgs;
			var args = ioArgs.args;

			ioArgs._contentToClean = [];
			var fn = dojo.byId(args["form"]);
			var content = args["content"] || {};
			if(fn){
				if(content){
					// if we have things in content, we need to add them to the form
					// before submission
					var pHandler = function(name, value) {
						var tn;
						if(dojo.isIE){
							tn = dojo.doc.createElement("<input type='hidden' name='"+name+"'>");
						}else{
							tn = dojo.doc.createElement("input");
							tn.type = "hidden";
							tn.name = name;
						}
						tn.value = value;
						fn.appendChild(tn);
						ioArgs._contentToClean.push(name);
					};
					for(var x in content){
						var val = content[x];
						if(dojo.isArray(val) && val.length > 1){
							var i;
							for (i = 0; i < val.length; i++) {
								pHandler(x,val[i]);
							}
						}else{
							if(!fn[x]){
								pHandler(x,val);
							}else{
								fn[x].value = val;
							}
						}
					}
				}
				//IE requires going through getAttributeNode instead of just getAttribute in some form cases, 
				//so use it for all.  See #2844
				var actnNode = fn.getAttributeNode("action");
				var mthdNode = fn.getAttributeNode("method");
				var trgtNode = fn.getAttributeNode("target");
				if(args["url"]){
					ioArgs._originalAction = actnNode ? actnNode.value : null;
					if(actnNode){
						actnNode.value = args.url;
					}else{
						fn.setAttribute("action",args.url);
					}
				}
				if(!mthdNode || !mthdNode.value){
					if(mthdNode){
						mthdNode.value= (args["method"]) ? args["method"] : "post";
					}else{
						fn.setAttribute("method", (args["method"]) ? args["method"] : "post");
					}
				}
				ioArgs._originalTarget = trgtNode ? trgtNode.value: null;
				if(trgtNode){
					trgtNode.value = this._iframeName;
				}else{
					fn.setAttribute("target", this._iframeName);
				}
				fn.target = this._iframeName;
				dojo._ioNotifyStart(dfd);
				fn.submit();
			}else{
				// otherwise we post a GET string by changing URL location for the
				// iframe
				var tmpUrl = args.url + (args.url.indexOf("?") > -1 ? "&" : "?") + ioArgs.query;
				dojo._ioNotifyStart(dfd);
				this.setSrc(this._frame, tmpUrl, true);
			}
		}catch(e){
			dfd.errback(e);
		}
	},

	_iframeOnload: function(){
		var dfd = this._currentDfd;
		if(!dfd){
			this._fireNextRequest();
			return;
		}

		var ioArgs = dfd.ioArgs;
		var args = ioArgs.args;
		var fNode = dojo.byId(args.form);
	
		if(fNode){
			// remove all the hidden content inputs
			var toClean = ioArgs._contentToClean;
			for(var i = 0; i < toClean.length; i++) {
				var key = toClean[i];
				//Need to cycle over all nodes since we may have added
				//an array value which means that more than one node could
				//have the same .name value.
				for(var j = 0; j < fNode.childNodes.length; j++){
					var chNode = fNode.childNodes[j];
					if(chNode.name == key){
						dojo.destroy(chNode);
						break;
					}
				}
			}

			// restore original action + target
			if(ioArgs["_originalAction"]){
				fNode.setAttribute("action", ioArgs._originalAction);
			}
			if(ioArgs["_originalTarget"]){
				fNode.setAttribute("target", ioArgs._originalTarget);
				fNode.target = ioArgs._originalTarget;
			}
		}

		ioArgs._finished = true;
	}
}

}

if(!dojo._hasResource["dojox.html.styles"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.html.styles"] = true;
dojo.provide("dojox.html.styles");
	
	// summary:
	//		Methods for creating and minipulating dynamic CSS Styles and Style Sheets
	//
	// example:
	//		| dojox.html.createStyle("#myDiv input", "font-size:24px");
	//			Creates Style #myDiv input, which can now be applied to myDiv, and 
	//			the inner input will be targeted
	//		| dojox.html.createStyle(".myStyle", "color:#FF0000");
	//			Now the class myStyle can be assigned to a node's className
	
(function(){
	
	var dynamicStyleMap = {};
	var pageStyleSheets = {};
	var titledSheets = [];
	var styleIndicies = [];
	
	dojox.html.insertCssRule = function(/*String*/selector, /*String*/declaration, /*String*/styleSheetName){
		// summary:
		//	Creates a style and attaches it to a dynamically created stylesheet
		//	arguments:
		//		selector: 	
		//					A fully qualified class name, as it would appear in
		//					a CSS dojo.doc. Start classes with periods, target
		//					nodes with '#'. Large selectors can also be created
		//					like:
		//					| "#myDiv.myClass span input"
		//		declaration:
		//					A single string that would make up a style block, not
		//					including the curly braces. Include semi-colons between
		//					statements. Do not use JavaScript style declarations
		//					in camel case, use as you would in a CSS dojo.doc:
		//					| "color:#ffoooo;font-size:12px;margin-left:5px;"
		//		styleSheetName: ( optional )
		//					Name of the dynamic style sheet this rule should be 
		//					inserted into. If is not found by that name, it is
		//					created. If no name is passed, the name "default" is 
		//					used.
		//
		var ss = dojox.html.getDynamicStyleSheet(styleSheetName);
		var styleText = selector + " {" + declaration + "}";
		console.log("insertRule:", styleText)
		if(dojo.isIE){
			// Note: check for if(ss.cssText) does not work
			ss.cssText+=styleText;
			console.log("ss.cssText:", ss.cssText)
		}else if(ss.sheet){
			ss.sheet.insertRule(styleText, ss._indicies.length);
		}else{
			ss.appendChild(dojo.doc.createTextNode(styleText));
		}
		ss._indicies.push(selector+" "+declaration);
		return selector; // String 
	
	}
	
	dojox.html.removeCssRule = function(/*String*/selector, /*String*/declaration, /*String*/styleSheetName){
		// summary:
		//		Removes a cssRule base on the selector and declaration passed
		//		The declaration is needed for cases of dupe selectors
		// description: Only removes DYNAMICALLY created cssRules. If you 
		//		created it with dojox.html.insertCssRule, it can be removed.
		//
		var ss;
		var index=-1;
		for(var nm in dynamicStyleMap){
			if(styleSheetName && styleSheetName!=nm) {continue;}
			ss = dynamicStyleMap[nm];
			for(var i=0;i<ss._indicies.length;i++){
				if(selector+" "+declaration == ss._indicies[i]){
					index = i;
					break;
				}
			}
			if(index>-1) { break; }
		}
		if(!ss){
			console.log("No dynamic style sheet has been created from which to remove a rule.");
			return false;
		}
		if(index==-1){
			console.log("The css rule was not found and could not be removed.");
			return false;
		}
		
		ss._indicies.splice(index, 1);
		
		
		
		if(dojo.isIE){ 
			// Note: check for if(ss.removeRule) does not work
			ss.removeRule(index);
		}else if(ss.sheet){
			ss.sheet.deleteRule(index);
		}else if(document.styleSheets[0]){
			console.log("what browser hath useth thith?")
			//
		}
		return true; //Boolean
		
	}
	
	/* TODO
	dojox.html.modifyCssRule = function(selector, declaration, styleSheetName){
		Not implemented - it seems to have some merit for changing some complex 
		selectors. It's not much use for changing simple ones like "span".
		For now, simply write a new rule which will cascade over the first.
		// summary
		//	Modfies an existing cssRule
	}
	*/
	
	dojox.html.getStyleSheet = function(/*String*/styleSheetName){
		// summary:
		//		Returns a style sheet based on the argument.
		//		Searches dynamic style sheets first. If no matches,
		//		searches document style sheets.
		//
		// argument: (optional)
		//		A title or an href to a style sheet. Title can be 
		//		an attribute in a tag, or a dynamic style sheet 
		//		reference. Href can be the name of the file.
		//		If no argument, the assumed created dynamic style 
		//		sheet is used.
		
		// try dynamic sheets first 
		if(dynamicStyleMap[styleSheetName || "default"]){
			return dynamicStyleMap[styleSheetName || "default"];
		}
		if(!styleSheetName){
			// no arg is nly good for the default style sheet 
			// and it has not been created yet.
			return false;
		}
		
		var allSheets = dojox.html.getStyleSheets();
		
		// now try document style sheets by name
		if(allSheets[styleSheetName]){
			return dojox.html.getStyleSheets()[styleSheetName];
		}
		
		// check for partial matches in hrefs (so that a fully 
		//qualified name does not have to be passed)
		for ( var nm in allSheets){
			if(	allSheets[nm].href && allSheets[nm].href.indexOf(styleSheetName)>-1){
				return allSheets[nm];
			}
		}
		return false; //StyleSheet or false
	}
	
	dojox.html.getDynamicStyleSheet = function(/*String*/styleSheetName){
		// summary:
		//		Creates and returns a dynamically created style sheet
		// 		used for dynamic styles
		//
		//	argument:
		//			styleSheetName /* optional String */
		//			The name given the style sheet so that multiple 
		//			style sheets can be created and referenced. If 
		//			no argument is given, the name "default" is used.
		//
		if(!styleSheetName){ styleSheetName="default"; }
		
		if(!dynamicStyleMap[styleSheetName]){
			if(dojo.doc.createStyleSheet){ //IE
			
				dynamicStyleMap[styleSheetName] = dojo.doc.createStyleSheet();
				dynamicStyleMap[styleSheetName].title = styleSheetName;

			}else{
				dynamicStyleMap[styleSheetName] = dojo.doc.createElement("style");
				dynamicStyleMap[styleSheetName].setAttribute("type", "text/css");
				dojo.doc.getElementsByTagName("head")[0].appendChild(dynamicStyleMap[styleSheetName]);
				console.log(styleSheetName, " ss created: ", dynamicStyleMap[styleSheetName].sheet);
			}
			dynamicStyleMap[styleSheetName]._indicies = [];
		}
		
		
		return dynamicStyleMap[styleSheetName]; //StyleSheet
	}

	dojox.html.enableStyleSheet = function(/*String*/styleSheetName){
		// summary:
		//		Enables the style sheet with the name passed in the
		//		argument. Deafults to the default style sheet.
		//
		var ss = dojox.html.getStyleSheet(styleSheetName);
		if(ss){ 
			if(ss.sheet){
				ss.sheet.disabled = false; 
			}else{
				ss.disabled = false; 
			}
		}
	}

	dojox.html.disableStyleSheet = function(styleSheetName){
		// summary:
		//		Disables the dynamic style sheet with the name passed in the
		//		argument. If no arg is passed, defaults to the default style sheet.
		//
		var ss = dojox.html.getStyleSheet(styleSheetName);
		if(ss){ 
			if(ss.sheet){
				ss.sheet.disabled = true; 
			}else{
				ss.disabled = true; 
			}
		}
	}
	
	dojox.html.activeStyleSheet = function(/*?String*/title){
		// summary:
		//		Getter/Setter
		// description:
		//		If passed a title, enables a that style sheet. All other
		//		toggle-able style sheets are disabled.
		//		If no argument is passed, returns currently enabled
		//		style sheet.
		//
		var sheets = dojox.html.getToggledStyleSheets();
		if(arguments.length == 1){
			//console.log("sheets:", sheets);
			dojo.forEach(sheets, function(s){
				s.disabled = (s.title == title) ? false : true;
				//console.log("SWITCHED:", s.title, s.disabled, s.id);
			});
		}else{
			for(var i=0; i<sheets.length;i++){
				if(sheets[i].disabled == false){
					return sheets[i];
				}
			}
		}
		return true; //StyleSheet or Boolean - FIXME - doesn't make a lot of sense
	}
	
	dojox.html.getPreferredStyleSheet = function(){
		// summary
		//	Returns the style sheet that was initially enabled
		//	on document launch.
		
		//TODO
	}
	
	
	
	
	dojox.html.getToggledStyleSheets = function(){
		// summary:
		//		Searches HTML for style sheets that are "toggle-able" - 
		//		can be enabled and disabled. These would include sheets
		//		with the title attribute, as well as the REL attribute.
		//	returns:
		//		An array of all toggle-able style sheets
		//	TODO: 	Sets of style sheets could be grouped according to
		//			an ID and used in sets, much like different
		//			groups of radio buttons. It would not however be
		//			according to W3C spec
		//
		if(!titledSheets.length){
			var sObjects = dojox.html.getStyleSheets();
			for(var nm in sObjects){
				
				if(sObjects[nm].title){
					//console.log("TITLE:", sObjects[nm].title, sObjects[nm])
					titledSheets.push(sObjects[nm]);
				}
			}
		}
		return titledSheets; //Array
	}
	
	
	dojox.html.getStyleSheets = function(){
		// summary:
		//		Collects all the style sheets referenced in the HTML page,
		//		including any incuded via @import. 
		//
		//	returns: 
		//		An hash map of all the style sheets.
		//
		//	TODO: 	Does not recursively search for @imports, so it will
		//			only go one level deep.
		//
		if(pageStyleSheets.collected) {return pageStyleSheets;}
		
		var sheets = dojo.doc.styleSheets;
		//console.log("styleSheets:", sheets);
		dojo.forEach(sheets, function(n){
			var s = (n.sheet) ? n.sheet : n;
			var name = s.title || s.href;
			if(dojo.isIE){
				// IE attaches a style sheet for VML - do not include this
				if(s.cssText.indexOf("#default#VML")==-1){
					
					
					if(s.href){
						// linked		
						pageStyleSheets[name] = s;
					
					}else if(s.imports.length){
						// Imported via @import
						dojo.forEach(s.imports, function(si){
							pageStyleSheets[si.title || si.href] = si;
						});
						
					}else{
						//embedded within page
						pageStyleSheets[name] = s;
					}
				}
				
			}else{
				//linked or embedded
				pageStyleSheets[name] = s;
				pageStyleSheets[name].id = s.ownerNode.id;
				dojo.forEach(s.cssRules, function(r){
					if(r.href){
						// imported
						pageStyleSheets[r.href] = r.styleSheet;
						pageStyleSheets[r.href].id = s.ownerNode.id;
					}
				});
			
			}
			
		});
		
		//console.log("pageStyleSheets:", pageStyleSheets);
		
		
		pageStyleSheets.collected = true;
		return pageStyleSheets; //Object
	}
	

})();

}

if(!dojo._hasResource["dojox.embed.flashVars"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.embed.flashVars"] = true;
dojo.provide("dojox.embed.flashVars");

dojo.mixin(dojox.embed.flashVars, {
	//	summary
	//		Handles flashvar serialization
	//		Converting complex objects into a simple, clear string that can be appended
	//		to the swf as a query: myMovie.swf?flashvars=foo.
	//		Note this needs to work with the SWF, which must know what variables to expect.
	//		Therefore this is something of an "internal" class - unless you know how to
	//		modify or create SWFs.
	//
	//	description:
	//		JSON could be done, but Deft does not yet have a JSON parser, and quotes are
	//		very problematic since Flash cannot use eval(); JSON parsing was successful
	//		when it was fully escaped, but that made it very large anyway. flashvar
	//		serialization at most is 200% larger than JSON.
	//
	//	See:
	//		Deft/common/flashVars.as
	//
	serialize: function(/* String */n, /*Object*/o){
		// summary:
		//		Key method. Serializes an object.
		//	n:String
		//		The name for the object, such as: "button"
		//	o:Object
		//		The object to serialize
		//
		var esc = function(val){
			//	have to encode certain characters that indicate an object
			if(typeof val=="string"){
				val = val.replace(/;/g,"_sc_");
				val = val.replace(/\./g,"_pr_");
				val = val.replace(/\:/g,"_cl_");
				//val = escape(val);
			}
			return val;
		};
		var df = dojox.embed.flashVars.serialize;
		var txt = "";
		if(dojo.isArray(o)){
			for(var i=0;i<o.length;i++){
				txt += df(n+"."+i, esc(o[i]))+";";
			}
			return txt.replace(/;{2,}/g,";");
		}else if(dojo.isObject(o)){
			for(var nm in o){
				txt += df(n+"."+nm, esc(o[nm]))+";";
			}
			return txt.replace(/;{2,}/g,";");
		}
		// Dev note: important that there is no double semi-colons
		return n+":"+o; // String
	}
});

}

if(!dojo._hasResource["dojox.form.FileUploader"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.form.FileUploader"] = true;
dojo.provide("dojox.form.FileUploader");








dojo.experimental("dojox.form.FileUploader");

	
	//	Usage Notes:
	//		To center text vertically, use vertical-align:middle;
	//			which emulates a boxModel button. Using line-height to center text
	//			can cause height problems in IE6
	
	
(function(){
	
	var swfPath = dojo.config.uploaderPath || dojo.moduleUrl("dojox.form", "resources/uploader.swf");
	
	var urlencode = function(url){
		// Using symbols in place of URL chars that will break in Flash serialization.
		if(!url || url == "none"){
			return false;
		}
		return url.replace(/:/g,"||").replace(/\./g,"^^").replace("url(", "").replace(")","").replace(/'/g,"").replace(/"/g,"");
	};
	
	var isButton = function(node){
		// testing if button for styling purposes
		var tn = node.tagName.toLowerCase();
		return tn == "button" || tn == "input";
	};
	
	var getTextStyle = function(node){
		// getting font info
		var o = {};
		o.ff = dojo.style(node, "fontFamily");
		if(o.ff){
			o.ff = o.ff.replace(", ", ","); // remove spaces. IE in Flash no likee
			o.ff = o.ff.replace(/\"|\'/g, "");
			o.ff = o.ff == "sans-serif" ? "Arial" : o.ff; // Flash doesn't know what sans-serif is
			o.fw = dojo.style(node, "fontWeight");
			o.fi = dojo.style(node, "fontStyle");
			o.fs = parseInt(dojo.style(node, "fontSize"), 10);			
			if(dojo.style(node, "fontSize").indexOf("%") > -1){
				// IE doesn't convert % to px. For god sakes.
				var n = node;
				while(n.tagName){
					console.log(" P FONT:", dojo.style(node, "fontSize"))
					if(dojo.style(n, "fontSize").indexOf("%") == -1){
						o.fs = parseInt(dojo.style(n, "fontSize"), 10);
						break;
					}
					if(n.tagName.toLowerCase()=="body"){
						// if everyting is %, the the font size is 16px * the %
						o.fs = 16 * .01 * parseInt(dojo.style(n, "fontSize"), 10);
					}
					n = n.parentNode;
				}
			}
			o.fc = new dojo.Color(dojo.style(node, "color")).toHex();
			o.fc = parseInt(o.fc.substring(1,Infinity),16);
		}
		o.lh = dojo.style(node, "lineHeight");
		o.ta = dojo.style(node, "textAlign");
		o.ta = o.ta == "start" || !o.ta ? "left" : o.ta;
		o.va = isButton(node) ? "middle" : o.lh == o.h ? "middle" : dojo.style(node, "verticalAlign");
		return o;
	};
	
	var getText = function(node){
		// Get the text of the button. It's possible to use HTML in the Flash Button,
		//	but the results are not spectacular.
		var cn = dojo.trim(node.innerHTML);
		if(cn.indexOf("<") >- 1){
			cn = escape(cn);
		}
		return cn;
	};
	
	var getStyle = function(node){
		// getting the style of a node. Using very abbreviated characters which the
		//	Flash movie understands.
		var o = {};
		var dim = dojo.contentBox(node);
		var pad = dojo._getPadExtents(node);
		o.p = [pad.t, pad.w-pad.l, pad.h-pad.t, pad.l];
		o.w = dim.w + pad.w;
		o.h = dim.h + pad.h;
		o.d = dojo.style(node, "display");
		var clr = new dojo.Color(dojo.style(node, "backgroundColor"));
		// if no color, Safari sets #000000 and alpha=0 since we don't support alpha,
		// it makes black - make it white
		o.bc = clr.a == 0 ? "#ffffff" : clr.toHex();
		o.bc = parseInt(o.bc.substring(1,Infinity),16);
		var url = urlencode(dojo.style(node, "backgroundImage"));
		if(url){
			o.bi = {
				url:url,
				rp:dojo.style(node, "backgroundRepeat"),
				pos: escape(dojo.style(node, "backgroundPosition"))
			};
			if(!o.bi.pos){
				// IE does Xpx and Ypx, not "X% Y%"
				var rx = dojo.style(node, "backgroundPositionX");
				var ry = dojo.style(node, "backgroundPositionY");
				rx = (rx == "left") ? "0%" : (rx == "right") ? "100%" : rx;
				ry = (ry == "top") ? "0%" : (ry == "bottom") ? "100%" : ry;
				o.bi.pos = escape(rx+" "+ry);
			}
		}
		return dojo.mixin(o, getTextStyle(node));
	};
	var getTempNodeStyle = function(node, _class, isDijitButton){
		// This sets up a temp node to get the style of the hover, active, and disabled states
		var temp, style;
		if(isDijitButton){
			// backwards compat until dojo 1.5
			temp = dojo.place("<"+node.tagName+"><span>"+node.innerHTML+"</span></"+node.tagName+">", node.parentNode); //+" "+_class+"
			var first = temp.firstChild;
			dojo.addClass(first, node.className);
			dojo.addClass(temp, _class);
			style = getStyle(first);
		}else{
			temp = dojo.place("<"+node.tagName+">"+node.innerHTML+"</"+node.tagName+">", node.parentNode);
			dojo.addClass(temp, node.className);
			dojo.addClass(temp, _class);
			temp.id = node.id;
			style = getStyle(temp);
		}
dojo.destroy(temp);
		return style;
	};
	
	var isUpperCase = function(ltr){
		// returns true if character is upper case
		return ltr.charCodeAt(0) < 91;
	};
	
	dojo.declare("dojox.form.FileUploader", [dijit._Widget, dijit._Templated, dijit._Contained], {
		// version:
		//		1.4
		// summary: 
		// 		Handles File Uploading to a server (PHP script included for testing)
		//
		//		***NEW: FileUploader is now a WIDGET. You do not have to pass a button
		//		in. Passing a button is still supported until version 1.5 to maintain
		//		backwards compatibility, but it is not reccomended. Just create your
		//		uploader like any other widget.
		//
		// description:
		//		If the correct version of Flash Player is available (> 9.0) , a SWF
		//		is used. If Flash Player is not installed or is outdated, a typical
		//		html fileInput is used. This process can be overridden with
		//		force:"flash" or force:"html".
		//
		//		FileUploader works with Flash 10.
		//
		//		***NEW: The button styles are now recreated in Flash, so there is no longer
		//		using an invisible Flash movie with wmode=transparent. This way the Flash button
		//		is actually placed inline with the DOM, not floating above it and constantly
		//		resetting its position. The "Windows Firefox clickable bug" should be fixed (and
		//		hopefully some Linux problems).
		//
		//		***NEW: The HTML button is created in a new way and it is now inline as is the
		//		FLash button. Styling is much easier and more versatile.
		//
		//	Dependencies:
		//		FileUploader no longer uses FileInput.css. It now uses FileUploader.css
		//		See requires for JavaScript dependencies.
		//
		//	NEW FEATURES - 
		//		There are a ton of features and fixes in this version.
		//			Disabled: Can be toggled with widget.attr("disable", true|false)
		//			Submit: A convenience method has been added for if the uploader is in a form.
		//					Instead of submitting the form, call uploader.submit(theForm), and the
		//					Uploader will handle all of the form values and post the data.
		//			Selected List: If passing the ID of a container, the Uploaders will populate it
		//					with the selected files.
		//			Deleting Files: You can now delete pending files.
		//			Progress Built in: showProgress:true will change the button to a progress
		//					bar on upload.
		//			Progress Attach: Passing progressWidgetId will tell the Uploader of a progress
		//					widget. If the Progress widget is initially hidden, it will change to
		//					visible and then restored after upload.
		//			A11Y: The Flash button can be accessed with the TAB key. (The HTML cannot due
		//					to browser limtations)
		//			Deferred Uploading: (Flash only) throttles the upload to one file at a time
		//
		//
		//	CDN USERS - 
		//		FileUpload now works with the CDN but with limitations. The SWF must 
		//		be from the same domain as the HTML page. 'swfPath' has been exposed
		//		so that you may link to that file (could of course be the same SWF in 
		//		dojox resource folder). The SWF will *NOT* work from the
		//		CDN server. This would require a special XML file that would allow 
		//		access to your server, and the logistics to that is impossible.
		//
		//	LIMITATIONS
		//		- This is not designed to be a part of a form, it contains its own. (See submit())
		//		- Currently does not in a Dialog box or a Tab where it is not initially visible,
		//		- The default style inherits font sizes - but a parent container should have a font size
		//			set somewhere of the results could be inconsistent.
		//			
		//	OPERA USERS -
		//		It works better than the 1.3 version. fileInputs apperantly can't have opacity
		//		set to zero. The Flash uploader works but files are auto-uploaded. Must be a
		//		flashVar problem.
		//
		//	Safari Bug note:
		//	The bug is in the way Safari handles the connection:
		//		https://bugs.webkit.org/show_bug.cgi?id=5760
		//		I added this to the virtual host in the Apache conf file, and now it
		//		works like a charm:
		//		BrowserMatch Safari nokeepalive
		//
		templateString:'<div><div dojoAttachPoint="progNode"><div dojoAttachPoint="progTextNode"></div></div><div dojoAttachPoint="insideNode" class="uploaderInsideNode"></div></div>',
		
		// uploadUrl: String
		//		The url targeted for upload. An absolute URL is preferred. Relative URLs are
		//		changed to absolute. 
		uploadUrl: "",
		//
		//	button: dijit.form.Button or a domNode
		// 		DEPRECATED: The "fake" button that when clicked, launches the upload dialog
		// button:"",
		//
		//	isDebug: Boolean
		//		If true, outputs traces from the SWF to console. What exactly gets passed
		//		is very relative, and depends upon what traces have been left in the DEFT SWF.
		isDebug:false,
		//
		//	devMode: Boolean.
		//		Re-implemented. devMode increases the logging, adding style tracing from the SWF.
		devMode:false,
		//
		//	id: String
		//		The object id, just like any other widget in Dojo. However, this id
		//		is also used as a reference for the SWF
		// id: "",
		//
		//	baseClass: String
		//		The name of the class that will style the button in a "normal" state.
		//		If baseClass is not defined, 'class' will be used.
		//		NOTE: By default the uploader will be styled like a dijit buttons and
		//		adhere to the the themes. Tundra, Soria, and Nihilo are supported.
		//		You can cascade the existing style by using 'class' or 'style'. If you
		//		overwrite baseClass, you should overwrite the remaing state classes
		//		that follow) as well.
		baseClass:"dojoxUploaderNorm",
		//
		//	hoverClass: String
		//		The name of the class that will style the button in a "hover" state. A specific
		//		class should be made to do this. Do not rely on a target like button:hover{...}
		hoverClass:"dojoxUploaderHover",
		//
		//	activeClass: String
		//		The name of the class that will style the button in a "press" state. A specific
		//		class should be made to do this. Do not rely on a target like button:active{...}
		activeClass:"dojoxUploaderActive",
		//
		//	disabledClass: String
		//		The name of the class that will style the button when its disabled.
		disabledClass:"dojoxUploaderDisabled",
		//
		//	force: String
		//		Use "flash" to always use Flash (and hopefully force the user to download the plugin
		//		if they don't have it). Use "html" to always use the HTML uploader. An empty string
		//		(default) will check for the right version of Flash and use HTML if not available.
		force:"",
		//
		//	uploaderType: [readonly] String
		//		Internal. What type of uploader is being used: "flash" or "html"
		uploaderType:"",
		//
		//	flashObject: [readonly] dojox.embed.Flash 
		//		The object that creates the SWF embed object. Mostly Internal.
		flashObject: null,
		//
		//	flashMovie: [readonly] Function
		//		The SWF. Mostly Internal.
		flashMovie: null,
		//
		//	flashDiv: [readonly] HTMLNode
		//		DEPRECATED for insideNode
		//		The div that holds the SWF and form/fileInput
		flashDiv: null,
		//
		//	insideNode: [readonly] HTMLNode
		//		The div that holds the SWF and form/fileInput
		insideNode: null,
		//
		//	deferredUploading: Number (1 - X)
		//		(Flash only) throttles the upload to a certain amount of files at a time.
		//		By default, Flash uploads file one at a time to the server, but in parallel.
		//		Firefox will try to queue all files at once, leading to problems. Set this
		//		to the amount to upload in parallel at a time.
		//		Generally, 1 should work fine, but you can experiment with queuing more than
		//		one at a time.
		//		This is of course ignored if selectMultipleFiles equals false.
		deferredUploading:1,
		//
		//	fileListId: String
		//		The id of a dom node to be used as a container for the pending file list.
		fileListId:"",
		//
		//	uploadOnChange: Boolean
		//		If true, uploads imediately after a file has been selected. If false,
		//		waits for upload() to be called.
		uploadOnChange: false,
		//
		//	selectMultipleFiles: Boolean
		//		If true and flash mode, multiple files may be selected from the dialog.
		//		If html mode, files are not uploaded until upload() is called. The references
		//		to each file is incremented:uploadedfile0, uploadedfile1, uploadedfile2... etc.
		selectMultipleFiles: true,
		//
		//	htmlFieldName: String
		//		The name of the field of the fileInput that the server is expecting
		htmlFieldName:"uploadedfile",
		//
		//	flashFieldName: String
		//		The name of the field of the flash uploaded files that the server is expecting
		flashFieldName:"flashUploadFiles",
		//
		// fileMask:  Array[ Array[Description, FileTypes], Array[...]...] 
		// 		(an array, or an array of arrays)
		//		Restrict file selection to certain file types
		// 		Empty array defaults to "All Files"
		// example:
		//	fileMask = ["Images", "*.jpg;*.jpeg;*.gif;*.png"]
		//	or
		//	fileMask = [
		//		["Jpeg File", 	"*.jpg;*.jpeg"],
		//		["GIF File", 	"*.gif"],
		//		["PNG File", 	"*.png"],
		//		["All Images", 	"*.jpg;*.jpeg;*.gif;*.png"],
		//	]
		//	NOTE: MacType is not supported, as it does not work very well.
		//			fileMask will work on a Mac, but differently than 
		//			Windows.
		fileMask: null,
		//
		//	minFlashVersion: Number
		//		The minimum of version of Flash player to target. 0 would always install Flash, 100
		//		would never install it. The Flash Player has supported multiple uploads since
		//		version 8, so it could go as low as that safely.
		minFlashVersion:9,
		//
		//	tabIndex: Number|String
		//		The tab order in the DOM. Only supported by Flash. HTML Uploaders have security
		//		protection to prevent you from tabbing to the uploader. Stupid.
		tabIndex:-1,
		//
		//	showProgress: Boolean
		//		If true, the button changes to a progress bar during upload.
		showProgress:false,
		//
		//	progressMessage: String
		//		The message shown while the button is changed to a progress bar
		progressMessage:"Loading",
		//
		//	progressBackgroundUrl: String|Uri
		//		The background image to use for the button-progress
		progressBackgroundUrl:dojo.moduleUrl("dijit", "themes/tundra/images/buttonActive.png"),
		//
		//	progressBackgroundColor: String|Number
		//		The background color to use for the button-progress
		progressBackgroundColor:"#ededed",
		//
		//	progressWidgetId:String
		//		The widget id of a Dijit Progress bar. The Uploader will bind to it and update it
		//		automatically.
		progressWidgetId:"",
		//
		// skipServerCheck: Boolean
		// 		If true, will not verify that the server was sent the correct format.
		//		This can be safely set to true. The purpose of the server side check
		//		is mainly to show the dev if they've implemented the different returns
		//		correctly.
		skipServerCheck:false,
		//
		// serverTimeout:Number (milliseconds)
		//		The amount of time given to the uploaded file
		//		to wait for a server response. After this amount
		//		of time, the onComplete is fired but with a 'server timeout'
		//		error in the returned item.
		serverTimeout: 5000,
		
		
		log: function(){
			//	summary:
			//		Due to the excessive logging necessary to make this code happen,
			//		It's easier to turn it on and off here in one place.
			//		Also helpful if there are multiple uploaders on one page.
			if(this.isDebug){
				console.log.apply(console, arguments);
			}
		},
		
		constructor: function(){
			this._subs = [];
		},
		
		postMixInProperties: function(){
			// internal stuff:
			this.fileList = [];
			this._cons = [];
			this.fileMask = [];
			this.fileInputs = [];
			this.fileCount = 0;
			this.flashReady = false;
			this._disabled = false;
			this.force = this.force.toLowerCase(); // Pete FTW.
			this.uploaderType = ((dojox.embed.Flash.available >= this.minFlashVersion || this.force=="flash") && this.force != "html") ? "flash" : "html";
			this.deferredUploading = this.deferredUploading===true ? 1 : this.deferredUploading;
			if(!this.swfPath){
				this.swfPath = swfPath;
			}
			
			this._refNode = this.srcNodeRef;
			this.getButtonStyle();
		},
		
		startup: function(){
		
		},
		
		postCreate: function(){
			this.inherited(arguments);
			//this.getButtonStyle();
			
			// internal stuff:
			this.setButtonStyle();
			var createMethod;
			if(this.uploaderType == "flash"){
				createMethod = "createFlashUploader";
			}else{
				this.uploaderType = "html";
				createMethod = "createHtmlUploader";
				
			}
			
			if(this._hiddenNode){
				var w = dijit.byNode(this._hiddenNode)
				this.connect(w, "onShow", createMethod);
			}else{
				this[createMethod]();
			}
			
			if(this.fileListId){
				this.connect(dojo.byId(this.fileListId), "click", function(evt){
					var p = evt.target.parentNode.parentNode.parentNode; // in a table
					if(p.id && p.id.indexOf("file_")>-1){
						this.removeFile(p.id.split("file_")[1]);
					}
				});
			}
			
			// cleaning up solves memory leak issues in the HTML version
			dojo.addOnUnload(this, this.destroy);
		},
		
		getButtonStyle: function(){
			// summary:
			//		Internal.
			//		Get necessary style information from srcRefNode and
			//		assigned styles
			//
			
			
			// TODO:
			//		To call this from postCreate....
			//		could do the style stuff initially, but if hidden they will be bad sizes
			//		could then redo the sizes
			//		alt is to create a genuine button and copy THAT	instead of how now
			 
			var refNode = this.srcNodeRef//this.domNode;
			var p = refNode.parentNode;
			while(p.tagName.toLowerCase() != "body"){
				var d = dojo.style(p, "display");
				if(d == "none"){
					this._hiddenNode = p;
					break;
				}
				p = p.parentNode
			}
			if(this._hiddenNode){
				dojo.style(this._hiddenNode, "display", "block");
			}
			
			
			if(this.button){
				console.warn("DEPRECATED: FileUploader.button - will be removed in 1.5. FileUploader should be created as widget.");
			}
			if(!refNode && this.button && this.button.domNode){
				// backwards compat for a Dijit button
				var isDijitButton = true;
				var cls = this.button.domNode.className + " dijitButtonNode";
				var txt = getText(dojo.query(".dijitButtonText", this.button.domNode)[0]);
				var domTxt = '<button id="'+this.button.id+'" class="'+cls+'">'+txt+'</button>';
				refNode = dojo.place(domTxt, this.button.domNode, "after");	 /// Pete doesn't like this?
				this.srcNodeRef = refNode;
				this.button.destroy();
				
				this.baseClass = "dijitButton";
				this.hoverClass = "dijitButtonHover";
				this.pressClass = "dijitButtonActive";
				this.disabledClass = "dijitButtonDisabled";
				
			}else if(!this.srcNodeRef && this.button){
				refNode = this.button;
			}
		
			if(dojo.attr(refNode, "class")){
				this.baseClass += " " + dojo.attr(refNode, "class");
			}
			dojo.attr(refNode, "class", this.baseClass);
			
			
			this.norm = getStyle(refNode);
			this.width = this.norm.w;
			this.height = this.norm.h;
			
			if(this.uploaderType == "flash"){
					
				this.over = getTempNodeStyle(refNode, this.baseClass+" "+this.hoverClass, isDijitButton);
				this.down = getTempNodeStyle(refNode, this.baseClass+" "+this.activeClass, isDijitButton);				
				this.dsbl = getTempNodeStyle(refNode, this.baseClass+" "+this.disabledClass, isDijitButton);				
				
				this.fhtml = {
					cn:getText(refNode),
					nr:this.norm,
					ov:this.over,
					dn:this.down,
					ds:this.dsbl
				};
			}else{
				this.fhtml = {
					cn:getText(refNode),
					nr:this.norm
				}
				if(this.norm.va == "middle"){
					this.norm.lh = this.norm.h;
				}
			}
			
			if(this.devMode){
				this.log("classes - base:", this.baseClass, " hover:", this.hoverClass, "active:", this.activeClass);
				this.log("fhtml:", this.fhtml)
				this.log("norm:", this.norm)
				this.log("over:", this.over)
				this.log("down:", this.down)
				
			}
		},
		
		setButtonStyle: function(){
			// summary:
			//		Internal.
			//		Set up internal dom nodes for button construction.
			//
			dojo.style(this.domNode, {
				width:this.fhtml.nr.w+"px",
				height:(this.fhtml.nr.h)+"px",
				padding:"0px",
				lineHeight: "normal",
				position:"relative"
			});
			if(this.uploaderType == "html" && this.norm.va == "middle"){
				dojo.style(this.domNode, "lineHeight", this.norm.lh + "px");
			}
			if(this.showProgress){
				this.progTextNode.innerHTML = this.progressMessage;
				dojo.style(this.progTextNode, {
					width:this.fhtml.nr.w+"px",
					height:(this.fhtml.nr.h+0)+"px",
					padding:"0px",
					margin:"0px",
					left:"0px",
					lineHeight:(this.fhtml.nr.h+0)+"px",
					position:"absolute"
				});
				dojo.style(this.progNode, {
					width:this.fhtml.nr.w+"px",
					height:(this.fhtml.nr.h+0)+"px",
					padding:"0px",
					margin:"0px",
					left:"0px",
					position:"absolute",
					display:"none",
					backgroundImage:"url("+this.progressBackgroundUrl+")",
					backgroundPosition:"bottom",
					backgroundRepeat:"repeat-x",
					backgroundColor:this.progressBackgroundColor
				});
			}else{
				dojo.destroy(this.progNode);
			}
			dojo.style(this.insideNode,{
				position:"absolute",
				top:"0px",
				left:"0px",
				display:""
			});
			dojo.addClass(this.domNode, this.srcNodeRef.className);
			if(this.fhtml.nr.d.indexOf("inline")>-1){
				dojo.addClass(this.domNode, "dijitInline");
			}
				
			try{
				this.insideNode.innerHTML = this.fhtml.cn;
			}catch(e){
				// You have got to be kidding me. IE does us he favor of checking that
				//	we aren't inserting the improper type of content with innerHTML into
				//	an inline element. Alert us with an "Unknown Runtime Error". You can't
				//	MAKE this stuff up.
				//
				if(this.uploaderType == "flash"){
				this.insideNode = this.insideNode.parentNode.removeChild(this.insideNode);
					dojo.body().appendChild(this.insideNode);
					this.insideNode.innerHTML = this.fhtml.cn;
					var c = dojo.connect(this, "onReady", this, function(){ dojo.disconnect(c);
						this.insideNode = this.insideNode.parentNode.removeChild(this.insideNode);
						this.domNode.appendChild(this.insideNode);
					});
				}else{
					this.insideNode.appendChild(document.createTextNode(this.fhtml.cn));
				}
			}
			this.flashDiv = this.insideNode; //backwards compat - rem in 1.5
			if(this._hiddenNode){
				dojo.style(this._hiddenNode, "display", "none");
			}
		},
		
		
		/*************************
		 *	   Public Events	 *
		 *************************/
		
		// The following events are inherited from _Widget and still may be connected:
		// onClick
		// onMouseUp
		// onMouseDown
		// onMouseOver
		// onMouseOut
		
		onChange: function(dataArray){
			//	summary:
			// 		stub to connect 
			// 		Fires when files are selected
			// 		Event is an array of last files selected
		},
		
		onProgress: function(dataArray){
			// summary:
			// 		Stub to connect 
			// 		Fires as progress returns from SWF
			// 		Event is an array of all files uploading
			//		Can be connected to for HTML uploader,
			//		but will not return anything.
		},
		
		onComplete: function(dataArray){
			// summary:
			// 		stub to connect 
			// 		Fires when all files have uploaded
			// 		Event is an array of all files
		},
		
		onCancel: function(){
			// summary:
			// 		Stub to connect 
			// 		Fires when dialog box has been closed 
			//		without a file selection
		},
		
		onError: function(/* Object or String */evtObject){
			// summary:
			//		Fires on errors
			//
			//FIXME: Unsure of a standard form for receiving errors
		},
		
		onReady: function(/* dojox.form.FileUploader */ uploader){
			// summary:
			//		Stub - Fired when dojox.embed.Flash has created the
			//		Flash object, but it has not necessarilly finished
			//		downloading, and is ready to be communicated with.
		},
		
		onLoad: function(/* dojox.form.FileUploader */ uploader){
			// summary:
			//		Stub - SWF has been downloaded 100%.
		},
		
		/*************************
		 *	   Public Methods	 *
		 *************************/
		submit: function(/* form node ? */form){
			// summary:
			//		If FileUploader is in a form, and other data should be sent
			//		along with the files, use this instead of form submit.
			//
			var data = form ? dojo.formToObject(form) : null;
			this.upload(data);
			return false; // Boolean
		},
		upload: function(/*Object ? */data){
			// summary:
			// 		When called, begins file upload
			//	data: Object
			//		postData to be sent to server
			//
			if(!this.fileList.length){
				return false;
			}
			if(!this.uploadUrl){
				console.warn("uploadUrl not provided. Aborting.");
				return false;
			}
			if(!this.showProgress){
				this.attr("disabled", true);
			}
			
			if(this.progressWidgetId){
				
				var node = dijit.byId(this.progressWidgetId).domNode;
				if(dojo.style(node, "display") == "none"){
					this.restoreProgDisplay = "none";
					dojo.style(node, "display", "block");
				}
				if(dojo.style(node, "visibility") == "hidden"){
					this.restoreProgDisplay = "hidden";
					dojo.style(node, "visibility", "visible");
				}
			}
			
			if(data && !data.target){
				this.postData = data;
			}
			this.log("upload type:", this.uploaderType, " - postData:", this.postData);
			
			for (var i = 0; i < this.fileList.length; i++){
				var f = this.fileList[i];
				f.bytesLoaded = 0;
				f.bytesTotal = f.size || 100000;
				f.percent = 0;
			}
			if(this.uploaderType == "flash"){
				this.uploadFlash();
			}else{
				this.uploadHTML();
			}
			// prevent form submit
			return false;
		},
		removeFile: function(/*String*/name, /*Boolean*/noListEdit){
			// summary:
			//		Removes a file from the pending file list.
			//		Removes pending data from the Flash movie
			//		and fileInputes from the HTML uploader.
			//		If a file container node is bound, the file
			//		will also be removed.
			// name:String
			//		The name of the file to be removed. Typically the file name,
			//		such as: picture01.png
			// noListEdit:Boolean
			//		Internal. If true don't remove files from list.
			//
			var i;
			for(i = 0; i < this.fileList.length; i++){
				if(this.fileList[i].name == name){
					if(!noListEdit){ // if onComplete, don't do this
						this.fileList.splice(i,1);
					}
					break;
				}
			}
			if(this.uploaderType == "flash"){
				this.flashMovie.removeFile(name);
			}else if(!noListEdit){
				dojo.destroy(this.fileInputs[i]);
				this.fileInputs.splice(i,1);
				this._renumberInputs();
			}
			if(this.fileListId){
				dojo.destroy("file_"+name);	
			}
		},
		destroyAll: function(){
			//	summary:
			// 		Destroys button
			console.warn("DEPRECATED for 1.5 - use destroy() instead");
			this.destroy();
		},
		
		destroy: function(){
			//	summary:
			//		Destroys uploader button
			if(this.uploaderType == "flash" && !this.flashMovie){
				this._cons.push(dojo.connect(this, "onLoad", this, "destroy"));
				return;
			}
			dojo.forEach(this._subs, dojo.unsubscribe, dojo);
			dojo.forEach(this._cons, dojo.disconnect, dojo);
			if(this.scrollConnect){
				dojo.disconnect(this.scrollConnect);
			}
			if(this.uploaderType == "flash"){
				this.flashObject.destroy();
				dojo.destroy(this.flashDiv);
			}else{
				dojo.destroy("dojoIoIframe");
				dojo.destroy(this._fileInput);
				dojo.destroy(this._formNode);
			}
			this.inherited(arguments);
		},
		hide: function(){
			//	summary:
			//		Hides the upload button.
			console.warn("DEPRECATED for 1.5 - use dojo.style(domNode, 'display', 'none' instead");
			dojo.style(this.domNode, 'display', 'none');
		},
		
		show: function(){
			//	summary:
			//		Shows the upload button. This is called
			//		when within a dialog.
			console.warn("DEPRECATED for 1.5 - use dojo.style(domNode, 'display', '') instead");
			dojo.style(this.domNode, 'display', '');
		},
		disable: function(/*Boolean*/disabled){
			console.warn("DEPRECATED: FileUploader.disable() - will be removed in 1.5. Use attr('disable', true) instead.")
			this.attr("disable", disabled);
		},
		/*************************
		 *	   Private Events	 *
		 *************************/
		_displayProgress: function(/*Boolean or Number */display){
			// summary:
			//		Shows and updates the built-in progress bar.
			//
			if(display === true){
				if(this.uploaderType == "flash"){
					dojo.style(this.insideNode,"left", "-2500px");
				}else{
					dojo.style(this.insideNode,"display", "none");	
				}
				dojo.style(this.progNode,"display","");
			}else if(display === false){
				dojo.style(this.insideNode,{
					display: "",
					left: "0px"
				});
				dojo.style(this.progNode,"display","none");
			}else{
				var w = display * this.fhtml.nr.w;
				dojo.style(this.progNode, "width", w + "px");
			}
		},
		_animateProgress: function(){
			// summary:
			//		Internal. Animated the built-in progress bar
			this._displayProgress(true);
			var _uploadDone = false;
			var c = dojo.connect(this, "_complete", function(){
				dojo.disconnect(c);
				_uploadDone = true;
			});
			var w = 0;
			var interval = setInterval(dojo.hitch(this, function(){
				w+=5;
				if(w>this.fhtml.nr.w){
					w = 0;
					_uploadDone = true;
				}
				this._displayProgress(w/this.fhtml.nr.w);
				
				if(_uploadDone){
					clearInterval(interval);
					setTimeout(dojo.hitch(this, function(){
						this._displayProgress(false);
					}), 500);
				}
				
			}),50);
		},
		
		_error: function(evt){
			//var type = evtObject.type ? evtObject.type.toUpperCase() : "ERROR";
			//var msg = evtObject.msg ? evtObject.msg : evtObject;
			if(typeof(evt)=="string"){
				evt = new Error(evt);
			}
			this.onError(evt);
		},
		
		_addToFileList: function(){
			// summary:
			//		Internal only. If there is a file list, adds a file to it.
			//		If you need to use a function such as this, connect to
			//		onChange and update outside of this widget.
			//
			if(this.fileListId){
				var str = '';
				dojo.forEach(this.fileList, function(d){
					// have to use tables because of IE. Grumble.
					str += '<table id="file_'+d.name+'" class="fileToUpload"><tr><td class="fileToUploadClose"></td><td class="fileToUploadName">'+d.name+'</td><td class="fileToUploadSize">'+Math.ceil(d.size*.001)+'kb</td></tr></table>'	
				}, this);
				dojo.byId(this.fileListId).innerHTML = str;
			}
		},
		
		_change: function(dataArray){
			// summary:
			//		Internal. Updates uploader selection
			if(dojo.isIE){
				//IE6 uses the entire path in the name, which isn't terrible, but much different
				// than everything else
				dojo.forEach(dataArray, function(f){
					f.name = f.name.split("\\")[f.name.split("\\").length-1];
				});
			}
			if(this.selectMultipleFiles){
				this.fileList = this.fileList.concat(dataArray);
			}else{
				if(this.fileList[0]){
					this.removeFile(this.fileList[0].name, true);
				}
				this.fileList = dataArray;
			}
			this._addToFileList();
			this.onChange(dataArray);
			if(this.uploadOnChange){
				this._buildFileInput();
				this.upload();
			}else if(this.uploaderType == "html" && this.selectMultipleFiles){
				this._buildFileInput();
				this._connectInput();
			}
		},
		
		_complete: function(dataArray){
			// summary:
			//		Internal. Handles tasks after files have finished uploading
			//
			dataArray = dojo.isArray(dataArray) ? dataArray : [dataArray];
			
			// Yes. Yes I do have to do three loops here. ugh.
			//
			// Check if one of the files had an error
			dojo.forEach(dataArray, function(f){
				if(f.ERROR){ this._error(f.ERROR); }
			}, this);
			
			// Have to be set them all too 100%, because
			// onProgress does not always fire
			dojo.forEach(this.fileList, function(f){
				f.bytesLoaded = 1;
				f.bytesTotal = 1;
				f.percent = 100;
				this._progress(f);
			}, this);
			// we're done. remove files.
			dojo.forEach(this.fileList, function(f){
				this.removeFile(f.name, true);
			}, this);
			
			this.onComplete(dataArray);
			
			this.fileList = [];
			this._resetHTML();
			this.attr("disabled", false);
			
			
			if(this.restoreProgDisplay){
				// using timeout so prog shows on screen for at least a short time
				setTimeout(dojo.hitch(this, function(){
					dojo.style(dijit.byId(this.progressWidgetId).domNode,
						this.restoreProgDisplay == "none" ? "display" : "visibility",
						this.restoreProgDisplay
					);
				}), 500);
			}
			
		},
		
		_progress: function(dataObject){
			// summary:
			//		Internal. Calculate progress
			var total = 0;
			var loaded = 0;
			for (var i = 0; i < this.fileList.length; i++){
				var f = this.fileList[i];
				if(f.name == dataObject.name){
					f.bytesLoaded = dataObject.bytesLoaded;
					f.bytesTotal = dataObject.bytesTotal;
					f.percent = Math.ceil(f.bytesLoaded / f.bytesTotal * 100);
					this.log(f.name, "percent:", f.percent)
				} 
				loaded += Math.ceil(.001 * f.bytesLoaded);
				total += Math.ceil(.001 * f.bytesTotal);
			}
			var percent = Math.ceil(loaded / total * 100);
			if(this.progressWidgetId){
				dijit.byId(this.progressWidgetId).update({progress:percent+"%"});
			}
			if(this.showProgress){
				this._displayProgress(percent * .01);
			}
			this.onProgress(this.fileList);
			
		},
		_getDisabledAttr: function(){
			// summary:
			//		Internal. To get disabled use: widget.attr("disabled");
			return this._disabled;
		},
		
		_setDisabledAttr: function(disabled){
			// summary:
			//		Internal. To set disabled use: widget.attr("disabled", true | false);
			if(this._disabled == disabled){ return; }
			
			if(this.uploaderType == "flash"){
				if(!this.flashReady){
					var _fc = dojo.connect(this, "onLoad", this, function(){
						dojo.disconnect(_fc);
						this._setDisabledAttr(disabled);
					});
					return;
				}
				this._disabled = disabled;
				this.flashMovie.doDisable(disabled);
			}else{
				this._disabled = disabled;
				dojo.style(this._fileInput, "display", this._disabled ? "none" : "");
			}
			dojo.toggleClass(this.domNode, this.disabledClass, disabled);
		},
		
		_onFlashBlur: function(){
			// summary:
			//		Internal. Detects when Flash movies reliquishes focus.
			//		We have to find all the tabIndexes in the doc and figure
			//		out whom to give focus to next.
			this.flashMovie.blur();
			if(!this.nextFocusObject && this.tabIndex){
				var nodes = dojo.query("[tabIndex]");
				for(var i = 0; i<nodes.length; i++){
					if(nodes[i].tabIndex >= Number(this.tabIndex)+1){
						this.nextFocusObject = nodes[i];
						break;
					}
				}
			}
			this.nextFocusObject.focus();
		},
		_disconnect: function(){
			// summary:
			//		Internal. Disconnects fileInput in favor of new one.
			dojo.forEach(this._cons, dojo.disconnect, dojo);
		},
		
		/*************************
		 *			HTML		 *
		 *************************/
		uploadHTML: function(){
			// summary:
			//		Internal. You could use this, but you should use upload() or submit();
			//		which can also handle the post data.
			//
			// NOTE on deferredUploading:
			// 		This is not enabled for HTML. Workaround would be to force
			//		singleFile uploads.
			//	TODO:
			//		Investigate removing fileInputs and resending form
			//		multiple times adding each fileInput
			//
			if(this.selectMultipleFiles){
				dojo.destroy(this._fileInput);
			}
			this._setHtmlPostData();
			if(this.showProgress){
				this._animateProgress();
			}
			var dfd = dojo.io.iframe.send({
				url: this.uploadUrl,
				form: this._formNode,
				handleAs: "json",
				error: dojo.hitch(this, function(err){
					this._error("HTML Upload Error:" + err.message);
				}),
				load: dojo.hitch(this, function(data, ioArgs, widgetRef){
					this._complete(data);
				})
			});
		},
		
		createHtmlUploader: function(){
			// summary:
			//		Internal. Fires of methods to build HTML Uploader.
			this._buildForm();
			this._setFormStyle();
			this._buildFileInput();
			this._connectInput();
			this._styleContent();
			dojo.style(this.insideNode, "visibility", "visible");	
			this.onReady();
		},
		
		_connectInput: function(){
			// summary:
			//		Internal. HTML Uploader connections. These get disconnected
			//		after upload or if multi upload.
			this._disconnect();
			this._cons.push(dojo.connect(this._fileInput, "mouseover", this, function(evt){
				dojo.addClass(this.domNode, this.hoverClass);
				this.onMouseOver(evt);
			}));
			this._cons.push(dojo.connect(this._fileInput, "mouseout", this, function(evt){
				dojo.removeClass(this.domNode, this.activeClass);
				dojo.removeClass(this.domNode, this.hoverClass);
				this.onMouseOut(evt);
				this._checkHtmlCancel("off");
			}));
			this._cons.push(dojo.connect(this._fileInput, "mousedown", this, function(evt){
				dojo.addClass(this.domNode, this.activeClass);
				dojo.removeClass(this.domNode, this.hoverClass);
				this.onMouseDown(evt);
			}));
			this._cons.push(dojo.connect(this._fileInput, "mouseup", this, function(evt){
				dojo.removeClass(this.domNode, this.activeClass);
				this.onMouseUp(evt);
				this.onClick(evt);
				this._checkHtmlCancel("up");
			}));
			this._cons.push(dojo.connect(this._fileInput, "change", this, function(){
				this._checkHtmlCancel("change");
				this._change([{
					name: this._fileInput.value,
					type: "",
					size: 0
				}]);
			}));
			if(this.tabIndex>=0){
				dojo.attr(this.domNode, "tabIndex", this.tabIndex);
			}
		},
		
		_checkHtmlCancel: function(mouseType){
			// summary:
			//		Internal. Check if the dialog was opened and canceled without file selection.
			if(mouseType == "change"){
				this.dialogIsOpen = false;
			}
			if(mouseType == "up"){
				this.dialogIsOpen = true;
			}
			if(mouseType == "off"){
				if(this.dialogIsOpen){
					this.onCancel();
				}
				this.dialogIsOpen = false;
			}
		},
		
		_styleContent: function(){
			// summary:
			//		Internal.Apply style to node
			var o = this.fhtml.nr;
			
			dojo.style(this.insideNode, {
				width:o.w+"px",
				height:o.va == "middle"?o.h+"px":"auto",
				textAlign:o.ta,
				paddingTop:o.p[0]+"px",
				paddingRight:o.p[1]+"px",
				paddingBottom:o.p[2]+"px",
				paddingLeft:o.p[3]+"px"
			});
			
			try{
				dojo.style(this.insideNode, "lineHeight", "inherit");
			}catch(e){
				// There are certain cases where IE refuses to set lineHeight.
				// For the life of me I cannot figure out the combination of
				// styles that IE doesn't like. Steaming... Pile...
			}
			
		},
		_resetHTML: function(){
			// summary:
			//		Internal. After upload, this is called to clear the form and build a new
			//		fileInput.
			if(this.uploaderType == "html" && this._formNode){
				this.fileInputs = [];
				dojo.query("*", this._formNode).forEach(function(n){
					dojo.destroy(n);
				});
				this.fileCount = 0;
				this._buildFileInput();
				this._connectInput();
			}
		},
		_buildForm: function(){
			// summary:
			//		Build the form that holds the fileInput
			//
			if(this._formNode){ return; }
			
			if(dojo.isIE){
				this._formNode = document.createElement('<form enctype="multipart/form-data" method="post">');
				this._formNode.encoding = "multipart/form-data";
			}else{
				this._formNode = document.createElement('form');
				this._formNode.setAttribute("enctype", "multipart/form-data");
			}
			this._formNode.id = dijit.getUniqueId("FileUploaderForm"); // needed for dynamic style
			this.domNode.appendChild(this._formNode);
		},
		
		_buildFileInput: function(){
			// summary:
			//		Build the fileInput field
			//
			if(this._fileInput){
				this._disconnect();
				// FIXME:
				//	Just hiding it which works, but we lose
				//	reference to it and can't remove it from
				//	the upload list.
				this._fileInput.id = this._fileInput.id + this.fileCount;
				dojo.style(this._fileInput, "display", "none");
			}
			this._fileInput = document.createElement('input');
			this.fileInputs.push(this._fileInput);
			// server will need to know this variable:
			var nm = this.htmlFieldName;
			var _id = this.id;
			if(this.selectMultipleFiles){
				nm += this.fileCount;
				_id += this.fileCount;
				this.fileCount++;
			}
			
			dojo.attr(this._fileInput, {
				id:this.id,
				name:nm,
				type:"file"
			});
			
			dojo.addClass(this._fileInput, "dijitFileInputReal");
			this._formNode.appendChild(this._fileInput);
			var real = dojo.marginBox(this._fileInput);
			dojo.style(this._fileInput, {
				position:"relative",
				left:(this.fhtml.nr.w - real.w) + "px",
				opacity:0
			});
		},
		
		_renumberInputs: function(){
			if(!this.selectMultipleFiles){ return; }
			var nm;
			this.fileCount = 0;
			dojo.forEach(this.fileInputs, function(inp){
				nm = this.htmlFieldName + this.fileCount;
				this.fileCount++;
				dojo.attr(inp, "name", nm);
			}, this);
		},
		
		_setFormStyle: function(){
			// summary:
			//		Apply a dynamic style to the form and input
			var size = Math.max(2, Math.max(Math.ceil(this.fhtml.nr.w / 60), Math.ceil(this.fhtml.nr.h / 15)));
			// Now create a style associated with the form ID
			dojox.html.insertCssRule("#" + this._formNode.id + " input", "font-size:" + size + "em");
			dojo.style(this.domNode, {
				overflow:"hidden",
				position:"relative"
			});
			dojo.style(this.insideNode, "position", "absolute");
		},
		
		_setHtmlPostData: function(){
			// summary:
			//		Internal.Apply postData to hidden fields in form
			if(this.postData){
				for (var nm in this.postData){
					dojo.create("input", {
						type: "hidden",
						name: nm,
						value: this.postData[nm]
					}, this._formNode);
				}
			}
		},
		
		/*************************
		 *			FLASH		 *
		 *************************/
		uploadFlash: function(){
			// summary:
			//		Internal. You should use upload() or submit();
			try{
				if(this.showProgress){
					this._displayProgress(true);
					var c = dojo.connect(this, "_complete", this, function(){
						dojo.disconnect(c);
						this._displayProgress(false);
					});
				}
				this.flashMovie.doUpload(this.postData);
				
			}catch(err){
				this._error("FileUploader - Sorry, the SWF failed to initialize." + err);
			}
		},
		
		createFlashUploader: function(){
			// summary:
			//		Internal. Creates Flash Uploader
			this.uploadUrl = this.uploadUrl.toString();
			if(this.uploadUrl){
				if(this.uploadUrl.toLowerCase().indexOf("http")<0 && this.uploadUrl.indexOf("/")!=0){
					// Appears to be a relative path. Attempt to 
					//	convert it to absolute, so it will better 
					//target the SWF.
					//
					var loc = window.location.href.split("/");
					loc.pop();
					loc = loc.join("/")+"/";
					this.uploadUrl = loc+this.uploadUrl;
					this.log("SWF Fixed - Relative loc:", loc, " abs loc:", this.uploadUrl);
				}else{
					this.log("SWF URL unmodified:", this.uploadUrl)
				}
			}else{
				console.warn("Warning: no uploadUrl provided.");
			}
			
			var w = this.fhtml.nr.w;
			var h = this.fhtml.nr.h;
			
			var args = {
				expressInstall:true,
				path: this.swfPath.uri || this.swfPath,
				width: w,
				height: h,
				allowScriptAccess:"always",
				allowNetworking:"all",
				vars: {
					uploadDataFieldName: this.flashFieldName,
					uploadUrl: this.uploadUrl,
					uploadOnSelect: this.uploadOnChange,
					deferredUploading:this.deferredUploading || 0,
					selectMultipleFiles: this.selectMultipleFiles,
					id: this.id,
					isDebug: this.isDebug,
					devMode:this.devMode,
					flashButton:dojox.embed.flashVars.serialize("fh", this.fhtml),
					fileMask:dojox.embed.flashVars.serialize("fm", this.fileMask),
					noReturnCheck: this.skipServerCheck,
					serverTimeout:this.serverTimeout
				},
				params: {
					scale:"noscale",
					wmode:"opaque"
				}
				
			};
			
			this.flashObject = new dojox.embed.Flash(args, this.insideNode);
			this.flashObject.onError = dojo.hitch(function(msg){
				this._error("Flash Error: " + msg);
			});
			this.flashObject.onReady = dojo.hitch(this, function(){
				dojo.style(this.insideNode, "visibility", "visible");
				this.log("FileUploader flash object ready");
				this.onReady(this);
			});
			this.flashObject.onLoad = dojo.hitch(this, function(mov){
				this.flashMovie = mov;
				this.flashReady = true;
				
				this.onLoad(this);
			});
			this._connectFlash();
		},
		
		_connectFlash: function(){
			// 	summary:
			//		Subscribing to published topics coming from the
			//		Flash uploader.
			// 	description:
			//		Sacrificing some readbilty for compactness. this.id
			//		will be on the beginning of the topic, so more than
			//		one uploader can be on a page and can have unique calls.
			//
			this._doSub("/filesSelected", "_change");
			this._doSub("/filesUploaded", "_complete");
			this._doSub("/filesProgress", "_progress");
			this._doSub("/filesError", "_error");
			this._doSub("/filesCanceled", "onCancel");
			this._doSub("/stageBlur", "_onFlashBlur");
			this._doSub("/up", "onMouseUp");
			this._doSub("/down", "onMouseDown");
			this._doSub("/over", "onMouseOver");
			this._doSub("/out", "onMouseOut");
			
			this.connect(this.domNode, "focus", function(){
				// TODO: some kind of indicator that the Flash button
				//	is in focus
				this.flashMovie.focus();
				this.flashMovie.doFocus();
			});
			if(this.tabIndex>=0){
				dojo.attr(this.domNode, "tabIndex", this.tabIndex);		
			}
		},
		
		_doSub: function(subStr, funcStr){
			// summary:
			//		Internal. Shortcut for subscribes to Flash movie
			this._subs.push(dojo.subscribe(this.id + subStr, this, funcStr));
		}
	});
	
})();

}

if(!dojo._hasResource["com.copacabana.PlateEntryWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.PlateEntryWidget"] = true;
dojo.provide("com.copacabana.PlateEntryWidget");












//I18N


 
//

dojo.declare("com.copacabana.PlateEntryWidget", [
		dijit._Widget, dijit._Templated ], {
	//i18nStrings: dojo.i18n.getLocalization("com.copacabana", "PlatesListWidgetStrings"),
	templateString:"<div >\r\n<div class=\"panel\" dojoAttachEvent=\"onclick:onClick\" >\t\r\n\t<h2>${plate.title} <span class=\"statusPlate\">${statusMsg}</span></h2>\r\n\t<span class=\"preco\">${priceFormated}</span>\t\r\n\t<p class=\"pcardapiodesc\">${plate.description}</p>\t\r\n</div>\r\n<div class=\"acompanhamentos\">\r\n<div dojoAttachPoint=\"showExtensionsBtn\" ></div> <div dojoAttachPoint=\"btn0\" ></div> \r\n<div dojoAttachPoint=\"extensionsSection\" class=\"optionsSection\">\r\nAdicione opções para '${plate.title}'. <br>\r\n<span style=\"font-style: italic;font-size: small;\">Por exemplo tamanhos (Pequeno/Médio/Grande) ou variações como \"Com batata salsa\". O valor deve ser o valor total com a opção.</span><br/>\r\n<div dojoAttachPoint=\"addNewExtensionsBtn\" ></div>\r\n<div dojoAttachPoint=\"extensionsList\" >Nenhuma opção cadastrada para '${plate.title}'</div>\r\n</div>\r\n\r\n</div>\r\n\r\n<iframe width=\"0\" height=\"0\" name=\"${plate.id}_frame\" style=\"display: none;\" ></iframe>\t\r\n<br>\r\n\r\n<div dojoAttachPoint=\"imageForm\" style=\"display: none; padding: 4px; margin: 3px; border: 1px solid black; background-color: rgb(255, 223, 143);\">\r\n\r\n<div dojoAttachPoint=\"imageSection\"  style=\"border: 1px solid gray; max-height: 300px; max-width: 300px;\"></div>\t\r\n\t<form action=\"\"\r\n\t\tmethod=\"post\" enctype=\"multipart/form-data\" dojoAttachPoint=\"photoForm\" target=\"${plate.id}_frame\">\t\t\r\n\t\t<div><input type=\"file\" dojoAttachPoint=\"filePath\" name=\"myFile\" title=\"Selecionar foto\" class=\"testando\">\r\n\t\t<input type=\"hidden\" name=\"pid\" value=\"${plate.id}\"></div>\r\n\t\t<div dojoAttachPoint=\"sendImageBtn\" ></div>\r\n\t</form>\r\n</div>\r\n<br/>\r\n\r\n</div>\r\n",
	options:[],
	constructor : function(args) {
		this.plate=args.plate;
		this.options=args.options;
		this.priceFormated=com.copacabana.util.moneyFormatter(this.plate.price);
		if(this.plate.status!='AVAILABLE'){
			this.statusMsg='INDISPONÍVEL';
		}
		if(this.plate.status=='HIDDEN'){
			this.statusMsg='OCULTO';
		}
		console.log("Created PlateEntryWidget: id"+this.id);
	},
	statusMsg:'',
	priceFormated:'R$ 0,00',
	postMixInProperties: function(){
        if (dijit.byId(this.id)) {
            dijit.byId(this.id).destroyRecursive();
        }
    },

	postMixInProperties : function() {
		this.inherited(arguments);
	},

	postCreate : function() {
		this.inherited(arguments);		

	},
	destroyRecursive : function() {
		dojo.forEach(this.getDescendants(), function(widget) {

			widget.destroyRecursive();
		});
		this.inherited(arguments);
	},
	plate:null,
	headerNode:null,
	resultsNode:null,
	uploader:null,
	fileMask :[
	        	["Jpeg File", 	"*.jpg;*.jpeg"],
	        	["GIF File", 	"*.gif"],
	        	["PNG File", 	"*.png"],
	        	["All Images", 	"*.jpg;*.jpeg;*.gif;*.png"]
	        ],
	f0:null,
	doUpload:function(){
		console.log("doUpload")		
		this.f0.upload();
	},
	
	button:null,
	sendImage:null,
	uploaded:function(pid,imgUrl,newFormAction){
		com.copacabana.util.hideLoading();
		if(this.plate.id==pid){
			this.plate.imageUrl=imgUrl;
			dojo.empty(this.imageSection);
			dojo.create('img',{src:this.plate.imageUrl,style:{maxHeight:'300px',maxWidth:'300px'}},this.imageSection);
			
		}
		formAction=newFormAction;
		this.updateUIforExistingImage();
	},
	submitXhr:function(){
		com.copacabana.util.showLoading();
		this.photoForm.action=formAction;
		dojo.subscribe('imageUploaded',dojo.hitch(this,this.uploaded));
    	this.photoForm.submit();
//		var xhrArgs = {
//				form: this.photoForm,			
//				handleAs : "text",
//				sync:true,
//				
//				load : dojo.hitch(this, this.returnData),
//				error : function(error) {
//					console.error(error)
//				}
//			}
//			var deferred = dojo.xhrPost(xhrArgs);
	},
	returnData:function(data){
		console.log(data);
	},
	deleteImageAction:function(){
		var xhrArgs = {
				url:'/deletePlateImage?pid='+this.plate.id,	
				handleAs : "text",				
				load : dojo.hitch(this, this.deleteImage),
				error : function(error) {
					console.error(error)
				}
		}
	var deferred = dojo.xhrGet(xhrArgs);
		
	},
	deleteImage:function(data){
		this.updateUIforNonExistingImage();
		
	},
	deleteImgBtn:null,
	updateUIforExistingImage:function(){
		this.button.setLabel("Editar imagem");
		if(this.deleteImgBtn==null){
		this.deleteImgBtn = new dijit.form.Button({
			label: "Remover Imagem",
			baseClass:"orangeButton",
			onClick:dojo.hitch(this,this.deleteImageAction)
		},
		dojo.create('div',{},this.imageForm,'first'));
		}else{
			dojo.style(this.deleteImgBtn.domNode,'display','block');
		}
		dojo.empty(this.imageSection);
		dojo.create('img',{src:this.plate.imageUrl,style:{maxHeight:'300px',maxWidth:'300px'}},this.imageSection);
		

	},
	updateUIforNonExistingImage:function(){
		this.button.setLabel("Adicionar imagem");
		console.log(this.deleteImgBtn);
		if(this.deleteImgBtn!=null){
			dojo.style(this.deleteImgBtn.domNode,'display','none');
			console.log('destruindo o delete btn');
			//this.deleteImgBtn.destroy();
		}
		dojo.empty(this.imageSection);

	},
	startup : function() {
		try {
			
			dojo.parser.parse(this.domNode);
			
			
			this.button = new dijit.form.Button({
	            label: "",
	            baseClass:"orangeButton",
	            onClick:dojo.hitch(this,function(){
	            	dojo.style(this.imageForm,'display','block');
	            	dojo.style(this.button,'display','none');
	            })
	        },
	        this.btn0);
			
			
			
			this.sendImage = new dijit.form.Button({
	            label: "Enviar",
	            baseClass:"orangeButton",
	            onClick:dojo.hitch(this,function(){
	            	this.submitXhr();
	            	//dojo.style(this.imageForm,'display','block');
	            })
	        },
	        this.sendImageBtn);

			if(this.plate.imageUrl!=null && this.plate.imageUrl!=''){
				this.updateUIforExistingImage();
			}else{
				this.updateUIforNonExistingImage();
			}
			
			
			var showExtensions = new dijit.form.Button({
	            label: "Editar opções",
	            baseClass:"orangeButton",
	            onClick:dojo.hitch(this,function(){
	            	var state = dojo.style(this.extensionsSection,'display');
	            	if(state=='block'){
	            		dojo.style(this.extensionsSection,'display','none');
	            	}else{
	            		dojo.style(this.extensionsSection,'display','block');
	            	}
	            		            	
	            })
	        },
	        this.showExtensionsBtn);
			
			var addNewExtensionsBtn = new dijit.form.Button({
	            label: "+ adicionar",
	            baseClass:"orangeButton",
	            onClick:dojo.hitch(this,function(){
	            	dojo.publish('addNewPlateOption',[this.plate.id,this.plate.name,{foodCategory:this.plate.foodCategory}]);
	            		            	
	            })
	        },
	        this.addNewExtensionsBtn);
			
			if(this.options){
				dojo.empty(this.extensionsList);
				dojo.subscribe('onEditPlateOption',dojo.hitch(this,this.onEditPlateOption));
				var table= dojo.create('table',{style:{width: '90%',border:'1px solid',margin:'5px',padding:'5px'}},this.extensionsList);
				var th = dojo.create('tr',{},table);
				dojo.create('th',{innerHTML:'Nome'},th);
				dojo.create('th',{innerHTML:'Preço'},th);
				dojo.create('th',{innerHTML:''},th);
				for ( var i = 0; i < this.options.length; i++) {
					var opt = this.options[i];
					var tr = dojo.create('tr',{},table);
					
					var priceFmted=com.copacabana.util.moneyFormatter(opt.price);
					dojo.create('td',{innerHTML:opt.title},tr);
					dojo.create('td',{innerHTML:priceFmted},tr);
					var td = dojo.create('td',{},tr);
					
					
					var editOptBtn = new dijit.form.Button({
			            label: "Editar",
			            baseClass:"orangeButton",
			            plateId:opt.id,
			            onClick:function(){
			            	console.log('this '+this.plateId)
			            	dojo.publish("onEditPlateOption",[this.plateId]);			            		            	
			            }
			        },
			        dojo.create('div',{},td));
					dojo.create('span',{innerHTML:' '},td)
					var deleteOptBtn = new dijit.form.Button({
			            label: "Apagar",
			            baseClass:"orangeButton",
			            plateId:opt.id,
			            onClick:function(){			            	
			            	dojo.publish("onDeletePlateOption",[this.plateId]);			            		            	
			            }
			        },
			        dojo.create('div',{},td));
					
					//dojo.create('div',{style:{cursor:'pointer'},onclick:'dojo.publish("onEditPlateOption",[\''+opt.id+'\'])',innerHTML:'Editar'},td)
					
					
					
				}				
			}
			
//			if(this.plate.sideDishes && this.plate.sideDishes.length>0){
//				var div = dojo.query(".acompanhamentos",this.domNode)[0];
//				var title = document.createElement("h3");
//				title.innerHTML="Acompanhamentos";
//				div.appendChild(title);
//				var table = document.createElement("table");
//				var tr = document.createElement("tr");
//				var th1 = document.createElement("th");
//				th1.innerHTML="Tipo";
//				var th2 = document.createElement("th");
//				th2.innerHTML="Quantidade";
//				var th3 = document.createElement("th");
//				th3.innerHTML="Descri&ccedil;&atilde;";
//				
//				tr.appendChild(th1);
//				tr.appendChild(th2);
//				tr.appendChild(th3);
//				table.appendChild(tr);
//				for ( var i = 0; i < this.plate.sideDishes.length; i++) {
//					var sd = this.plate.sideDishes[i];
//					var tri = document.createElement("tr");
//					var td1 = document.createElement("td");
//					var td2 = document.createElement("td");
//					var td3 = document.createElement("td");
//					td1.innerHTML="aaa";
//					td2.innerHTML="bbb";
//					td3.innerHTML="c";
//					tri.appendChild(td1);
//					tri.appendChild(td2);
//					tri.appendChild(td3);
//					table.appendChild(tri);
//					
//				}
//				div.appendChild(table);
//			}
			
//			this.headerNode = dojo.query(".resultadoMensagem",this.domNode)[0];
//			this.resultsNode = dojo.query(".resultsList",this.domNode)[0];
//			this.imageNode =  document.createElement('img');
//			this.imageNode.src = dojo.moduleUrl("com.copacabana", "images/loader.gif");
//			this.imageNode.alt="executing search";
//			this.imageNode.title="executing search";
			
		} catch (e) {
			console.error("plateEntry 01 ",e);
		}
	},
	onEditPlateOption:function(id){
		for ( var i = 0; i < this.options.length; i++) {
			var opt = this.options[i];
			if(opt.id==id){
				dojo.publish("addNewPlateOption",[this.plate.id,this.plate.title,opt]);
			}
		}
	},
	onClick:function(evt){		
		dojo.publish("editPlate",[this.plate]);
		dojo.parser.parse(this.domNode);			

	}
	/*onMouseEnter:function(evt){
		console.log("enter");
		var panel = dojo.query(".panel",this.domNode)[0];
		dojo.style(panel,"backgroundColor","silver");
		
		dojo.parser.parse(this.domNode);			

	},
	onMouseOut:function(evt){
		console.log("ount");
		var panel = dojo.query(".panel",this.domNode)[0];
		dojo.style(panel,"backgroundColor","white");
	}*/
});

}

if(!dojo._hasResource["com.copacabana.PlateOrderWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.PlateOrderWidget"] = true;
dojo.provide("com.copacabana.PlateOrderWidget");











//I18N


 


dojo.declare("com.copacabana.PlateOrderWidget", [
		dijit._Widget, dijit._Templated ], {
	i18nStrings: null,
	templateString:"<tr >\r\n\t<td class=\"descricao\"><div dojoAttachPoint=\"imgPlace\" style=\"float:left\"></div>\t\r\n\t<span class=\"platetitle\" dojoAttachPoint=\"titleSection\">${plate.title}</span><br clear=\"all\"/> ${plate.description}</td>\r\n\t<td>${plate.priceFormatted}</td>\r\n\t<td class=\"quantidade\"><span dojoAttachEvent=\"onclick:decrease\">- </span> <input style=\"width:15px;\" width=\"25\" dojoType=\"dijit.form.TextBox\"\r\n\t\tclass=\"quantidadeValue\" height=\"15\" /> <span dojoAttachEvent=\"onclick:increase\"> +</span></td>\t\r\n\t<td><img alt=\"Pedir\" src=\"/resources/img/btPedir.png\" dojoAttachEvent=\"onclick:onClick\" style=\"cursor: pointer;\"/></td>\r\n</tr>\r\n",
	orderDisabled:false,
	constructor : function(plate,disable) {
		this.plate=plate;
		this.id="plate_order_"+plate.id;
		this.plate.priceFormatted = com.copacabana.util.moneyFormatter(this.plate.price);
		if(disable || plate.status=='UNAVAILABLE'){
			this.templateString="<tr >\r\n\t<td class=\"descricao\"><div dojoAttachPoint=\"imgPlace\" style=\"float:left\"></div><span dojoAttachPoint=\"titleSection\">${plate.title}</span><br clear=\"all\"/>${plate.description}</td>\r\n\t<td>${plate.priceFormatted}</td>\r\n\t<td>${statusStr}</td>\t\t\r\n</tr>\r\n";
			this.orderDisabled=true;
			if(plate.status=='UNAVAILABLE'){
				this.statusStr='* Temporariamente indisponivel.';	
			}
		}else if(this.plate.availableTurn!='ANY'){
			if(this.plate.currentTurn!=this.plate.availableTurn){
				this.templateString="<tr >\r\n\t<td class=\"descricao\"><div dojoAttachPoint=\"imgPlace\" style=\"float:left\"></div><span dojoAttachPoint=\"titleSection\">${plate.title}</span><br clear=\"all\"/>${plate.description}</td>\r\n\t<td>${plate.priceFormatted}</td>\r\n\t<td><span dojoAttachPoint=\"statusSection\"></span></td>\t\t\r\n</tr>\r\n";
				this.orderDisabled=true;
				
				
				
			}
		}
		
		

	},
	statusStr:'',
	 destroyRecursive: function(){
        dojo.forEach(this.getDescendants(), function(widget){
        	widget.destroyRecursive();
        });
        this.inherited(arguments);
    },
	plate:null,
	postMixInProperties : function() {
		this.inherited(arguments);
	},

	postCreate : function() {
		this.inherited(arguments);
		this.i18nStrings=dojo.i18n.getLocalization("com.copacabana", "PlateOrderWidgetStrings");
	},	
	largeSection:null,
	showImage:function(evt){
		
		this.largeImgDiv.src=this.plate.imageUrl;
		
		dojo.style(this.largeSection,'display','block');
		
		
	},
	hideImage:function(evt){
		
		dojo.style(this.largeSection,'display','none');
		
	},
	largeImgDiv:null,
	startup : function() {
		try {
			dojo.parser.parse(this.domNode);
			if(this.plate.availableTurn!='ANY'){
				if(this.plate.currentTurn!=this.plate.availableTurn){					
					this.statusSection.innerHTML=this.i18nStrings['onlyFor_'+this.plate.availableTurn];
				}
			}
			//<div style="float: left;" class="imgSection"><img style="max-height: 50px;" src="/prato/img/1362"></div>
			if(this.plate.imageUrl!=null && this.plate.imageUrl!=''){
				var fct = dojo.hitch(this,this.showImage);
				var fct2 = dojo.hitch(this,this.hideImage);
				var largerStyle={position:'absolute',display:'none',padding:'5px',border:'1px solid gray','MozBorderRadius':"5px 5px 5px 5px",backgroundColor:'white'};
				this.largeSection=dojo.create('div',{style:largerStyle,onmouseout:fct2},this.imgPlace);
				console.log('is IE !! ',dojo.isIE);
				if(!dojo.isIE){
					this.largeImgDiv= dojo.create('img',{style:{},src:'/resources/img/loader.gif'},this.largeSection);
				}else{
					this.largeImgDiv= dojo.create('img',{style:{minWidth:'300px',minHeight:'300px'},src:this.plate.imageUrl},this.largeSection);
						
				}
				dojo.create('div',{style:{textAlign:'center'},innerHTML:this.plate.title},this.largeSection);
				dojo.create('img',{src:this.plate.imageUrl+'.small',onmouseover:fct},this.imgPlace);
				dojo.style(this.titleSection,'fontSize','large');
				dojo.style(this.titleSection,'paddingLeft','5px');
				
			}
			if (this.orderDisabled == false) {
				
				dijit.byNode(dojo.query(".quantidadeValue", this.domNode)[0])
						.attr("value", 1);
			}

		} catch (e) {
			console.error("plateOrder start", e);
		}
	},
	onClick:function(evt){
		var qtyNode = dijit.byNode(dojo.query(".quantidadeValue", this.domNode)[0]);
		var qty = parseFloat(qtyNode.attr("value"));
		var pedidoHandler = dijit.byId("pedidoWrapper");
		if(qty>0){
			pedidoHandler.addPlate(this.plate,qty);
		}
	},
	increase:function(){
		var qtyNode = dijit.byNode(dojo.query(".quantidadeValue", this.domNode)[0]);
		qtyNode.attr("value",parseFloat(qtyNode.attr("value"))+1);		
	},
	decrease:function(){
		var qtyNode = dijit.byNode(dojo.query(".quantidadeValue", this.domNode)[0]);
		if(parseFloat(qtyNode.attr("value"))>0){
			qtyNode.attr("value",parseFloat(qtyNode.attr("value"))-1);
		}
	}
	

});

}

if(!dojo._hasResource["com.copacabana.PlatesListWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.PlatesListWidget"] = true;
dojo.provide("com.copacabana.PlatesListWidget");









//I18N


 


dojo.declare("com.copacabana.PlatesListWidget", [
		dijit._Widget, dijit._Templated ], {
	i18nStrings:null,
	templateString:"<div>\r\n<p>Atualmente seu estabelecimento possui <span class=\"totalPlates\">0</span> itens na\r\ncategoria <span class=\"categoriaPlates\">Todas</span></p>\r\n\r\n<div id=\"plateList\" class=\"plateList\">\r\n</div>\r\n</div>\r\n",
	constructor : function() {
		
	},
	periodToFilter:null,
	isFilterByPeriod:function(){
		if(this.periodToFilter==null){
			return false;
		}else{
			return true
		}
	},
	
	key:null,
	postMixInProperties : function() {
		this.inherited(arguments);
	},

	postCreate : function() {
		this.inherited(arguments);
		this.i18nStrings= dojo.i18n.getLocalization("com.copacabana", "PlatesListWidgetStrings");
	},
	headerNode:null,
	resultsNode:null,
	imageNode:null,
	totalPlates:null,
	categoryOfPlates:null,
	
	cleanResultsNWait:function(){
		//this.resultsNode.innerHTML="";
		com.copacabana.util.cleanNode(this.resultsNode);
		this.resultsNode.appendChild(this.imageNode);
	},
	entity:null,
	categoryId:null,
	destroyRecursive : function() {
		dojo.forEach(this.getDescendants(), function(widget) {

			widget.destroyRecursive();
		});
		this.inherited(arguments);
	},
	addPlate:function(plateItem){
		while(this.plateList.length>0) {
			var plate = this.plateList.pop();
			plate.destroy(false);			
		}
		var list=[];
		var found=false;
		for ( var i = 0; i < this.entity.items.length; i++) {
			if(this.entity.items[i].id==plateItem.id){
				list.push(plateItem);	
				found=true;
			}else{
				list.push(this.entity.items[i]);
			}
		}
		
		this.entity.items=list;
		if(found==false){
			this.entity.items.push(plateItem);
		}
		this.updatePlateList();
	},
	hashPlateExtensions:[],
	loadedPlates: function(data) {
		var plist = dojo.fromJson(data);
		this.entity = dojo.clone(plist);
		this.entity.items=[];
		this.hashPlateExtensions=[];
		for ( var i = 0; i < plist.items.length; i++) {
			var plate = plist.items[i];
			if(plate.isExtension==true){
				if(!this.hashPlateExtensions[plate.extendsPlate]){
					this.hashPlateExtensions[plate.extendsPlate]=[];
				}
				this.hashPlateExtensions[plate.extendsPlate].push(plate);
			}else{
				this.entity.items.push(plate);
			}
		}
		this.updatePlateList();
	},
	plateList:[],
	allCats:[],
	updatePlateList : function(shouldNotify) {
		// this.resultsNode.innerHTML="";
		dojo.empty(this.resultsNode);
		this.allCats = [];
		var results = this.entity.items;

		var counter = 0;
		if (results.length === 0) {
			this.resultsNode.innerHTML = "Nenhum produto nesta categoria.";
		} else {
			var ul = document.createElement("ul");
			for ( var i = 0; i < results.length; i++) {
				var p = results[i];
				this.allCats[p.foodCategory] = true;
				if (this.categoryId != null) {
					if (this.categoryId != p.foodCategory && this.categoryId != "all") {
						continue;
					}
				}
				counter++;
				var plate = new com.copacabana.PlateEntryWidget({
					plate : p,
					options:dojo.clone(this.hashPlateExtensions[p.id])
				});
				plate.startup();
				this.plateList.push(plate);
				var item = document.createElement("li");
				item.appendChild(plate.domNode);
				ul.appendChild(item);
			}
			this.resultsNode.appendChild(ul);
		}
		this.totalPlates.innerHTML = counter;
		if(shouldNotify!=false){
			dojo.publish("categoriesAvailable", [ this.allCats ]);
		}

	},
	refreshPlateList:function(){
		this.cleanResultsNWait();

		var xhrArgs = {
				url : "/listAdminRestaurantPlates.do?&filterByPeriod="+this.isFilterByPeriod()+"&periodToFilter="+this.periodToFilter,								
				handleAs : "text",
				load : dojo.hitch(this, "loadedPlates"),
				error : function(error) {
					console.error("cannot load plates.",error)
				}
		}
		var deferred = dojo.xhrPost(xhrArgs);

	},
	startup : function() {
		try {
			dojo.parser.parse(this.domNode);
			this.totalPlates = dojo.query(".totalPlates",this.domNode)[0];
			
			this.categoryOfPlates = dojo.query(".categoriaPlates",this.domNode)[0];
			this.totalPlates.innerHTML = 0;
			this.categoryOfPlates.innerHTML = "Todas";
			this.resultsNode = dojo.query(".plateList",this.domNode)[0];
			this.imageNode = document.createElement('img');
			this.imageNode.src = dojo.moduleUrl("com.copacabana", "images/loader.gif");
			this.imageNode.alt="executing search";
			this.imageNode.title="executing search";
			this.refreshPlateList();		        
			dojo.subscribe("onCategoryChanged",dojo.hitch(this, "changedCategory"));			
		} catch (e) {
			console.error("PlateList 01 ",e);
		}
	},
	changedCategory:function(data){
		this.cleanResultsNWait();
		while(this.plateList.length>0) {
			var plate = this.plateList.pop();
			plate.destroy(false);			
		}
		this.totalPlates.innerHTML = 0;
		this.categoryId=data.catId;
		this.categoryOfPlates.innerHTML=data.catName;		
		this.updatePlateList(false);
	}
	
});

}

if(!dojo._hasResource["com.copacabana.RestaurantTypeOptionWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.RestaurantTypeOptionWidget"] = true;
dojo.provide("com.copacabana.RestaurantTypeOptionWidget");








dojo.declare("com.copacabana.RestaurantTypeOptionWidget", [ dijit._Widget,
		dijit._Templated ], {
	i18nString : null,
	title : "",
	url : null,
	templateString:"<div>\r\n<div class=\"tipo ${cat.type} cheio\" style=\"top: ${cat.top}px;\" id=\"${cat.id}\" dojoAttachEvent=\"onclick:showRestaurantList\">${cat.name}</div>\r\n</div>\r\n",
	constructor : function(cat) {
		
		this.cat = cat;
		this.cat.top = 35 + 35 * cat.index;
	},
	cat : {},
	postMixInProperties : function() {
		this.inherited(arguments);
	},

	postCreate : function() {
		this.inherited(arguments);
		dojo.parser.parse(this.domNode);

	},

	startup : function() {

	},	
	delegateFctToDisplayRestaurants:null,
	showRestaurantList : function() {
		this.delegateFctToDisplayRestaurants(this.cat);
				
	}

});

}

if(!dojo._hasResource["com.copacabana.PlateOrderOptionsWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.PlateOrderOptionsWidget"] = true;
dojo.provide("com.copacabana.PlateOrderOptionsWidget");









	


//I18N


 


dojo.declare("com.copacabana.PlateOrderOptionsWidget", [
		dijit._Widget, dijit._Templated ], {
	i18nStrings: null,
	templateString:"<tr>\r\n\t<td colspan=4><div dojoAttachPoint=\"moreOptions\" dojoAttachEvent='onclick:wipeIt' title=\"${i18nStrings.optionsTitle}\" style=\"color: #FF9B69;cursor: pointer;\"></div>\r\n\t<div dojoAttachPoint=\"moreOptionsSection\" style=\"display: none\">\r\n\t<table style=\"width: 100%;\">\r\n\t<thead></thead>\r\n\t<tbody dojoAttachPoint=\"optList\">\t\r\n\t</tbody>\r\n\t</table>\r\n\t</div>\r\n\t</td>\r\n</tr>\r\n",
	orderDisabled:false,
	optionsList:null,
	mainPlateTitle:null,
	constructor : function(optionsList,mainPlateTitle,disabled) {
		
		this.mainPlateTitle=mainPlateTitle;
		this.optionsList=optionsList;		
		this.orderDisabled=disabled;
		
	},
	
	plate:null,
	
	postCreate : function() {
		
		//this.inherited(arguments);//Not sure why it was breaking..
		this.i18nStrings=dojo.i18n.getLocalization("com.copacabana", "PlateOrderOptionsWidgetStrings");
		
	},	
	connections:[],
	destroyRecursive : function() {
		dojo.unsubscribe(this.subscribeAddOption);
		while(this.connections.length>0){
			dojo.disconnect(this.connections.pop());
		}
		dojo.forEach(this.getDescendants(), function(widget) {
			widget.destroyRecursive();
		});
		this.inherited(arguments);
	},
	subscribeAddOption:null,
	largeImgDiv:null,
	startup : function() {
		try {
			
			dojo.parser.parse(this.domNode);

			if(this.optionsList.length>1){				
				this.moreOptions.innerHTML =  dojo.string.substitute(this.i18nStrings.optionsLabel,[this.optionsList.length]); 
			}else if(this.optionsList.length==1){
				this.moreOptions.innerHTML =  dojo.string.substitute(this.i18nStrings.singleOptionLabel,[this.optionsList.length]);
			}			
			var trStyle={borderBottom:'1px solid #EB7D4B'};


			this.subscribeAddOption=dojo.subscribe('onAddPlateOption',dojo.hitch(this,this.onClick));
			for ( var i = 0; i < this.optionsList.length; i++) {
				var option = this.optionsList[i];
				//<tr><td>Tamanho m�dio</td><td>R$ 10,00</td><td><td><img alt="Pedir" src="/resources/img/btPedir.png" dojoAttachEvent="onclick:onClick" style="cursor: pointer;"/></td></tr>
				var tr;
				if((i+1) < this.optionsList.length){
					tr = dojo.create('tr',{style:trStyle},this.optList);
				}else{
					tr = dojo.create('tr',{},this.optList);
				}
				dojo.create('td',{innerHTML:option.title},tr);
				var price = com.copacabana.util.moneyFormatter(option.price);
				
				dojo.create('td',{innerHTML:price},tr);
				dojo.create('td',{},tr);
				var action = dojo.create('td',{},tr);
				if(this.orderDisabled!=true){

					var btn = dojo.create('img',{alt:'Pedir',src:'/resources/img/btPedir.png',style:{cursor:'pointer'}},action);

					var ff ={ 
							id:option.id,
							date:new Date(),
							title:option.title,
							addToBasket:function(){
								console.log('creation date',this.date);
								//dojo.publish('onAddPlateOption',[this.id]);
								this.addPlate(this.id);
							}							
					}
					ff.addPlate=dojo.hitch(this,this.onClick);
					this.connections.push(dojo.connect(btn, 'onclick', ff,"addToBasket", true));
				}			
			}
			dojo.subscribe('onExpandOptions',dojo.hitch(this,this.onOtherWipeIn));			
		} catch (e) {
			console.error("plateOrder start", e);
		}
	},
	expanded:false,
	onOtherWipeIn:function(id){
		if(this.id!=id && this.expanded==true){
			this.wipeOut();
		}
	},
	wipeOut:function () {		
		
			this.expanded=false;
			dojo.style(this.moreOptionsSection, "height", "");
			dojo.style(this.moreOptionsSection, "display", "block");
			var wipeArgs = {
					node:this.moreOptionsSection
			};
			dojo.fx.wipeOut(wipeArgs).play();
		
    },
   
    wipeIt:function () {
    	if(this.expanded==true){
    		this.wipeOut();    		
    	}else{
    		this.expanded=true;
    		dojo.publish('onExpandOptions',[this.id]);
    		dojo.style(this.moreOptionsSection, "display", "none");
    		var wipeArgs = {
    				node: this.moreOptionsSection
    		};
    		dojo.fx.wipeIn(wipeArgs).play();
    		console.log('efoi?')
    	}
    },
	onClick:function(id){
		if(!this.optionsList){
			return;
		}
		for ( var i = 0; i < this.optionsList.length; i++) {
			if(this.optionsList[i].id==id){
				var pedidoHandler = dijit.byId("pedidoWrapper");
				var p = dojo.clone(this.optionsList[i]);
				p.title=this.mainPlateTitle+':'+p.title;
				pedidoHandler.addPlate(p,1);		
			}
			
		}
		
		
	},
	increase:function(){
		var qtyNode = dijit.byNode(dojo.query(".quantidadeValue", this.domNode)[0]);
		qtyNode.attr("value",parseFloat(qtyNode.attr("value"))+1);		
	},
	decrease:function(){
		var qtyNode = dijit.byNode(dojo.query(".quantidadeValue", this.domNode)[0]);
		if(parseFloat(qtyNode.attr("value"))>0){
			qtyNode.attr("value",parseFloat(qtyNode.attr("value"))-1);
		}
	}
	

});

}

if(!dojo._hasResource["com.copacabana.FractionPlateWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.FractionPlateWidget"] = true;
dojo.provide("com.copacabana.FractionPlateWidget");








// I18N





dojo.declare("com.copacabana.FractionPlateWidget", [ dijit._Widget,
		dijit._Templated ], {
	// i18nStrings: dojo.i18n.getLocalization("com.copacabana",
	// "PlatesListWidgetStrings"),
	templateString:"<div>\r\n<div style=\"-moz-border-radius: 3px 3px 3px 3px;border: 1px solid;padding: 5px;\"><img src='/resources/img/measure.png'>Qual o tamanho?  <select dojoType=\"dijit.form.FilteringSelect\" class=\"plateSize\" dojoAttachPoint=\"plateSize\" dojoAttachEvent=\"onblur:sizeChanged,onChange:sizeChanged\">\r\n    <option value=\"NONE\" selected>\r\n        Grande\r\n    </option>\r\n    <option value=\"MEDIUM\" >\r\n        Média\r\n    </option>\r\n    <option value=\"SMALL\">\r\n        Pequena\r\n    </option>\r\n</select>\r\n</div>\r\n<div style=\"-moz-border-radius: 3px 3px 3px 3px;border: 1px solid;padding: 5px;\">\r\nQuais são os sabores?\r\n<br />\r\nSelecione cada metade:<br/>\r\n<table style=\"width: 450px;\">\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td valign=\"top\" style=\"width: 70%;text-align: left;\">\t\r\n\t\t\t<table>\t\t\r\n\t\t\t<tr>\r\n\t\t\t<td>1/2</td><td style=\"text-align: left;\"><select searchAttr=\"title\" labelAttr=\"img\" labelType=\"html\" dojoType=\"dijit.form.FilteringSelect\" class=\"plateOne\" autoComplete=\"false\" selectOnClick=\"true\" invalidMessage=\"Prato n&atilde;o encontrado\"></select></td><td><span dojoAttachPoint='plate1Info'></span></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t<td>1/2</td><td style=\"text-align: left;\"><select searchAttr=\"title\" labelAttr=\"img\" labelType=\"html\" dojoType=\"dijit.form.FilteringSelect\" class=\"plateTwo\" autoComplete=\"false\" selectOnClick=\"true\" invalidMessage=\"Prato n&atilde;o encontrado\"  ></select></td><td><span dojoAttachPoint='plate2Info'></span></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr><td></td><td colspan=\"2\"><div dojoAttachPoint='totalInfo' style=\"height: 15px; text-align: right;\"></div></td></tr>\r\n\t\t\t\r\n\t\t\t</table>\r\n\t\t\t</td> \r\n\t\t\t<td>\r\n\t\t\t<div class=\"circle\" style=\"width: 82px; height: 80px;\">\r\n\t\t\t<div class=\"halfOne turnOff\" ></div>\r\n\t\t\t<div class=\"halfTwo turnOff\" ></div>\r\n\t\t\t</div>\r\n\t\t\t</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n</div>\r\n<div style=\"width: 100%; text-align: center; margin-top: 15px;\">\r\n<img alt=\"Pedir\" src=\"/resources/img/btPedir.png\" dojoAttachEvent=\"onclick:onClick\" style=\"cursor: pointer;\"/>\r\n</div>\r\n</div>\r\n\t\t\t\r\n",
	constructor : function(args) {
		this.plates = dojo.clone(args.catPlates);
		this.rest=dojo.clone(args.rest);

	},
	sizeChanged:function(val){		
		console.log('size Changed',val);
		var sortAttributes = [{attribute: "title", descending: false}];
		var queryData= {
				query: {"plateSize":val},
				queryOptions: {},
				sort: sortAttributes,
				onBegin: function(){console.log('begining')},
				onComplete: dojo.hitch(this,function(items, request){
					var availablePlates=[];
					for (i = 0; i < items.length; i++) {
						var item = items[i];
						var title = this.plateStore.getValue(item, "title");
						var imageUrl = this.plateStore.getValue(item, "imageUrl");
						
						if(this.plateStore.getValue(item, "isExtension")==true){
							title=this.plateStore.getValue(item, "name");
							imageUrl=this.plateStore.getValue(item, "mainPlateImageUrl");
							console.log(this.plateStore.getValue(item, "mainPlateTitle"));
							console.log(this.plateStore.getValue(item, "mainPlateImageUrl"));
						}
						var htmlTitle=title;
						if(imageUrl!=null && imageUrl.length>0) {
							htmlTitle='<img src="'+imageUrl+'.small" />'+title;
						}
						availablePlates.push(
								{
									id:this.plateStore.getValue(item, "id"),
									title:title,
									'img':htmlTitle
								}		
						);
						console.log(this.plateStore.getValue(item, "title"));	                        
					}
					var store=new dojo.data.ItemFileReadStore({
						data:{
							'identifier':'id',
							'label':'title',
							'items':availablePlates
						}
					});
					//todo set the value similar to the existing selection
					      	   
					this.prato1.reset();
					this.prato2.reset();					
					this.prato2.queryExpr="*${0}*";
					this.prato1.queryExpr="*${0}*";
					this.prato1.store=store;
					this.prato2.store=store;  
					this.updateTotals();
				}),
				onError: function(err){console.error(err)}
		};
		var items = {
				identifier:'id',
				label:'name',
				items:this.plates
		}
		this.plateStore = new dojo.data.ItemFileReadStore({
			data:items
		});	
		this.plateStore.fetch(queryData);
	},
	prato1:null,
	prato2:null,
	halfDialog:null,
	plateStore:null,
	plateSize:null,
	startup : function() {
		dojo.parser.parse(this.domNode);
		
		this.prato1 = dijit.byNode(dojo.query(".plateOne",this.domNode)[0]);		
		this.plateSize = dijit.byNode(dojo.query(".plateSize",this.domNode)[0]);
		this.prato2 = dijit.byNode(dojo.query(".plateTwo",this.domNode)[0]);
		
		this.sizeChanged('NONE');
		
		dojo.connect(this.plateSize, "onChange", dojo.hitch(this,this.sizeChanged));
		dojo.connect(this.prato1, "onChange", dojo.hitch(this,this.changeHalfOne));		
		dojo.connect(this.prato2, "onChange", dojo.hitch(this,this.changeHalfTwo));
		
		var options ={
				closable:true,
			title : "Meia pizza",
			style : 'border:1px solid black;',
			content: this.domNode
		}	
		
		this.halfDialog = new dijit.Dialog(options);	
		this.halfDialog.show();
		
	},
	postCreate : function() {
		this.inherited(arguments);
		this.i18nStrings = dojo.i18n.getLocalization("com.copacabana",	"FractionPlateWidgetStrings");
	},
	onClick:function(evt){		
		if(this.selectedPlate1!=null && this.selectedPlate2!=null){
			console.log('criar pedido');
			var pedidoHandler = dijit.byId("pedidoWrapper");
			
			var title = "";
			console.log("isExtension",this.selectedPlate1.isExtension);
			if(this.selectedPlate1.isExtension.length>0){
				this.selectedPlate1.isExtension=this.selectedPlate1.isExtension[0];
			}
			if(this.selectedPlate2.isExtension.length>0){
				this.selectedPlate2.isExtension=this.selectedPlate2.isExtension[0];
			}
			if(this.selectedPlate1.isExtension==true){
				title = "1/2 "+this.selectedPlate1.mainPlateTitle;
			}else{
				title = "1/2 "+this.selectedPlate1.name;
			}
			if(this.selectedPlate2.isExtension==true){
				title += "1/2 "+this.selectedPlate2.mainPlateTitle;
			}else{
				title += "1/2 "+this.selectedPlate2.name;
			}
			if(this.selectedPlate1.plateSize!='NONE'){
				if(this.selectedPlate1.plateSize=='SMALL'){
					title='Pqna '+title; 
				}
				if(this.selectedPlate1.plateSize=='MEDIUM'){
					title='Média '+title; 
				}
			}
			pedidoHandler.addFractionPlate(this.selectedPlate1,this.selectedPlate2,1,title,this.getCost());
			this.halfDialog.hide();
			
		}else{
			var msg = new com.copacabana.MessageWidget();
			msg.showMsg("Por favor selecione as duas metades.");
		}
		
		
	},
	changeHalfOne:function(evt){
		this.selectedPlate1=this.changeHalf(this.prato1, ".halfOne", this.plate1Info);
		this.updateTotals();
	},
	changeHalfTwo:function(evt){
		this.selectedPlate2=this.changeHalf(this.prato2, ".halfTwo", this.plate2Info);
		this.updateTotals();
	},
	changeHalf:function(selectWidget,classHalf,domPlace){
		
		var plateHandler;
		if(selectWidget.attr('value')!=null && selectWidget.attr('value')!=''){
			dojo.removeClass(dojo.query(classHalf,this.domNode)[0],'turnOff');
			plateHandler=this.showPlateInfo(selectWidget.attr('value'),domPlace);			
		}else{
			domPlace.innerHTML='';
			dojo.addClass(dojo.query(classHalf,this.domNode)[0],'turnOff');
			plateHandler=null;			
		}
		return plateHandler;
	},
	getPlateInfo:function(pid){
		for ( var i = 0; i < this.plates.length; i++) {
			var p = this.plates[i];
			if(p.id==pid){
				return p;
			}
		}
		console.error('cannot find plate',pid);
	},
	updateTotals:function(){
		if(this.selectedPlate1!=null && this.selectedPlate2!=null){
			var total = this.getCost();
			this.totalInfo.innerHTML="Pre&ccedil;o final: "+com.copacabana.util.moneyFormatter(total);
		}else{
			this.totalInfo.innerHTML='';	
		}
		
	},
	rest:null,	
	getCost:function(){
		console.log("calculus type: ",this.rest.fractionPriceType);
		if(!this.rest.fractionPriceType){
			this.rest.fractionPriceType='HALFHALF';			
		}
		switch (this.rest.fractionPriceType) {
			case 'HALFHALF':
				return (parseFloat(this.selectedPlate1.price)/2)+(parseFloat(this.selectedPlate2.price)/2);	
				break;
			case 'MOREEXPENSIVEWINS':
				if(parseFloat(this.selectedPlate1.price)>parseFloat(this.selectedPlate2.price)){
					return parseFloat(this.selectedPlate1.price); 
				}else{
					return parseFloat(this.selectedPlate2.price); 
				}
				break;
	
			default:
				return (parseFloat(this.selectedPlate1.price)/2)+(parseFloat(this.selectedPlate2.price)/2);
			break;
		}

	},
	selectedPlate1:null,
	selectedPlate2:null,
	showPlateInfo:function(id,domPlace){
		var plateInfo = this.getPlateInfo(id);
		domPlace.innerHTML= com.copacabana.util.moneyFormatter(plateInfo.price);// "1/2
																				// "+plateInfo.name;
		return plateInfo;
		
	}
	

});

}

if(!dojo._hasResource["com.copacabana.RestPlateMenuWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.RestPlateMenuWidget"] = true;
dojo.provide("com.copacabana.RestPlateMenuWidget");










//I18N





dojo.declare("com.copacabana.RestPlateMenuWidget", [ dijit._Widget,
                                                     dijit._Templated ], {
	i18nStrings : null,
	templateString:"<div class=\"cardapio\" style=\"width: 650px\">\r\n<h2>Card&aacute;pio<img src=\"/resources/img/loader.gif\" class=\"loadingSection\" style=\"width:15px;\"/></h2>\r\n\r\n<ul id=\"categorias\" style=\"display:block\">\r\n\t\t<li></li>\r\n</ul>\r\n<div class=\"addFractionPlate\" dojoAttachEvent=\"onclick:addFractionPlate\"  ><button baseClass=\"orangeButton\" dojoType=\"dijit.form.Button\">Monte sua pizza meio a meio</button><br/></div>\r\n<table id=\"cardapio\"  style=\"margin: -15px 0px 0px 100px;\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>Descri&ccedil;&atilde;o</th>\r\n\t\t\t<th>Pre&ccedil;o Unit&aacute;rio</th>\r\n\t\t\t<th><span class=\"qtdLabel\">Quantidade</span></th>\r\n\t\t\t<th> </th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody class=\"plateMenuList\">\t\t\r\n\t</tbody>\r\n</table>\r\n\r\n</div>\r\n",
	constructor : function() {
		this.id = "cardapio";
		console.log("Created RestPlateMenuWidget: id "+this.id);

	},
	postMixInProperties: function(){
		if (dijit.byId(this.id)) {
			dijit.byId(this.id).destroyRecursive();
		}
	},
	destroyRecursive: function(){
		console.log("destroying RestPlateMenuWidget");
		while(this.plateList.length>0){
			var v = this.plateList.pop();
			v.destroyRecursive(false);
		}
		dojo.forEach(this.getDescendants(), function(widget){
			console.log("RestPlateMenuWidget destroying "+widget.id);
			widget.destroyRecursive();
		});
		this.inherited(arguments);
	},
	rest:null,
	setRestaurant:function(rest){
		this.rest=rest;
	},
	

	postCreate : function() {
		this.inherited(arguments);
		this.i18nStrings=dojo.i18n.getLocalization("com.copacabana",
		"RestPlateMenuWidgetStrings");
	},
	resultsNode:null,
	isHighlight:function(id){
		for ( var i = 0; i < this.highlights.length; i++) {
			if(this.highlights[i]==id){
				return true;
			}
		}
		return false;
	},
	extensions:[],
	highlights:[],
	populatePlateList : function(entity,highlight) {

		this.resultsNode = dojo.query(".plateMenuList", this.domNode)[0];

		var results = entity.plates;

		this.catNodes=[];
		this.categoryList=[];
		this.highlights =entity.highlights;
		//this.createAllCategoriesNode();
		
		this.createHighlighCategoriesNode();
		
		var counter=0;

		if(results.length===0){
			this.resultsNode.innerHTML=this.i18nStrings.noPlatesInCategory;	
		}else{	
			var disable=false;
			if(this.rest.isOpen==false || (this.rest.siteStatus && this.rest.siteStatus!='ACTIVE')){
				disable=true;
			}
			var counter=0;
			this.extensions=[];
			for ( var i = 0; i < results.length; i++) {
				var p = results[i];
				if(p.availableTurn!='ANY'){
					if(p.currentTurn!=p.availableTurn){
						results.splice(i,1);
						i--;
					}
				}
				if(p.isExtension==true){
					if(this.extensions[p.extendsPlate]==null){
						this.extensions[p.extendsPlate]=[];
					}
					this.extensions[p.extendsPlate].push(p);
					results.splice(i,1);
					i--;
				}
			}
			for ( var i = 0; i < results.length; i++) {
				var p = results[i];
				if(p.status=='HIDDEN'){
					continue;
				}
				
				

				var wid = new com.copacabana.PlateOrderWidget(p,disable);
				wid.startup();
				

				
				if(this.extensions[p.id]!=null){					
					var wids = new com.copacabana.PlateOrderOptionsWidget(this.extensions[p.id],p.title,disable);
					wids.startup();
					wid.options=wids;
				}

				this.plateList.push(wid);
				if(this.isHighlight(p.id)==true){
					if(counter%2==0){
						dojo.style(wid.domNode,'backgroundColor','#E9E6E6');
					}
					this.resultsNode.appendChild(wid.domNode);
					if(wid.options){
						if(counter%2==0){
							dojo.style(wid.options.domNode,'backgroundColor','#E9E6E6');
						}
						this.resultsNode.appendChild(wid.options.domNode);
					}
					counter++;

				}
				
			
				
				if(!this.categoryList[p.foodCategory]){
					this.categoryList[p.foodCategory]=true;
					var args = {
							identity: p.foodCategory,  
							onItem :dojo.hitch(this,this.onFoodCatFound),
							onError : function(item, request) {
								console.error(item);
							}
					};
					foodCategoriesCache.fetchItemByIdentity(args);
				}
			}			
		}


	},
	hasProcessedFraction:false,
	fractionCategory:[],
	showFractionedOrder:function(show,catId){
		this.fractionCategory[catId]=true;
		if(this.hasProcessedFraction==true){
			return;
		}

		var fractionNode = dojo.query('.addFractionPlate',this.domNode)[0];
		var restNotAvailable = (this.rest.isOpen==false || (this.rest.siteStatus && this.rest.siteStatus!='ACTIVE'));
		if(restNotAvailable==false && show==true){
			dojo.style(fractionNode,'display','block');
		}else{
			dojo.style(fractionNode,'display','none');
		}
		this.hasProcessedFraction=true;
	},
	onFoodCatFound:function(item, request) {			        	
		var catDiv=dojo.create("li",{property:"commerce:cuisine"});

		//document.createElement("li");

		if(item.name.length==1){
			item.name=item.name[0];
		}
		if(item.name.length>=5 && item.name.substr(0,5)=='Pizza'){
			this.showFractionedOrder(true,item.id);
		}
		var maxlength=10;
		var catName= dojo.clone(item.name);
		if(item.name.length>maxlength){
			if(item.name.substr(0,maxlength).indexOf(' ')==-1 ){
				catName=item.name.substr(0,maxlength)+'- '+item.name.substr(maxlength);
			}
		}
		catDiv.innerHTML=catName;
		this.catNodes[item.id]=catDiv;
		dojo.byId("categorias").appendChild(catDiv);
		var fct=function(evt){
			this.updatePlateList(evt,item.id,item.name);									
		}
		dojo.connect(catDiv,"onclick",dojo.hitch(this,fct));
	},
	catNodes:[],
	currCategory:null,
	updatePlateList:function(evt,category,catName){
		this.currCategory=category;


		com.copacabana.util.cleanNode(this.resultsNode);
		var curr = dojo.query(".selecionado",this.domNode)[0];				
		dojo.removeClass(curr,"selecionado");		
		dojo.addClass(this.catNodes[category],"selecionado");
		var counter=0;
		for ( var i = 0; i < this.plateList.length; i++) {
			var wid = this.plateList[i];
			if(category=="highlights" && this.isHighlight(wid.plate.id)){
					if(counter%2==0){
						dojo.style(wid.domNode,'backgroundColor','#E9E6E6');
					}else{
						dojo.style(wid.domNode,'backgroundColor','#FFFFFF');
					}
					
					this.resultsNode.appendChild(wid.domNode);
					if(wid.options){
						if(counter%2==0){
							dojo.style(wid.options.domNode,'backgroundColor','#E9E6E6');
						}else{
							dojo.style(wid.options.domNode,'backgroundColor','#FFFFFF');
						}
						this.resultsNode.appendChild(wid.options.domNode);
					}
					counter++;
				
			}else{

				if(wid.plate.foodCategory==category || category=="all"){
					if(counter%2==0){
						dojo.style(wid.domNode,'backgroundColor','#E9E6E6');
					}else{
						dojo.style(wid.domNode,'backgroundColor','#FFFFFF');
					}
					
					this.resultsNode.appendChild(wid.domNode);
					
					if(wid.options){
						if(counter%2==0){
							dojo.style(wid.options.domNode,'backgroundColor','#E9E6E6');
						}else{
							dojo.style(wid.options.domNode,'backgroundColor','#FFFFFF');
						}
						this.resultsNode.appendChild(wid.options.domNode);
					}
					counter++;
					
				}
				
			}
		}			
	},
	hideloading:function(){
		dojo.style(dojo.query('.loadingSection',this.domNode)[0],'display','none'); 
	},
	categoryList:[],
	plateList:[],
	loadedPlates:function(data) {
		this.hideloading();
		try{
			var  response = dojo.fromJson(data);			
			this.populatePlateList(response);
		}catch(e){
			console.error("loaded plates but can't display it",e);
		}
	},

	createAllCategoriesNode:function(){		
		var catDiv=document.createElement("li");
		catDiv.innerHTML=this.i18nStrings.allCategories;
		this.catNodes["all"]=catDiv;		
		var fct=function(evt){
			this.updatePlateList(evt,"all");									
		};
		dojo.connect(catDiv,"onclick",dojo.hitch(this,fct));

		dojo.byId("categorias").appendChild(catDiv);
		dojo.addClass(catDiv,"selecionado");
	},
	createHighlighCategoriesNode:function(){		
		var catDiv=document.createElement("li");
		catDiv.innerHTML=this.i18nStrings.highlights;
		this.catNodes["highlights"]=catDiv;		
		var fct=function(evt){
			this.updatePlateList(evt,"highlights");									
		};
		dojo.connect(catDiv,"onclick",dojo.hitch(this,fct));

		dojo.byId("categorias").appendChild(catDiv);
		dojo.addClass(catDiv,"selecionado");
	},
	startup : function() {
		try {
			dojo.parser.parse(this.domNode);
			if(this.rest.isOpen==false || (this.rest.siteStatus && this.rest.siteStatus!='ACTIVE')){
				dojo.query(".qtdLabel",this.domNode)[0].innerHTML='';	
			}
		} catch (e) {
			console.log(e);
		}
	},
	preFetched:null,
	loadedHighlights:function(data){
		this.populatePlateList(data);
	},
	loadHighlights:function(){		
		var xhrArgs = {
				url : "/destaquesRestaurante.do?key=" + this.rest.id,
				handleAs : "json",
				load : dojo.hitch(this, this.loadedHighlights),
				error : function(error) {
					console.error("cannot load rest. high plates ",error);
				}
		};
		var deferred = dojo.xhrPost(xhrArgs);	
	},
	show:function(){		
		if(this.preFetched==null){
			var xhrArgs = {
					url : "/destaquesRestaurante.do?key=" + this.rest.id,
					handleAs : "text",
					load : dojo.hitch(this, this.loadedPlates),
					error : function(error) {
						console.error("cannot load rest. plates ",error);
					}
			};
			var deferred = dojo.xhrPost(xhrArgs);	
		}else{
			this.populatePlateList(this.preFetched);
			this.hideloading();
		}
	},
	halfDialog:null,
	addFractionPlate:function(){
		var catplateList=[];
		for ( var i = 0; i < this.plateList.length; i++) {
			var wid = this.plateList[i];
			if(this.fractionCategory[wid.plate.foodCategory]==true && wid.plate.status=='AVAILABLE'){
				catplateList.push(wid.plate);
				
				if(wid.options){
					for(var id in wid.options.optionsList){
						var popt = wid.options.optionsList[id];
						var pp = dojo.clone(popt);
						pp.name=wid.plate.title+":"+pp.title;
						pp.mainPlateTitle=wid.plate.title;
						pp.mainPlateImageUrl=wid.plate.imageUrl;
						catplateList.push(pp);
					}
				}
			}			
		}
		var fdialog = new com.copacabana.FractionPlateWidget({catPlates:catplateList,rest:this.rest});
		fdialog.startup();

	},
	addHalfPlate:function(args){
		console.log(args)
	}

});

}

if(!dojo._hasResource["com.copacabana.RestaurantViewWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.RestaurantViewWidget"] = true;
dojo.provide("com.copacabana.RestaurantViewWidget");









//Require the Tooltip class


//I18N


 


dojo.declare("com.copacabana.RestaurantViewWidget", 
		[ dijit._Widget, dijit._Templated ], {
	i18nStrings: null,
	openingStr:null,
	templateString:"<div style=\"font-family: Arial,sans-serif;font-size: 62.5%;color: #555;\">\r\n<div class=\"restaurantinfo\" style=\"background: #F7F7F7;padding: 10px 10px 22px 10px;margin-bottom: 1em;border: 1px solid #DDD;\">\r\n<div class=\"ratingbox\" dojoAttachPoint=\"facebookDom\"></div>\r\n<h1 class=\"consumer\">\r\n\t\t<a class=\"VendorName\" dojoAttachPoint=\"restName\">\r\n\t\t    </a>&nbsp;<span class=\"priceRating\"></span></h1>\r\n\t\t<div style=\"float:right;\" dojoAttachPoint=\"logoNode\"></div>\r\n\t    <p style=\"margin:2px;max-height: 105px;\">\r\n\t\t<span dojoAttachPoint=\"restDescription\"></span><br/>\r\n\t\t<span dojoAttachPoint=\"restAddress\" style=\"clear:both;\"></span>\r\n\t\t</p>\r\n\t\t<div dojoAttachPoint=\"openStatus\"></div>\r\n\t    <div class=\"restaurantdetails\">\r\n\t    <p class=\"paymenttype\">\r\n\t\t   Aceita <strong dojoAttachPoint=\"paymentTypes\"></strong>. \r\n\t\t</p>\r\n\t\t<p class=\"info\" style=\"display:none;\" dojoAttachPoint=\"neighSelected\">\r\n\t\t    Taxa de entrega <strong dojoAttachPoint=\"delCost\"><img src=\"/resources/img/loading.gif\"></strong> <span dojoAttachPoint=\"minSection\"></span><br> para o bairro <span dojoAttachPoint=\"destNeigh\" title=\"Clique para trocar o bairro\" style=\"cursor: pointer; text-decoration: underline; font-weight: bold;\"></span> (<a class=\"tooltip-header\" dojoAttachPoint=\"infoSectionDelivery\">mais informa&ccedil;&otilde;es</a>) \r\n\t\t</p>\r\n\t\t<p class=\"info\" style=\"display:none;\" dojoAttachPoint=\"entireCity\">\r\n\t\t    Taxa de entrega <strong dojoAttachPoint=\"delCostCity\"><img src=\"/resources/img/loading.gif\"></strong> <span dojoAttachPoint=\"minSectionCity\"></span><br> para todos os bairros de <span dojoAttachPoint=\"cityName\"></span> (<a class=\"tooltip-header\" dojoAttachPoint=\"infoSectionCity\">mais informa&ccedil;&otilde;es</a>) \r\n\t\t</p>\r\n\t\t<p class=\"info\" style=\"display:none;\" dojoAttachPoint=\"neighNotSelected\">\r\n\t\t     Selecione um bairro da &aacute;rea de entrega: <select dojoType=\"dijit.form.FilteringSelect\" class=\"nSelection\"\r\n\t\t      autoComplete=\"false\" selectOnClick=\"true\" hasDownArrow=\"false\" invalidMessage=\"Bairro fora da &aacute;rea do restaurante\" promptMessage=\"Digite o bairro\"  style=\"background-color: white;width: 150px;margin-bottom:0px;margin-top: 0px;\" ></select>\r\n\t\t</p>\r\n\t\t\r\n\t\t<p class=\"readytime\">\r\n\t\t    Prazo de entrega estimado <strong dojoAttachPoint=\"estimateForecast\">30 min</strong> (<a class=\"tooltip-header\" dojoAttachPoint=\"alertaEntrega\" >mais informa&ccedil;&otilde;es</a>).\r\n\t\t</p>\r\n\t\t\r\n\t    </div>\r\n\t</div>\r\n<div id=\"pedido\" class=\"pedidoWidget\" style=\"float:right;position:relative;top:0px;\"></div>\r\n<div style=\"width: 650px;\">\r\n<div  class=\"cardapioPanel\" dojoAttachPoint=\"cardapioDomNode\"></div>\r\n</div>\r\n\r\n</div>\r\n",
	constructor : function(rest) {
		
		this.rest=rest;
		
		

//		if(this.rest.onlyForRetrieval==true){
//			this.strings.moredata+=' * Somente pedidos para retirar no restaurante.';	
//		}
		this.id=rest.id+"_RestaurantView";



	},
	postMixInProperties: function(){
		if (dijit.byId(this.id)) {
			dijit.byId(this.id).destroyRecursive();
		}
	}, 
	destroyRecursive: function(){

		if(this.restPlateMenu!=null){
			console.log("destroying restPlateMenu");
			this.restPlateMenu.destroy();
			this.restPlateMenu.destroyDescendants(false);
			this.restPlateMenu.destroyRecursive(false);
		}
		if(this.order!=null){
			console.log("destroying order");
			this.order.destroy(false);
			this.order.destroyDescendants(false);
			this.order.destroyRecursive(false);
		}

		dojo.forEach(this.getDescendants(), function(widget){
			console.log(" RestaurantViewWidget destroying "+widget.id);
			widget.destroyRecursive();
		});
		this.inherited(arguments);
	},
	imageNode:null,
	

	postCreate : function() {
		this.inherited(arguments);	
		this.i18nStrings=dojo.i18n.getLocalization("com.copacabana", "RestaurantViewWidgetStrings");
	},
	rest:null,
	setRestaurant:function(rest){
		this.rest=rest;
	},
	strings:{
		restName:"",
		description:""
	},

	showPanel:function(){
		
		
		/*
		//this.strings.restName=this.rest.name;
		if(this.rest.uniqueUrlName && this.rest.uniqueUrlName.length>0){
			dojo.create("a",{href:'/'+ this.rest.uniqueUrlName ,innerHTML:this.rest.name,style:{fontSize: '1.4em'}},this.restNamePlace);

		}else{
			var url = '/?showRestaurant=true&restaurantId='+this.rest.id;
			dojo.create("a",{href:url,innerHTML:this.rest.name,style:{fontSize: '1.4em',color:'#605D5D'}},this.restNamePlace);		

		}
		this.strings.description=this.rest.description;
		dojo.parser.parse(this.domNode);
		

		if(this.rest.imgUrl && this.rest.imgUrl !=""){
			this.imageNode =  document.createElement('img');
			this.imageNode.src = this.rest.imgUrl;
			this.imageNode.alt=this.rest.name;
			this.imageNode.title=this.rest.name;
			var imgNode = dojo.query(".imagem",this.domNode)[0];
			imgNode.appendChild(this.imageNode);
		}

		if(this.rest.imgKeyString && this.rest.imgKeyString !=""){
			this.imageNode =  document.createElement('img');
			dojo.addClass(this.imageNode,'restLogoPlace');

			this.imageNode.src = this.rest.imageUrl+".small";
			this.imageNode.alt=this.rest.name;
			this.imageNode.title=this.rest.name;
			if(!dojo.isIE){
				console.log('noneed');
			}else{
				this.imageNode.height=70;
				this.imageNode.width=70;
			}
			var imgNodelogo = dojo.query(".imagemRestLogo",this.domNode)[0];

			imgNodelogo.appendChild(this.imageNode);


		}

		var orderPosition = dojo.query(".pedidoWidget",this.domNode)[0];
		if(this.rest.isOpen==true && this.rest.siteStatus=='ACTIVE'){
			this.order = new com.copacabana.ClientOrderWidget();
			this.order.setRestaurant(this.rest);
			this.order.startup();		
			orderPosition.appendChild(this.order.domNode);
		}*/


	},
	selectedNeighborhood:function(evt){		
		this.showDelRangeInfo({id:evt});
	},
	order:null,
	restPlateMenu:null,
	startup : function() {
		try {
			dojo.parser.parse(this.domNode);
			this.delRangeSelection = dijit.byNode(dojo.query(".nSelection",this.domNode)[0]);			
			dojo.connect(this.delRangeSelection, "onChange", dojo.hitch(this,this.selectedNeighborhood));			
			dojo.connect(this.destNeigh, "onclick", dojo.hitch(this,this.switchToSelectNeigh));
			dojo.create("span",{innerHTML:this.rest.name,style:{fontSize:'large',color:'#EB7D4B'}},this.restName);
			
			if(this.rest.uniqueUrlName && this.rest.uniqueUrlName.length>0){
				this.restName.href='/'+ this.rest.uniqueUrlName;
			}else{
				var url = '/?showRestaurant=true&restaurantId='+this.rest.id;
				this.restName.href=url;		

			}
			
			if(this.rest.description && this.rest.description!=''){
				this.restDescription.innerHTML=this.rest.description;
			}
			this.restAddress.innerHTML = 'Telefone: '+this.rest.contact.phone;			
			
			if(this.rest.opensToday==false){
				this.openingStr='N&atilde;o abre hoje.';
			}else{
				this.openingStr="Hoje das "+this.rest.openingString+' &agrave;s '+this.rest.closingString;
				if(this.rest.hasSecondTurn==true){
					this.openingStr+=' e das ' + this.rest.secTurnOpeningString+' &agrave;s '+this.rest.secTurnClosingString;
				}
				this.openingStr+='.';
			}
			
			if(this.rest.siteStatus!='ACTIVE'){
				if(this.rest.siteStatus=='TEMPUNAVAILABLE'){
					this.openStatus.innerHTML='Indisponível';
					dojo.addClass(this.openStatus,"restaurantClosed");
					this.openStatus.title=this.i18nStrings.tempUnavailable;
				}else{
					this.openStatus.innerHTML='Breve';
					dojo.addClass(this.openStatus,"restaurantSoon");
					this.openStatus.title=this.i18nStrings.soonNoComendoBem;
				}
				//dojo.addClass(this.oStatusDom,'restaurantSoon');
				//dojo.removeClass(this.oStatusDom,'restaurantClosed');				

			}else{
				if(this.rest.isOpen!=true){
					this.openStatus.innerHTML='Restaurante está fechado neste momento.<br>';
					this.openStatus.innerHTML+=this.openingStr;
					dojo.addClass(this.openStatus,"alertMsg");
					this.openStatus.title=this.i18nStrings.closedInfo;								
					dojo.style(this.openStatus,'display','block');

				}else{
					this.openStatus.innerHTML=this.openingStr;
					//dojo.empty(this.oStatusDom);

					if(!this.rest.currentDelay || this.rest.currentDelay==null){
						this.rest.currentDelay='30 min';
					}

					var style={};
					switch (this.rest.currentDelay) {
					case 'ONCEADAY':
						this.estimateForecast.innerHTML='1x ao dia';						
						break;

					default:
						if(this.rest.currentDelay>45){
							//style={textDecoration:'blink'};
						}
					
					this.estimateForecast.innerHTML=this.rest.currentDelay+' mins';
					break;
					}					
				}
			}
			
			if(this.rest.acceptablePayments && this.rest.acceptablePayments.length>0){
				for(var i=0;i<this.rest.acceptablePayments.length;i++){
					if(this.i18nStrings["paymentType_"+this.rest.acceptablePayments[i]]){
						this.paymentTypes.innerHTML+=this.i18nStrings["paymentType_"+this.rest.acceptablePayments[i]];
						if((i+1)<this.rest.acceptablePayments.length){
							this.paymentTypes.innerHTML+=", "
						}
					}					
				}
			}

			if(this.rest.uniqueUrlName && this.rest.uniqueUrlName!=''){
				var host = window.location.hostname;
				if(!host){
					host=window.host;
				}				
								
				com.copacabana.util.createFacebookButtonCurrent(this.facebookDom,"http://"+host+"/"+this.rest.uniqueUrlName);
			}
			
			if(this.rest.imgUrl && this.rest.imgUrl !=""){
				this.imageNode = dojo.create("img",{src:this.rest.imgUrl,alt:this.rest.name,title:this.rest.name},this.logoNode)				
			}

			if(this.rest.imgKeyString && this.rest.imgKeyString !=""){
				this.imageNode = dojo.create("img",{style:{maxHeight:'100px'},src:this.rest.imageUrl,alt:this.rest.name,title:this.rest.name},this.logoNode)

				if(!dojo.isIE){
					console.log('noneed');
				}else{
					this.imageNode.height=100;
					this.imageNode.width=100;
				}
				
			}
			
			this.restPlateMenu = new com.copacabana.RestPlateMenuWidget();
			this.restPlateMenu.setRestaurant(this.rest);

			//var menu = dojo.query(".cardapioPanel",this.domNode)[0];
			var menu = this.cardapioDomNode;
			this.restPlateMenu.startup();
			this.restPlateMenu.show();
			
			menu.appendChild(this.restPlateMenu.domNode);
			
			var orderPosition = dojo.query(".pedidoWidget",this.domNode)[0];
			if(this.rest.isOpen==true && this.rest.siteStatus=='ACTIVE'){
				this.order = new com.copacabana.ClientOrderWidget();
				this.order.setRestaurant(this.rest);
				this.order.startup();		
				orderPosition.appendChild(this.order.domNode);
			}
			
			this.starttooltips();
			
			var searchWidget = dijit.byId('formularioBusca');
			var neighborhood = searchWidget.getSelectedNeighborhood();

			this.showDelRangeInfo(neighborhood);
			
		} catch (e) {
			console.error("RestViewWidget startup failed ",e.message);
		}
	},
	switchToSelectNeigh:function(){		
		this.showDelRangeInfo({id:null});
	},
	showDelRangeInfo:function(neighborhood){
		this.currentDelNeigh=neighborhood;
		if(neighborhood==null||!neighborhood.id){
			dojo.style(this.entireCity,"display","none");
			dojo.style(this.neighSelected,"display","none");
			this.delRangeSelection.reset();
			dojo.style(this.neighNotSelected,"display","block");
		}else{
			dojo.style(this.entireCity,"display","none");
			dojo.style(this.entireCity,"display","none");
			dojo.style(this.neighSelected,"display","block");
			dojo.style(this.neighNotSelected,"display","none");			
		}
		com.copacabana.util.loadDeliveryRange(this.rest.id,dojo.hitch(this,this.loadedDeliveryRange),function(error){console.error(error)});
	},
	currentDelNeigh:{id:null,name:null},
	loadedDeliveryRange:function(delRange){
		var dupefixes={};
		if(delRange.length==1 && delRange[0].neighborhood==null && delRange[0].city && delRange[0].city.id){
			dojo.style(this.neighNotSelected,"display","none");
			dojo.style(this.neighSelected,"display","none");
			dojo.style(this.entireCity,"display","block");
			var range= delRange[0];
			this.cityName.innerHTML=range.city.name;
			this.delCostCity.innerHTML=com.copacabana.util.moneyFormatter(range.deliveryRange.costInCents/100.0);
			if(range.deliveryRange.minimumOrderValueInCents && range.deliveryRange.minimumOrderValueInCents>0){
				this.minSectionCity.innerHTML=" com pedido m&iacute;nimo de <b>"+com.copacabana.util.moneyFormatter(range.deliveryRange.minimumOrderValueInCents/100.0)+"</b> ";	
			}else{
				this.minSectionCity.innerHTML="";
			}

		}else{
			var neighborhood = this.currentDelNeigh;
			var storeData = [];	
			var entireCityEntry=null;
			var foundNeigh=false;
			if(delRange.length>0) {		
				for(var i=0;i<delRange.length;i++){
					var range = delRange[i];
					if(range.neighborhood==null && range.city && range.city.id){
						entireCityEntry={
								costInCents:range.deliveryRange.costInCents,
								minimumOrderValueInCents:range.deliveryRange.minimumOrderValueInCents
						}
						continue;
					}
					if(dupefixes[range.neighborhood.id]==true){
						continue;
					}
					dupefixes[range.neighborhood.id]=true;
					
					storeData.push({name:range.neighborhood.name,id:range.neighborhood.id});;
					if(range.neighborhood.id==neighborhood.id){
						foundNeigh=true;
						this.destNeigh.innerHTML=range.neighborhood.name;
						this.delCost.innerHTML=com.copacabana.util.moneyFormatter(range.deliveryRange.costInCents/100.0);
						if(range.deliveryRange.minimumOrderValueInCents && range.deliveryRange.minimumOrderValueInCents>0){
							this.minSection.innerHTML=" com pedido m&iacute;nimo de <b>"+com.copacabana.util.moneyFormatter(range.deliveryRange.minimumOrderValueInCents/100.0)+"</b> ";	
						}else{
							this.minSection.innerHTML="";
						}
						console.log("minimumOrderValueInCents",range.deliveryRange.minimumOrderValueInCents);
					}
				}
				if(foundNeigh==false && entireCityEntry!=null){
					this.destNeigh.innerHTML=neighborhood.name;
					this.delCost.innerHTML=com.copacabana.util.moneyFormatter(entireCityEntry.costInCents/100.0);
					if(entireCityEntry.minimumOrderValueInCents && entireCityEntry.minimumOrderValueInCents>0){
						this.minSection.innerHTML=" com pedido m&iacute;nimo de <b>"+com.copacabana.util.moneyFormatter(entireCityEntry.minimumOrderValueInCents/100.0)+"</b> ";	
					}else{
						this.minSection.innerHTML="";
					}
					foundNeigh=true;
					
				}
				
				if(foundNeigh==false){
					dojo.style(this.entireCity,"display","none");
					dojo.style(this.neighSelected,"display","none");					
					dojo.style(this.neighNotSelected,"display","block");
				}
				
			}else{
				console.log("não entrega!!");
			}
			var store=new dojo.data.ItemFileReadStore({
				data:{
					'identifier':'id',
					'label':'name',
					'items':storeData
				}
			});
			this.delRangeSelection.store=store;
		}

	},
	starttooltips:function(){
		var taxaStr = "<b>Taxa de entrega estimada</b><br>A taxa de entrega pode variar dependendo do valor total do seu pedido.<br>Para trocar o bairro clique no nome do bairro ao lado ou utilize a busca no formulário acima (Onde você está?).";	
		// Add tooltip of his picture
		new dijit.Tooltip({
			connectId: [this.infoSectionDelivery],
			label: taxaStr
		});
		new dijit.Tooltip({
			connectId: [this.infoSectionCity],
			label: taxaStr
		});
		var deliveryTxt = "<b>Sobre prazos de entrega</b><br>"+
		"Pedidos online feitos pelo ComendoBem são geralmente entregues mais rapidamente que pedidos feitos por telefone.<br>Entretanto saiba que " +
		"ele é baseado na melhor estimativa do restaurante. Se o dia é agitado no estabelecimento, como dias chuvosos ou feriados, é comum pedidos exigirem alguns minutos extras (e, claro, é também possível ter o pedido entregue antes).<br />Quando seu pedido é completo o restaurante é imediatamente notificado. " +
		"O momento que o restaurante confirma seu pedido ele fornece estimativas mais precisas que podem ser vistas nos detalhes do pedido. <br>Mas tenha certeza que todo restaurante vai preparar e entregar seu pedido o mais rápido possível";
		new dijit.Tooltip({
			connectId: [this.alertaEntrega],
			label: deliveryTxt
		});
		
	
	}
});

}

if(!dojo._hasResource["com.copacabana.RestaurantWheelWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.RestaurantWheelWidget"] = true;
dojo.provide("com.copacabana.RestaurantWheelWidget");










dojo.declare("com.copacabana.RestaurantWheelWidget", [ dijit._Widget ], {
	i18nString : null,
	title : "",
	url : null,
	//templatePath : ,//dojo.moduleUrl("com.copacabana",		"templates/RestaurantWheel.html"),
	constructor : function() {
	},
	loadedObject:null,
	postMixInProperties : function() {
		this.inherited(arguments);
	},
	imageNode:null,
	statusTextNode:null,
	postCreate : function() {
		this.inherited(arguments);
		this.domNode=dojo.byId('menuRestaurantesCategorias');
		
		this.imageNode =  document.createElement('img');
		this.imageNode.src = dojo.moduleUrl("com.copacabana", "images/smallOrangeGrayLoader.gif");
		this.imageNode.alt="carregando";
		this.imageNode.title="carregando";
		this.statusNode = document.createElement('div');
		this.statusNode .appendChild(this.imageNode);
		dojo.addClass(this.statusNode,'restItem');
		dojo.style(this.statusNode ,'backgroundColor','white');
		this.statusTextNode=document.createTextNode(' Carregando');
		this.statusNode.appendChild(this.statusTextNode);
		this.emptyResultsNode = document.createElement('div');
		
		dojo.addClass(this.emptyResultsNode,'restItem');
		dojo.style(this.emptyResultsNode ,'backgroundColor','white');
		
		this.emptyResultsNode.appendChild(document.createTextNode('Nenhum restaurante'));
		
		
	},
	emptyResultsNode:null,
	addListeners:function(){
		

	    var pMenu;
	    
	        pMenu = new dijit.Menu({
	            targetNodeIds: ["massas"],
	            leftClickToOpen:true,
	            popupDelay:300
	        });
	        
	        pMenu.addChild(new dijit.MenuItem({
	            label: "Teste"
	        }));
	        

	        pMenu.startup();
	    
	},
	updateCache:function(response,cat,cityId){
		if(!this.loadedCatRestListCache[cat.id]){
			this.loadedCatRestListCache[cat.id]=[];
		}
		this.loadedCatRestListCache[cat.id][cityId]=response;
	},
	getFoodCategoryCached:function(cat,cityId){
		if(this.loadedCatRestListCache[cat.id]){
			return this.loadedCatRestListCache[cat.id][cityId]; 
		}
		return undefined;
		
	},
	loadedCatRestListCache:[],
	loadedRestaurants:function(response,cat,cityId){
		this.updateCache(response,cat,cityId);
		
		//var restPane=dojo.query(".restSuggestions", this.domNode)[0];
		
		//this.restSuggestionPane.innerHTML="";
		com.copacabana.util.cleanNode(this.restSuggestionPane);
		
		
		
		
		if(response.length==0){
			dojo.style(this.noResultsPane,"display","block");
			//restPane.innerHTML="Nenhum restaurante encontrado";
			//com.copacabana.util.cleanNode(this.statusNode);
			
			this.restSuggestionPane.appendChild(this.emptyResultsNode);
		}		
		for ( var i = 0; i < response.length; i++) {
			var rest = new com.copacabana.FoodCategoryRestaurantResultWidget({rest:response[i]});
			rest.startup();
			this.restSuggestionPane.appendChild(rest.domNode);
		}
	},
	catBackground:null,
	noResultsPane:null,
	statusNode:null,
	lastCategoryClicked:null,
	showRestaurants:function(cat){
		dojo.style(this.noResultsPane,"display","none");
		
		if(cat.imgUrl){
			dojo.style(this.catBackground,"backgroundImage","url('"+cat.imgUrl+"')");
			dojo.style(this.catBackground,"backgroundRepeat","no repeat");
		}else{
			dojo.style(this.catBackground, "backgroundImage",
			"url('/resources/img/bgMenu/telaVermelha.jpg')");
		}
		this.lastCategoryClicked=cat;
		var cityId = dijit.byId('formularioBusca').getCitySelection();
		dojo.style(this.restSuggestionPane,"display","block");
		if(!this.getFoodCategoryCached(cat.id,cityId)){
				
			com.copacabana.util.cleanNode(this.restSuggestionPane);			
			this.restSuggestionPane.appendChild(this.statusNode);			
			
			var fct=function(response){
				this.loadedRestaurants(response,cat,cityId);
			}
			var xhrArgs = {
					url : "/getRestaurantByFoodCategory.do",
					content: {cityId:cityId,id:cat.id},
					handleAs : "json",
					load : dojo.hitch(this, fct),
					error : function(error) {
						com.copacabana.util.cleanNode(this.restSuggestionPane);
						console.error("cannot load rest by category",error);
					}
				};
			var deferred = dojo.xhrGet(xhrArgs);
		}else{
			this.loadedRestaurants(this.getFoodCategoryCached(cat.id,cityId));
		}
		// /getRestaurantByFoodCategory.do?id=ahByY291dG9jb3BhY2FiYW5hchILEgxGb29kQ2F0ZWdvcnkYCQw
	},	
	loadedCategories:function(data){
		var i;		
		for ( i = 0; i < data.length && i<12; i++) {	
			var fc=data[i];
			if(i%2){
				fc.index=i/2 -0.5;
				fc.type="direita";
			}else{
				fc.index=i/2;
				fc.type="esquerda";
				
			}
			var d = new com.copacabana.RestaurantTypeOptionWidget(fc);
			d.delegateFctToDisplayRestaurants=dojo.hitch(this,this.showRestaurants);//dojo.query(".restSuggestions", this.domNode)[0];
			dojo.byId('menuRestaurantes').appendChild(d.domNode);
			
		}
	},
	onShowRequest:function(id){
		for ( var i = 0; i < this.loadedObject.length; i++) {
			if(this.loadedObject[i].id==id){
				return this.showRestaurants(this.loadedObject[i]);				
			}
		}
		
	},
	restSuggestionPane:null,
	startup : function() {
		try{
			dojo.subscribe('onShowRestSelection',dojo.hitch(this,this.onShowRequest));
			this.restSuggestionPane=dojo.query(".restSuggestions")[0];
			this.catBackground=dojo.query(".categoryBackground")[0];
			this.noResultsPane=dojo.query(".noRestItem")[0];
			dojo.subscribe('onCityChanged',dojo.hitch(this,this.onCityChanged));
			/*if(!this.loadedObject || this.loadedObject==null){
					var xhrArgs = {
						url : "/listMainFoodCategories.do",
						handleAs : "json",
						load : dojo.hitch(this, this.loadedCategories),
						error : function(error) {
							console.error("cannot list main food cats",error);
						}
					};
				var deferred = dojo.xhrGet(xhrArgs);
			}else{
				
				this.loadedCategories(this.loadedObject);
			}*/
		}catch(e){
			console.log('failed to load wheel:'+e.message,e);
			
		}
	},
	onCityChanged:function(evt){
		if(this.lastCategoryClicked && this.lastCategoryClicked.id){
			//reload options
			this.showRestaurants(this.lastCategoryClicked);
		}
	},
	hideRestaurants:function(evt){
		//dojo.style(dojo.query(".restSuggestions", this.domNode)[0],"display","none");
		//dojo.style(dojo.query(".categoryBackground", this.domNode)[0],"backgroundImage","url('/resources/img/bgMenu/fundo.jpg')");
		
	}
});

}

if(!dojo._hasResource["com.copacabana.Cripter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.Cripter"] = true;
dojo.provide("com.copacabana.Cripter");

dojo
		.declare(
				"com.copacabana.Cripter",
				null,
				{
					constructor : function(/* Object */params) {

			},

			// private property
			_keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

			encode : function(input) {
				input=this.encodeBase64(input);
				input=this.MD5(input);
				return input;
			},
			// public method for encoding
			encodeBase64 : function(input) {
				var output = "";
				var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
				var i = 0;

				input = this._utf8_encode(input);

				while (i < input.length) {

					chr1 = input.charCodeAt(i++);
					chr2 = input.charCodeAt(i++);
					chr3 = input.charCodeAt(i++);

					enc1 = chr1 >> 2;
					enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
					enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
					enc4 = chr3 & 63;

					if (isNaN(chr2)) {
						enc3 = enc4 = 64;
					} else if (isNaN(chr3)) {
						enc4 = 64;
					}

					output = output + this._keyStr.charAt(enc1)
							+ this._keyStr.charAt(enc2)
							+ this._keyStr.charAt(enc3)
							+ this._keyStr.charAt(enc4);

				}

				return output;
			},

			// public method for decoding
			decode : function(input) {
				var output = "";
				var chr1, chr2, chr3;
				var enc1, enc2, enc3, enc4;
				var i = 0;

				input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

				while (i < input.length) {

					enc1 = this._keyStr.indexOf(input.charAt(i++));
					enc2 = this._keyStr.indexOf(input.charAt(i++));
					enc3 = this._keyStr.indexOf(input.charAt(i++));
					enc4 = this._keyStr.indexOf(input.charAt(i++));

					chr1 = (enc1 << 2) | (enc2 >> 4);
					chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
					chr3 = ((enc3 & 3) << 6) | enc4;

					output = output + String.fromCharCode(chr1);

					if (enc3 != 64) {
						output = output + String.fromCharCode(chr2);
					}
					if (enc4 != 64) {
						output = output + String.fromCharCode(chr3);
					}

				}

				output = this._utf8_decode(output);

				return output;

			},

			// private method for UTF-8 encoding
			_utf8_encode : function(string) {
				string = string.replace(/\r\n/g, "\n");
				var utftext = "";

				for ( var n = 0; n < string.length; n++) {

					var c = string.charCodeAt(n);

					if (c < 128) {
						utftext += String.fromCharCode(c);
					} else if ((c > 127) && (c < 2048)) {
						utftext += String.fromCharCode((c >> 6) | 192);
						utftext += String.fromCharCode((c & 63) | 128);
					} else {
						utftext += String.fromCharCode((c >> 12) | 224);
						utftext += String
								.fromCharCode(((c >> 6) & 63) | 128);
						utftext += String.fromCharCode((c & 63) | 128);
					}

				}

				return utftext;
			},

			// private method for UTF-8 decoding
			_utf8_decode : function(utftext) {
				var string = "";
				var i = 0;
				var c = c1 = c2 = 0;

				while (i < utftext.length) {

					c = utftext.charCodeAt(i);

					if (c < 128) {
						string += String.fromCharCode(c);
						i++;
					} else if ((c > 191) && (c < 224)) {
						c2 = utftext.charCodeAt(i + 1);
						string += String.fromCharCode(((c & 31) << 6)
								| (c2 & 63));
						i += 2;
					} else {
						c2 = utftext.charCodeAt(i + 1);
						c3 = utftext.charCodeAt(i + 2);
						string += String.fromCharCode(((c & 15) << 12)
								| ((c2 & 63) << 6) | (c3 & 63));
						i += 3;
					}

				}

				return string;
			},
			
			
			MD5:function (string) {
				 
				function RotateLeft(lValue, iShiftBits) {
					return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));
				}
			 
				function AddUnsigned(lX,lY) {
					var lX4,lY4,lX8,lY8,lResult;
					lX8 = (lX & 0x80000000);
					lY8 = (lY & 0x80000000);
					lX4 = (lX & 0x40000000);
					lY4 = (lY & 0x40000000);
					lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);
					if (lX4 & lY4) {
						return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
					}
					if (lX4 | lY4) {
						if (lResult & 0x40000000) {
							return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
						} else {
							return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
						}
					} else {
						return (lResult ^ lX8 ^ lY8);
					}
			 	}
			 
			 	function F(x,y,z) { return (x & y) | ((~x) & z); }
			 	function G(x,y,z) { return (x & z) | (y & (~z)); }
			 	function H(x,y,z) { return (x ^ y ^ z); }
				function I(x,y,z) { return (y ^ (x | (~z))); }
			 
				function FF(a,b,c,d,x,s,ac) {
					a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
					return AddUnsigned(RotateLeft(a, s), b);
				};
			 
				function GG(a,b,c,d,x,s,ac) {
					a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
					return AddUnsigned(RotateLeft(a, s), b);
				};
			 
				function HH(a,b,c,d,x,s,ac) {
					a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
					return AddUnsigned(RotateLeft(a, s), b);
				};
			 
				function II(a,b,c,d,x,s,ac) {
					a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
					return AddUnsigned(RotateLeft(a, s), b);
				};
			 
				function ConvertToWordArray(string) {
					var lWordCount;
					var lMessageLength = string.length;
					var lNumberOfWords_temp1=lMessageLength + 8;
					var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;
					var lNumberOfWords = (lNumberOfWords_temp2+1)*16;
					var lWordArray=Array(lNumberOfWords-1);
					var lBytePosition = 0;
					var lByteCount = 0;
					while ( lByteCount < lMessageLength ) {
						lWordCount = (lByteCount-(lByteCount % 4))/4;
						lBytePosition = (lByteCount % 4)*8;
						lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));
						lByteCount++;
					}
					lWordCount = (lByteCount-(lByteCount % 4))/4;
					lBytePosition = (lByteCount % 4)*8;
					lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);
					lWordArray[lNumberOfWords-2] = lMessageLength<<3;
					lWordArray[lNumberOfWords-1] = lMessageLength>>>29;
					return lWordArray;
				};
			 
				function WordToHex(lValue) {
					var WordToHexValue="",WordToHexValue_temp="",lByte,lCount;
					for (lCount = 0;lCount<=3;lCount++) {
						lByte = (lValue>>>(lCount*8)) & 255;
						WordToHexValue_temp = "0" + lByte.toString(16);
						WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);
					}
					return WordToHexValue;
				};
			 
				function Utf8Encode(string) {
					string = string.replace(/\r\n/g,"\n");
					var utftext = "";
			 
					for (var n = 0; n < string.length; n++) {
			 
						var c = string.charCodeAt(n);
			 
						if (c < 128) {
							utftext += String.fromCharCode(c);
						}
						else if((c > 127) && (c < 2048)) {
							utftext += String.fromCharCode((c >> 6) | 192);
							utftext += String.fromCharCode((c & 63) | 128);
						}
						else {
							utftext += String.fromCharCode((c >> 12) | 224);
							utftext += String.fromCharCode(((c >> 6) & 63) | 128);
							utftext += String.fromCharCode((c & 63) | 128);
						}
			 
					}
			 
					return utftext;
				};
			 
				var x=Array();
				var k,AA,BB,CC,DD,a,b,c,d;
				var S11=7, S12=12, S13=17, S14=22;
				var S21=5, S22=9 , S23=14, S24=20;
				var S31=4, S32=11, S33=16, S34=23;
				var S41=6, S42=10, S43=15, S44=21;
			 
				string = Utf8Encode(string);
			 
				x = ConvertToWordArray(string);
			 
				a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;
			 
				for (k=0;k<x.length;k+=16) {
					AA=a; BB=b; CC=c; DD=d;
					a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);
					d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);
					c=FF(c,d,a,b,x[k+2], S13,0x242070DB);
					b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);
					a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);
					d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);
					c=FF(c,d,a,b,x[k+6], S13,0xA8304613);
					b=FF(b,c,d,a,x[k+7], S14,0xFD469501);
					a=FF(a,b,c,d,x[k+8], S11,0x698098D8);
					d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);
					c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);
					b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);
					a=FF(a,b,c,d,x[k+12],S11,0x6B901122);
					d=FF(d,a,b,c,x[k+13],S12,0xFD987193);
					c=FF(c,d,a,b,x[k+14],S13,0xA679438E);
					b=FF(b,c,d,a,x[k+15],S14,0x49B40821);
					a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);
					d=GG(d,a,b,c,x[k+6], S22,0xC040B340);
					c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);
					b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);
					a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);
					d=GG(d,a,b,c,x[k+10],S22,0x2441453);
					c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);
					b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);
					a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);
					d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);
					c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);
					b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);
					a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);
					d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);
					c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);
					b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);
					a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);
					d=HH(d,a,b,c,x[k+8], S32,0x8771F681);
					c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);
					b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);
					a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);
					d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);
					c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);
					b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);
					a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);
					d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);
					c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);
					b=HH(b,c,d,a,x[k+6], S34,0x4881D05);
					a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);
					d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);
					c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);
					b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);
					a=II(a,b,c,d,x[k+0], S41,0xF4292244);
					d=II(d,a,b,c,x[k+7], S42,0x432AFF97);
					c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);
					b=II(b,c,d,a,x[k+5], S44,0xFC93A039);
					a=II(a,b,c,d,x[k+12],S41,0x655B59C3);
					d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);
					c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);
					b=II(b,c,d,a,x[k+1], S44,0x85845DD1);
					a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);
					d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);
					c=II(c,d,a,b,x[k+6], S43,0xA3014314);
					b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);
					a=II(a,b,c,d,x[k+4], S41,0xF7537E82);
					d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);
					c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);
					b=II(b,c,d,a,x[k+9], S44,0xEB86D391);
					a=AddUnsigned(a,AA);
					b=AddUnsigned(b,BB);
					c=AddUnsigned(c,CC);
					d=AddUnsigned(d,DD);
				}
			 
				var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);
			 
				return temp.toLowerCase();
			}

});

}

if(!dojo._hasResource["dojo.cookie"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cookie"] = true;
dojo.provide("dojo.cookie");



/*=====
dojo.__cookieProps = function(){
	//	expires: Date|String|Number?
	//		If a number, the number of days from today at which the cookie
	//		will expire. If a date, the date past which the cookie will expire.
	//		If expires is in the past, the cookie will be deleted.
	//		If expires is omitted or is 0, the cookie will expire when the browser closes. << FIXME: 0 seems to disappear right away? FF3.
	//	path: String?
	//		The path to use for the cookie.
	//	domain: String?
	//		The domain to use for the cookie.
	//	secure: Boolean?
	//		Whether to only send the cookie on secure connections
	this.expires = expires;
	this.path = path;
	this.domain = domain;
	this.secure = secure;
}
=====*/


dojo.cookie = function(/*String*/name, /*String?*/value, /*dojo.__cookieProps?*/props){
	//	summary: 
	//		Get or set a cookie.
	//	description:
	// 		If one argument is passed, returns the value of the cookie
	// 		For two or more arguments, acts as a setter.
	//	name:
	//		Name of the cookie
	//	value:
	//		Value for the cookie
	//	props: 
	//		Properties for the cookie
	//	example:
	//		set a cookie with the JSON-serialized contents of an object which
	//		will expire 5 days from now:
	//	|	dojo.cookie("configObj", dojo.toJson(config), { expires: 5 });
	//	
	//	example:
	//		de-serialize a cookie back into a JavaScript object:
	//	|	var config = dojo.fromJson(dojo.cookie("configObj"));
	//	
	//	example:
	//		delete a cookie:
	//	|	dojo.cookie("configObj", null, {expires: -1});
	var c = document.cookie;
	if(arguments.length == 1){
		var matches = c.match(new RegExp("(?:^|; )" + dojo.regexp.escapeString(name) + "=([^;]*)"));
		return matches ? decodeURIComponent(matches[1]) : undefined; // String or undefined
	}else{
		props = props || {};
// FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
		var exp = props.expires;
		if(typeof exp == "number"){ 
			var d = new Date();
			d.setTime(d.getTime() + exp*24*60*60*1000);
			exp = props.expires = d;
		}
		if(exp && exp.toUTCString){ props.expires = exp.toUTCString(); }

		value = encodeURIComponent(value);
		var updatedCookie = name + "=" + value, propName;
		for(propName in props){
			updatedCookie += "; " + propName;
			var propValue = props[propName];
			if(propValue !== true){ updatedCookie += "=" + propValue; }
		}
		document.cookie = updatedCookie;
	}
};

dojo.cookie.isSupported = function(){
	//	summary:
	//		Use to determine if the current browser supports cookies or not.
	//		
	//		Returns true if user allows cookies.
	//		Returns false if user doesn't allow cookies.

	if(!("cookieEnabled" in navigator)){
		this("__djCookieTest__", "CookiesAllowed");
		navigator.cookieEnabled = this("__djCookieTest__") == "CookiesAllowed";
		if(navigator.cookieEnabled){
			this("__djCookieTest__", "", {expires: -1});
		}
	}
	return navigator.cookieEnabled;
};

}

if(!dojo._hasResource["com.copacabana.UserProfileWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.UserProfileWidget"] = true;
dojo.provide("com.copacabana.UserProfileWidget");












dojo.declare("com.copacabana.UserProfileWidget", [ dijit._Widget,
		dijit._Templated ],
			{
		i18nString : null,
		title : "",
		url : null,
		templateString:"<div id=\"login\" class=\"quadrado\">\r\n<h2>Conecte-se</h2><br>\r\n<div style=\"text-align: center;\"><a class=\"fb_button fb_button_medium\" target=\"_fbauth\" href=\"/fbresponse.jsp\"  ><span class=\"fb_button_text\">Conectar com Facebook</span></a>\r\n<div style=\"margin-top: 3px;margin-bottom: 3px\">ou</div></div>\r\n<div>\r\n<form dojoType=\"dijit.form.Form\" id=\"loginForm\" action=\"/authenticateNoSSL.do\" method=\"post\" style=\"margin-bottom: 0px\" onsubmit=\"return false;\">\r\n\t<input  type=\"hidden\" class=\"passwordHidden\" name=\"password\" dojoType=\"dijit.form.TextBox\"  />\r\n\t<input  type=\"hidden\" class=\"usernameHidden\" name=\"login\" dojoType=\"dijit.form.TextBox\"  />\r\n\t<input  type=\"hidden\" name=\"isMD5\" value=\"true\" />\r\n</form>\r\n<div\r\n\tstyle=\"margin-left: 1px;margin-bottom: 5px;\" >E-mail:\r\n\t<input type=\"text\" class=\"username mandatory\"  id=\"username\" name=\"login\" selectOnClick=\"true\" dojoType=\"dijit.form.ValidationTextBox\" required=\"true\" style=\"width: 180px;\" /><span class=\"loading\"></span>\r\n\t</div>\r\n<div\r\n\tstyle=\"margin-bottom: 10px\" >Senha: \r\n<input  style=\"width: 115px;\"  type=\"password\" class=\"password mandatory\" selectOnClick=\"true\" id=\"passwordFake\" name=\"passwordfake\" dojoType=\"dijit.form.ValidationTextBox\"  required=\"true\" />\r\n<button baseClass=\"orangeButton loginBtnClass\"  dojoType=\"dijit.form.Button\" dojoAttachEvent=\"onclick:executeLogin\" id=\"loginbtn\"  >Entrar</button>\r\n<br style=\"clear: both;\" clear=\"both\"/>\r\n<span dojoType=\"dijit.form.DropDownButton\" baseClass=\"rememberButton ieRememberBtn\" style=\"margin-left:80px;\">\r\n    <span style=\"font-size: xx-small;\">\r\n        *esqueci minha senha \r\n    </span>\r\n    <div dojoType=\"dijit.TooltipDialog\" id=\"lembrete\" dojoAttachEvent=\"onExecute:executeReminder,onexecute:executeReminder\">\r\n    \t<p>Insira seu e-mail cadastrado e lhe enviaremos sua senha.</p>\r\n        <label for=\"name2\">\r\n            E-mail cadastrado:\r\n        </label>\r\n        <form action=\"/lembreteSenha.do\" method=\"post\" id=\"lembreteForm\" dojoType=\"dijit.form.Form\" onsubmit=\"return false;\">        \r\n        <input dojoType=\"dijit.form.TextBox\" id=\"email\" name=\"email\" type=\"text\"/>\r\n        </form>\r\n        <br>        \r\n        <button dojoType=\"dijit.form.Button\" type=\"submit\" baseClass=\"orangeButton\">\r\n            Enviar senha\r\n        </button>\r\n    </div>\r\n</span> \r\n</div><div class=\"loginMsgs\" style=\"color: red;\">&nbsp;</div>\r\nAinda n&atilde;o tem cadastro?<br/> <a title=\"Cadastre-se no ComendoBem\" href=\"/loginRegistro.do\" style=\"color: rgb(235, 125, 75); font-weight: bold;\">Clique aqui e cadastre-se</a>\r\n\r\n \r\n</div>\r\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" style=\"top:-5px;\">\r\n<tr>\r\n<td style=\"text-align: left;\"> </td>\r\n<td style=\"padding-left: 0px;padding-right: 0px;text-align: left;\">\r\n\r\n</td>\r\n</tr></table>\r\n\r\n</div>\r\n",
		constructor : function() {
		try{
			if(loggedUser){
				this.templateString="<div id=\"login\" class=\"quadrado\">\r\n<h2></h2>\r\n<div class=\"loggedContent\"></div>\r\n</div>\r\n";
			}
			if(undefined != registeringPage && registeringPage===true){
				this.templateString="<div id=\"login\" >\r\n<form dojoType=\"dijit.form.Form\" id=\"loginForm\" action=\"/authenticateNoSSL.do\" method=\"post\" style=\"margin-bottom: 5px;\" onsubmit=\"return false;\">\r\n<input  type=\"hidden\" class=\"passwordHidden\" name=\"password\" dojoType=\"dijit.form.TextBox\"  />\r\n<input  type=\"hidden\" class=\"usernameHidden\" name=\"login\" dojoType=\"dijit.form.TextBox\"  /> \r\n<input  type=\"hidden\" name=\"isMD5\" value=\"true\" />\r\n</form>\r\nE-mail: <input type=\"text\" id=\"username\" class=\"username mandatory\" required=\"true\" name=\"login\" selectOnClick=\"true\" dojoType=\"dijit.form.ValidationTextBox\" style=\"width: 200px;margin-left: 1px;\" /><br />\r\n<div style=\"margin-top: 3px;\">\r\nSenha: <input type=\"password\" id=\"passwordFake\" class=\"password mandatory\" required=\"true\" name=\"passwordfake\" selectOnClick=\"true\" dojoType=\"dijit.form.ValidationTextBox\"  style=\"width: 140px;\" /> \r\n<button dojoType=\"dijit.form.Button\" type=\"button\"  baseClass=\"orangeButton\" id=\"loginbtn\">Enviar</button>\r\n</div>\r\n<div dojoType=\"dijit.form.DropDownButton\"  baseClass=\"rememberButton\" style=\"margin-top: 5px;\">\r\n    <span>\r\n        Esqueci minha senha.\r\n    </span>\r\n    <div dojoType=\"dijit.TooltipDialog\" id=\"lembrete\" dojoAttachEvent=\"onExecute:executeReminder,onexecute:executeReminder\">\r\n    \t<p>Insira seu e-mail cadastrado e lhe enviaremos sua senha.</p>\r\n        <label for=\"name2\">\r\n            E-mail cadastrado:\r\n        </label>\r\n        <form action=\"/lembreteSenha.do\" method=\"post\" id=\"lembreteForm\" dojoType=\"dijit.form.Form\">        \r\n        <input dojoType=\"dijit.form.TextBox\" id=\"email\" name=\"email\" type=\"text\" selectOnClick=\"true\"/>\r\n        </form>\r\n        <br>        \r\n        <button dojoType=\"dijit.form.Button\" type=\"submit\" baseClass=\"orangeButton\">\r\n            Enviar senha\r\n        </button>\r\n    </div>\r\n</div><br/>\r\n<div class=\"loginMsgs\" style=\"color: red;float: right;\"></div>\r\n</div>\r\n";
				this.isRegistering=true;
			}
		}catch(e){}
	},
	isRegistering:false,
	checktoremember:function(evt){
		if (evt.keyCode == dojo.keys.ENTER) {				
			dijit.byId('lembrete').onExecute(evt);
		}
		return false;
	},
	
	checktosubmit:function(evt){
		if (evt) {
			// Stop the submit event since we want to control form submission.
			evt.preventDefault();
			evt.stopPropagation();
			dojo.stopEvent(evt);
		}
		if (evt.keyCode == dojo.keys.ENTER) {				
			this.executeLogin(evt);
		}
		return false;
	
	},
	
	successLogin: function(response) {		
		this.logging=false;

		var panel = dojo.query(".loginMsgs",this.domNode)[0];
		com.copacabana.util.cleanNode(panel);
		
		if(response.status==true){
			panel.innerHTML="Ok! Aguarde...";
			dojo.cookie("lastCBUser",dijit.byId('username').attr('value'), {
	            expires: 30
	        });
			if(this.forwardPage!=null && this.forwardPage!=""){
				window.location=this.forwardPage;
			}else{
				if (response.sessionBean.userType == "restaurant") {
					dojo.publish('onLoggedIn',['Restaurant']);
					window.location = "/restaurantPortal.jsp";
				} else if(response.sessionBean.userType == "central"){
					window.location = "/centralPortal.jsp";
				}else{					
					if(this.isRegistering==true){
						window.location = "/clientPortal.jsp";
					}else{
						dojo.publish('onLoggedIn',['Client',response.sessionBean.entity]);
						dojo.empty(this.domNode);
						if(response.moreInfo.pendingOrders>0 ){
							dojo.create("p",{innerHTML:'Bem vindo '+response.sessionBean.entity.name},this.domNode);
							dojo.create("div",{innerHTML:"Voc&ecirc; possui pedidos em execu&ccedil;&atilde;o."},this.domNode);
							dojo.create("a",{href:"/meusPedidos.do",innerHTML:"Veja aqui"},this.domNode);

						}else{
							//just replace the login template
							
													
							dojo.create("p",{innerHTML:'Bem vindo '+response.sessionBean.entity.name},this.domNode);
							dojo.create("div",{innerHTML:response.moreInfo.cbNews},this.domNode)

						}
					}
				}
			}
		}else{			
			if(response.authStatus=='OAUTH_FB'){
				var res = confirm("Sua conta está associada ao Facebook.\nUtilize o acesso via Facebook.\nVocê deseja definir uma senha para acessar sem sua conta do Facebook?");
				console.log(res);
				if(res=='YES' || res==true){				
					var uname = dijit.byNode(dojo.query(".username",this.domNode)[0]).attr('value');
					uname=dojo.string.trim(uname);				
					var success= function(response) {				
						alert("Um email foi enviado para você com as instruções para gerar sua senha.");
					};
					var err = function(response) {
						alert("Usuário não encontrado. Por favor, verifique seu email cadastrado.");
					}
					
					com.copacabana.util.startPasswordRegen(uname,success,err);
				}
				
			}else{
				if(!response.sessionId || response.sessionId==sessionId){
					panel.innerHTML="Por favor, verifique seu usu&aacute;rio e senha.";
				}else{				
					panel.innerHTML="Sess&atilde;o expirada recarregando...";
					sessionId = response.sessionId;
					this.executeLogin(null);
				}
			}
			
			
		}
	},
	postMixInProperties : function() {
		this.inherited(arguments);
	},
	textNode : null,
	imageNode : null,
	postCreate : function() {
		this.inherited(arguments);
		dojo.parser.parse(this.domNode);
	
	},
	linkNode:null,
	startup : function() {
		
		if(loggedUser){
			var dom = dojo.query(".loggedContent",this.domNode)[0];
			var text = document.createTextNode("Bem vindo "+loggedUser.entity.name);
			dom.appendChild(text);
	
			//this.loadInterestingInfo();
	
		}else{
			dojo.connect(dijit.byId('loginbtn'), "onClick", this, "executeLogin");
			var lembrete = dijit.byId('lembrete');
			dojo.connect(lembrete, "onExecute", this, "executeReminder");
			dojo.connect(dijit.byId('passwordFake'), "onKeyUp", this, "checktosubmit");
			dojo.connect(dijit.byId('username'), "onKeyUp", this, "checktosubmit");
	
			dojo.connect(dijit.byId('email'), "onKeyUp", this, "checktoremember");
	
	
			this.imageNode =  document.createElement('img');
			this.imageNode.src = dojo.moduleUrl("com.copacabana", "images/smallOrangeGrayLoader.gif");
			this.imageNode.alt="autenticando";
			this.imageNode.title="autenticando";
			var cbLogin = dojo.cookie("lastCBUser");
			if(cbLogin && cbLogin!=""){
				dijit.byId('username').attr('value',cbLogin);
			}
		}
	
	
	},
	imageNode:null,
	addInfo:function(response){
		var dom = dojo.query(".loggedContent",this.domNode)[0];
		dom.appendChild(document.createElement("br"));
		var p = document.createElement("p");
		p.appendChild(document.createTextNode("Pedidos recentes:"));
		dom.appendChild(p);
		var ul = document.createElement("ul");
		for ( var i = 0; i < response.latestOrders.length; i++) {
			var order = response.latestOrders[i];
			var li = document.createElement("li");
			li.appendChild(document.createTextNode(order.status+": "+order.orderedTime));
			ul.appendChild(li);
		}				
		dom.appendChild(ul);
	
	},
	loadInterestingInfo:function(){
		var xhrArgs = {
				url: 'retrieveUserNews.do',
				handleAs: "json",
				load : dojo.hitch(this,this.addInfo),
				error: dojo.hitch(this,function(response) {
					console.log(response);
				})
		};
		//
		var deferred = dojo.xhrPost(xhrArgs);
	},
	forwardPage:null,
	logging:false,
	counter:0,
	MAXTRIES:3,
	executeLogin:function(event){
		if (event) {
			// Stop the submit event since we want to control form submission.
			event.preventDefault();
			event.stopPropagation();
			dojo.stopEvent(event);
		}
		if (!com.copacabana.util.checkValidFormAdv(".mandatory",this.domNode)) {
			return false;
		} else {
			var panel = dojo.query(".loginMsgs",this.domNode)[0];
			com.copacabana.util.cleanNode(panel);				
			panel.appendChild(this.imageNode);
			if(this.logging===false){
				this.logging=true;
				//this is not perfect but good
				var pwdDijit = dijit.byNode(dojo.query(".password",this.domNode)[0]);
				var pwd=pwdDijit.attr('value')+"|"+sessionId;
				
				
				dijit.byNode(dojo.query(".passwordHidden",this.domNode)[0]).attr('value',new com.copacabana.Cripter().encode(pwd));
				var uname = dijit.byNode(dojo.query(".username",this.domNode)[0]).attr('value');
				uname=dojo.string.trim(uname);
				dijit.byNode(dojo.query(".username",this.domNode)[0]).attr('value',uname);
				dijit.byNode(dojo.query(".usernameHidden",this.domNode)[0]).attr('value',uname);
				var panel = dojo.query(".loginMsgs",this.domNode)[0];
				var err = function(response){
					panel.innerHTML="Problemas no servidor, por favor tente novamente.";
				}
				com.copacabana.util.executeLogin(uname,pwd,false,null,dojo.hitch(this,this.successLogin),err);
				
			}
			return false;
		}
	
	},
	executeReminder:function(event){
	
		var xhrArgs = {
				form: dojo.byId("lembreteForm"),
				handleAs: "text",
				load : dojo.hitch(this,function(response) {
					var panel = dojo.query(".loginMsgs",this.domNode)[0];
					panel.innerHTML="Um email foi enviado para voc&ecirc; com sua senha.";
				}),
				error: dojo.hitch(this,function(response) {
					console.error('error to execute remider.',response);
					var panel = dojo.query(".loginMsgs",this.domNode)[0];
					panel.innerHTML="Usu&aacute;rio n&atilde;o encontrado. Por favor, verifique seu email cadastrado.";
				})
		};
		//
		var deferred = dojo.xhrPost(xhrArgs);
		return false;
	}
			
});

}

if(!dojo._hasResource["com.copacabana.lbs.FindUserLocation"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.lbs.FindUserLocation"] = true;

dojo.provide("com.copacabana.lbs.FindUserLocation");



dojo.declare(
		"com.copacabana.lbs.FindUserLocation",
		[ dijit._Widget ],
		{
			constructor: function(/*Object*/ params) {

		},

		_initialized: false,

		postMixInProperties: function() {
			try {
				this.inherited(arguments);
			}
			catch (err) { console.error(err); }		
		},
		
		postCreate: function() {
			
		},
		tempSaveCookie:function(key,val){						
			dojo.cookie("FindUserLocation_"+key, dojo.toJson(val), { expires: 1 });
		},
		getCookieVal:function(key){
			var a = dojo.cookie("FindUserLocation_"+key);
			if(a){
				return dojo.fromJson(a);
			}else{
				return null;
			}
		},
		locationError:function(error) {
			switch (error.code) {
			case error.PERMISSION_DENIED:
				console.log("Location not provided");
				break;

			case error.POSITION_UNAVAILABLE:
				console.log("Current location not available");
				break;

			case error.TIMEOUT:
				console.log("Timeout");
				break;

			default:
				console.log("unknown error");
			break;
			}

		},
		dontConvertAddress:false,
		avoidAddressConversion:function(){
			this.dontConvertAddress=true;
		},
		gotLocation:function(location) {
			console.log(location.coords.latitude+","+location.coords.longitude);
			console.log("Accuracy "+location.coords.accuracy+" speed "+location.coords.speed);
			this.geoLocation=
				{
					coords:{
						latitude:location.coords.latitude,
						longitude:location.coords.longitude
					}
				};
			this.tempSaveCookie("geoLoc",this.geoLocation);
			if(this.dontConvertAddress!=true){
				this.getAddresss(location);
			}else{
				
				dojo.publish("onUserLocationCoords",[this.geoLocation]);	
			}
		},		
		geoLocation:null,
		getAddresss:function(location){
			 if(this.locationInfo!=null){
				 dojo.publish("onUserLocation",[this.locationInfo]);
			 }else{
				 var geocoder = new google.maps.Geocoder();

				 var latlng = new google.maps.LatLng(location.coords.latitude, location.coords.longitude);
				 geocoder.geocode({'latLng': latlng}, dojo.hitch(this,this.geocodeReturn));

				 /*

			dojo.require("dojo.io.script");

			 var jsonpArgs = {
					 url: "http://maps.google.com/maps/api/geocode/xml",
			            //callbackParamName: "status",
					    mimetype: "text/plain",
			            content: {
						 sensor:"false",
						 latlng:location.coords.latitude+","+location.coords.longitude			                
			            },
			            load: function(data) {
			                //Set the data from the search into the viewbox in nicely formatted JSON
			              console.log(data);
			            },
			            error: function(error) {
			                console.error(error);
			            }
			        };
			        dojo.io.script.get(jsonpArgs);
				  */

			 }
		},
		locationInfo:null,
		geocodeReturn:function(results, status) {

		      if (status == google.maps.GeocoderStatus.OK) {
		        for ( var j = 0; j < results.length; j++) {
				  if (results[j]) {
				  var item = results[j];
		          console.log(item.formatted_address,item);
		          var comps = item.address_components;
		          var neighbor;
		          var city;
		          var street;
		          var number;
		          var postal_code;
		          var formatted_address;
		          formatted_address=item.formatted_address;
		          for ( var i = 0; i < comps.length; i++) {
		        	 var entry = comps[i];
		        	 if(entry.types[0]=="neighborhood" || entry.types[0]=="sublocality"){
		        		 neighbor=entry;
		        	 }else{
		        		 if(entry.types[0]=="locality"){
		        			 city=entry;
		        		 }
		        		 if(entry.types[0]=="route"){
		        			 street=entry;
		        		 }
		        		 if(entry.types[0]=="street_number"){
		        			number=entry;
		        		 }
		        		 if(entry.types[0]=="postal_code"){
		        			 postal_code=entry;
			        	 }
		        		 if(entry.types[0]=="formatted_address"){
		        			 formatted_address=entry;
			        	 }		        		 
		        	 }
		          }	          
		          
		          if(city )
		          {
		        	  
		        	  console.log("cidade",city);
			          console.log("bairro",neighbor);
			          console.log("rua",street);
			          
			          console.log("number",number);
			          console.log("postal_code",postal_code);
			          var neighName=null;
			          if(neighbor){
			        	  neighName=neighbor.long_name;
			          }
		        	  this.locationInfo={
		        			  city:	city.long_name,
		        			  neighborhood: neighName,
		        			  street: street,
		        			  postal_code:postal_code,
		        			  formatted_address:formatted_address,
		        			  x:this.geoLocation.coords.longitude,
		        			  y:this.geoLocation.coords.latitude
		        	  }
		        	  this.tempSaveCookie("locInfo",this.locationInfo);
			          dojo.publish("onUserLocation",[this.locationInfo]);
		        	  break;
		          }
		         ;
		          
		          
		        } else {
		        	console.log("No results found");
		        }
		        }
		      } else {
		    	  console.log("Geocoder failed due to: " + status);
		      }
		    
		},
		findLocation:function(){
			if(this.locationInfo!=null){
				dojo.publish("onUserLocation",[this.locationInfo]);
			}else{
				if(this.geoLocation!=null){
					this.gotLocation(this.geoLocation);
				}else{
					try {
						if(navigator.geolocation){ 
							navigator.geolocation.getCurrentPosition(dojo.hitch(this,"gotLocation"), dojo.hitch(this,"locationError"));
							//navigator.geolocation.watchPosition(dojo.hitch(this,"showLocation"),  dojo.hitch(this,"locationError"));
						}
					}
					catch (err) {
						console.error(err);
					}
				}
			}
		},
		startup: function() {
			this.inherited(arguments);
			this.location=this.getCookieVal("locInfo");
			this.geoLocation=this.getCookieVal("geoLoc");

			
		},

		shutdown: function() {
			this.inherited(arguments);
		}
		}
);

}

if(!dojo._hasResource["com.copacabana.order.ChangeCreateAddressWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.order.ChangeCreateAddressWidget"] = true;
dojo.provide("com.copacabana.order.ChangeCreateAddressWidget");












// I18N





dojo.declare("com.copacabana.order.ChangeCreateAddressWidget", 
		[ dijit._Widget, dijit._Templated ], {
	i18nStrings : null,
	templateString:"<div style=\"margin: 5px;\">\r\n<form action=\"/addAddressToUser.do\" method=\"post\"\r\n\tdojoType=\"dijit.form.Form\" class=\"updateUserForm\">\t\r\n</form>\r\n<div class=\"eraseTables\">\r\n<div class=\"fundoCinza\">\r\n<h2>Selecione um de seus endere&ccedil;os</h2>\r\n</div>\r\n<table>\r\n\t<tr>\r\n\t\t<td><select dojoType=\"dijit.form.FilteringSelect\"\r\n\t\t\tclass=\"existingSelection\" autoComplete=\"true\"\r\n\t\t\tinvalidMessage=\"Endereco inv&aacute;lido\" selectOnClick=\"true\" \t></select></td>\r\n\t\t<td>\r\n\t\t<div><img src=\"/resources/img/btOk.png\" alt=\"salvar\"\r\n\t\t\tdojoAttachEvent=\"onclick:selectAddress\" /></div>\r\n\t\t</td>\r\n\t</tr>\r\n</table>\r\n<br/>\r\n\r\n<div class=\"fundoCinza\">\r\n<h2>Criar novo Endere&ccedil;o</h2>\r\n</div>\r\n<form action=\"/addAddressToUser.do\" method=\"post\"\r\n\tdojoType=\"dijit.form.Form\" class=\"newAddressForm\">\r\n\r\n<input type=\"hidden\" name=\"address.id\" class=\"addressId\" dojoType=\"dijit.form.TextBox\"/>\r\n<table>\r\n\t<tr>\r\n\t\t<td><label for=\"street\">Endere&ccedil;o:<img alt=\"Sua localiza��o atual\" src=\"/resources/img/locPin.png\" class=\"autoLocImg\" style=\"display: none\"></label></td>\r\n\t\t<td><input dojoType=\"dijit.form.ValidationTextBox\" type=\"text\" required=\"true\" trim=\"true\" properCase=\"true\"\r\n\t\t\tname=\"address.street\" class=\"addressStreet\" width=\"260\" class=\"required\" /></td>\r\n\t\t<td><span class=\"required\">*</span></td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td><label for=\"number\">N&uacute;mero:</label></td>\r\n\t\t<td><input dojoType=\"dijit.form.ValidationTextBox\" type=\"text\" required=\"true\" trim=\"true\"\r\n\t\t\tname=\"address.number\" width=\"70\" class=\"required\" /></td>\r\n\t\t<td width=\"5\"><span class=\"required\">*</span></td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td><label for=\"additionalInfo\">Complemento:</label></td>\r\n\t\t<td><input dojoType=\"dijit.form.ValidationTextBox\" type=\"text\" required=\"false\" trim=\"true\"\r\n\t\t\tname=\"address.additionalInfo\" width=\"70\"  width=\"80\" /></td>\r\n\t\t<td></td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td><label for=\"number\">Telefone:</label></td>\r\n\t\t<td><input dojoType=\"dijit.form.ValidationTextBox\" type=\"text\" required=\"true\" trim=\"true\" regExpGen=\"com.copacabana.util.phoneFormat\" invalidMessage=\"Telefone inv&aacute;lido. Utilize o seguinte formato (DDD) NNNN-NNNN\"\r\n\t\t\tname=\"address.phone\" width=\"70\" class=\"required\" /></td>\r\n\t\t<td width=\"5\"><span class=\"required\">*</span></td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td><label for=\"city\">Cidade:</label></td>\r\n\t\t<td><select dojoType=\"dijit.form.FilteringSelect\" selectOnClick=\"true\"\r\n\t\t\t autoComplete=\"true\"  class=\"citySelection\" dojoAttachPoint=\"citySelection\"\r\n\t\t\tinvalidMessage=\"Cidade inv&aacute;lida\"></select></td>\r\n\t\t<td></td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td><label for=\"neighborhood\">Bairro:</label></td>\r\n\t\t<td><select dojoType=\"dijit.form.FilteringSelect\"\r\n\t\t\tname=\"address.neighborhood\" autoComplete=\"false\" dojoAttachPoint=\"neighbor\" selectOnClick=\"true\" class=\"neighSelection required\" required=\"true\" \r\n\t\t\tinvalidMessage=\"Bairro inv&aacute;lido\"></select></td>\r\n\t\t<td><span class=\"required\">*</span></td>\r\n\t</tr>\t\r\n\t<tr>\r\n\t\t<td></td>\r\n\t\t<td></td>\r\n\t\t<td>\r\n\t\t<div><img src=\"/resources/img/btOk.png\" alt=\"salvar\"\r\n\t\t\tdojoAttachEvent=\"onclick:createAddress\" /></div>\r\n\t\t</td>\r\n\t</tr>\r\n</table>\r\n</form>\r\n\r\n</div>\r\n</div>\r\n",
	constructor : function(data) {
		this.clientId=data.clientId;
		console.log(data.currAddress);
		this.currAddress=data.currAddress;
	},
	currAddress:null,
	destroyRecursive : function() {
		console.log("destroying!");
		//dijit.byNode(dojo.byId("updateUserForm")).destroy(false);
		//this.domNode.removeChild(dojo.byId("updateUserForm"));
		dojo.forEach(this.getDescendants(), function(widget) {
			widget.destroyRecursive(false);
		});
	},
	
	
	postCreate : function() {
		this.inherited(arguments);
		this.i18nStrings=dojo.i18n.getLocalization("com.copacabana.order", "ChangeCreateAddressWidgetStrings");
		dojo.subscribe("onUserLocation",dojo.hitch(this,this.updateDefaultComboValues));
		
	},
	
	geoLocator:null,
	geolocateUserLocation:function(){
		if(this.geoLocator==null){
			this.geoLocator = new com.copacabana.lbs.FindUserLocation();
			this.geoLocator.startup();
		}
		this.geoLocator.findLocation();
	},
	clearOldCList:function(){
		
	},
	
	hideToolTip:function(){
    	dijit.hideTooltip(dojo.query('.autoLocImg',this.domNode)[0]);
    },
	 gotCity:function(items, request){        	
    	//dojo.style(dojo.byId('autoLocImg'),'display','inline');
    	
    	if(items.length==0){
    		return;
    	}
    	this.autolocated=true;

    	var i;
    	for (i = 0; i < items.length; i++) {
    		var item = items[i];
    		this.getCitySelection().attr('value',item.id);                    
    	}
    	console.log('gotCity');
    	//this.onCityUpdate();

    	
    },
	fetchFailed:function(){
		
	},
	getCitySelection:function(){
		return dijit.byNode(dojo.query(".citySelection",this.domNode)[0]);
	},
	updateDefaultComboValues:function(data){
    	try{
    		this.autolocationData=data;
    		if(data.street){
    			var iconLoc = dojo.query('.autoLocImg',this.domNode)[0];
    			dojo.style(iconLoc,'display','inline');
    	    	dijit.showTooltip("Localiza&ccedil;&atilde;o autom&aacute;tica", iconLoc,['before','above']);
    	    	setTimeout(dojo.hitch(this, this.hideToolTip), 2000);
    			
    			dijit.byNode(dojo.query(".addressStreet",this.domNode)[0]).attr('value',data.street.long_name);
    		}
    		var citySelection = this.getCitySelection();
    		
    		citySelection.store.fetch({
    			query: {
    			name: data.city
    		},
    		onBegin: dojo.hitch(this,this.clearOldCList),
    		onComplete: dojo.hitch(this,this.gotCity),
    		onError: dojo.hitch(this,this.fetchFailed), 
    		queryOptions: {
    			deep: true
    		}
    		});
    	}catch(e){
    		console.error("update?",e);
    	}

    },

	startup:function(){
		try{
		dojo.parser.parse(this.domNode);
		//this.loadNeighborhood();
		this.loadCities();
		this.loadAddresses();
		this.geolocateUserLocation();
		console.log(dojo.byId('changeaddressbtn'));
			if(dojo.byId('changeaddressbtn')){
				dijit.hideTooltip(dojo.byId('changeaddressbtn'));
			}
		}catch(e){
			console.error("failed to start changecreateaddress",e);
		}
	},
	clientId:null,
	loadAddresses:function (){
		console.log("loadingC address ", "/listClientAddresses.do?id="+this.clientId)
		var xhrArgs = {
				url : "/listClientAddresses.do?id="+this.clientId,
				handleAs : "json",
				load :dojo.hitch(this,this.renderAddresses),
				error : function(error) {
					console.error("cannot list client addresses",error);
				}
			};
			var deferred = dojo.xhrPost(xhrArgs);	
    },
   
    
    addressesList:[],
    renderAddresses:function(response){
    	console.log("renderAddresses",response);
    	this.addressesList=[];
    	//TODO maybe changing the json that comes from server would be better
    	var arrayItemStore ={'identifier':"id",'label':"street",'items':[]};
    	for ( var i = 0; i < response.length; i++) {
    		arrayItemStore.items.push(
    				{
    					id:response[i].id,
    					street:response[i].street,
    					number:response[i].number,
    					name:response[i].street
    					
    		});    		
    		this.addressesList[response[i].id]=response[i];			
		}
    	var args={data:arrayItemStore};
    	var stateStore = new dojo.data.ItemFileReadStore(args);
    	var existingFilterSelection = dijit.byNode(dojo.query(".existingSelection",this.domNode)[0]);
    	
    	existingFilterSelection.store = stateStore;    	
    	existingFilterSelection.store.fetch({onComplete: dojo.hitch(this,this.completeFecth), onError: dojo.hitch(this,this.completeFecth)});
    },
    completeFecth:function(items, findResult){
    	if(this.currAddress){
    		dijit.byNode(dojo.query(".existingSelection",this.domNode)[0]).attr("value",this.currAddress.id);
    	}
    	

    },
	loadNeighborhood:function (){
    	var stateStore = new dojo.data.ItemFileReadStore({
            url: "/listNeighborsItemFileReadStore.do"
        });
    	var nSelection = dijit.byNode(dojo.query(".neighSelection",this.domNode)[0]);
    	nSelection.store.reset();
    	nSelection.store.queryExpr="*${0}*";    	
    	nSelection.store = stateStore;
    	
    	
        
    },
    loadCities:function(){
    	var stateStore = new dojo.data.ItemFileReadStore({
            url: "/listCitiesItemFileReadStore.do"
        });
        
        dijit.byNode(dojo.query(".citySelection",this.domNode)[0]).store = stateStore;
        dojo.connect(dijit.byNode(dojo.query(".citySelection",this.domNode)[0]), "onChange", dojo.hitch(this,this.onCityUpdate));
    },
    autolocated:false,
    onCityUpdate:function(){        
        try{   
	    	var stateStore = new dojo.data.ItemFileReadStore({
	            url: "/listNeighborsByCity.do?key="+dijit.byNode(dojo.query(".citySelection",this.domNode)[0]).attr("value")
	        });
	    	
	    	this.getNeighSelection().reset();	    	
	    	this.getNeighSelection().queryExpr="*${0}*";
	    	this.getNeighSelection().store = stateStore;
	    	if(this.autolocated==true){
	    		if(this.autolocationData.neighborhood){
	        		this.changeNeighborhood(this.autolocationData);
	        	}
	    	}
        }catch(e){
			console.error(e);
        }
    },
    changeNeighborhood:function(locationData){
    	this.getNeighSelection().store.fetch({
            query: {
                name: locationData.neighborhood
            },
            onBegin: dojo.hitch(this,this.clearOldCList),
            onComplete: dojo.hitch(this,this.gotAutoNeighbor),
            onError: dojo.hitch(this,this.fetchNeigFailed), 
            queryOptions: {
                deep: true
            }
        });
    },
    fetchNeigFailed:function(error){
    	console.error('failed to set the neighborhood',error);
    },
    gotAutoNeighbor:function(items){
    	    
        var i;
    	if(items.length>0){    		
            for (i = 0; i < items.length; i++) {
                var item = items[i];
                this.getNeighSelection().attr('value',item.id);
                
            }
    	}
    },
    getNeighSelection:function(){
    	return dijit.byNode(dojo.query(".neighSelection",this.domNode)[0]);
    },
    selectAddress:function(evt){
    	console.log("selectAddress:"+dijit.byNode(dojo.query(".existingSelection",this.domNode)[0]).attr("value"));
    	var selectedId=dijit.byNode(dojo.query(".existingSelection",this.domNode)[0]).attr("value");
    	this.selectedAddress=this.addressesList[selectedId];
    	dojo.publish("onAddressSelected",[this.selectedAddress]);    	
    	this.destroyRecursive();
    },
    
    createAddress:function(evt){
    	if (!com.copacabana.util.checkValidForm('.required',this.domNode)) {
    		return;
    	}
    	
    	com.copacabana.util.showLoading();
    	var xhrArgs = {
			form : dojo.query(".newAddressForm",this.domNode)[0],
			handleAs : "json",
			load : dojo.hitch(this,function(data) {
				
				com.copacabana.util.hideLoading();
				var entity = data;
				entity.neighborhood.city={
						id:dijit.byNode(dojo.query(".citySelection",this.domNode)[0]).attr('value')						
				}				
				dojo.publish("onAddressSelected",[data]);
				this.destroyRecursive();
			}),
			error : function(error) {
    			
    			console.log("Form error ", error);
    			com.copacabana.util.hideLoading();
			}
		};
		//Call the asynchronous xhrPost
    	
    	var deferred = dojo.xhrPost(xhrArgs);
    	
    },
    
    addressIdNode:null,
    userNode:null,
    selectedAddress:null,
    
    
    updateUser:function(data){
    	var form=dojo.query(".updateUserForm", this.domNode)[0];//dojo.byId("updateUserForm")
    	if(this.userNode!=null){
    		form.removeChild(this.userNode);     		
    	}
    	if(this.addressIdNode!=null){
    		form.removeChild(this.addressIdNode);     		
    	}
    	
    	this.userNode = document.createElement("input");
    	this.userNode.setAttribute("name","id");
    	this.userNode.setAttribute("value",this.clientId);
    	this.userNode.setAttribute("type","hidden");
    	form.appendChild(this.userNode);
    	 this.addressIdNode = document.createElement("input");
    	 this.addressIdNode.setAttribute("name","addresses[0].k");
    	 this.addressIdNode.setAttribute("value",data.id);
    	 this.addressIdNode.setAttribute("type","hidden");
    	 form.appendChild(this.addressIdNode);
     	this.selectedAddress=data;
     	
    	var xhrArgs = {
    			form : form,
    			handleAs : "json",
    			load : dojo.hitch(this,function(data) {
    				var entity = data;   				    				
    				
    				dojo.publish("onAddressSelected",[this.selectedAddress]);
    				
    				
    			}),
    			error : function(error) {
    				//We'll 404 in the demo, but that's okay.  We don't have a 'postIt' service on the
    			//docs server.
    			console.log("Form error ", error);
    			}
    		};
    		//Call the asynchronous xhrPost
        	console.log("sending");
        	var deferred = dojo.xhrPost(xhrArgs);
    }
    
});

}

if(!dojo._hasResource["com.copacabana.order.ChangeDeliveryAddressWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.order.ChangeDeliveryAddressWidget"] = true;
dojo.provide("com.copacabana.order.ChangeDeliveryAddressWidget");











// I18N






dojo.declare("com.copacabana.order.ChangeDeliveryAddressWidget", 
		[ dijit._Widget, dijit._Templated ], {
	i18nStrings : null,
	templateString:"<div>\r\n<span class=\"endereco\" style=\"color:#E87919\"></span>\r\n<span class=\"enderecoError\" ></span>\r\n</div>\r\n",
	constructor : function(data) {
		dojo.mixin(this,data);
		this.clientId = data.clientId;
		this.restId = data.restId;
		this.clientAddress=data.clientAddress;		
		this.selectedAddress=data.selectedAddress;
		this.isDeliverable=false;
		console.log("is",this.deliveryRange)
		console.log("is",data)
		this.id="deliveryManager";		
	},
	destroyRecursive : function() {		
		dojo.forEach(this.getDescendants(), function(widget) {			
			widget.destroyRecursive();
		});
	},
	clientAddress:null,
	selectedAddress:null,
	restId : null,
	postCreate : function() {
		this.inherited(arguments);
		this.i18nStrings= dojo.i18n.getLocalization("com.copacabana.order", "ChangeDeliveryAddressWidgetStrings");
		console.log("if restaddress is null it will get loaded",this.restaurantAddress);
		if(this.restaurantAddress==null){			
			this.loadRestAddress();
		}
		
	},
	deliveryRange:null,
	isDeliverable:false,
	loadDeliveryRange:function(data) {
		
		var entity = dojo.fromJson(data);
		
		this.deliveryRange=entity;		
		console.log("selected",this.selectedAddress);
		this.checkIfAddressInRange(this.selectedAddress);
		
		
		this.updateAddressPanel(this.selectedAddress,this.clientAddress);
		
	},
	
	loadRestAddress:function (){
		console.log('Loading restaurant Address');
		if(this.restaurantAddress==null){
    	var xhrArgs = {				
				url : "/loadAddress.do?id="+this.restaurantAddressKey,
				handleAs : "json",
				load:dojo.hitch(this,this.setRestaurantAddress),
				error : function(error) {
					console.warn("cannot list restaurnt addresses",error);
				}
			};
			var deferred = dojo.xhrPost(xhrArgs);
		}
    },
    setRestaurantAddress:function(address){
    	console.log('restAdd',address);
    	this.restaurantAddress=address;
    },
	updateAddressPanel:function(selectedAddress,clientAddress){
		
		var panel = dojo.query(".endereco", this.domNode)[0];
		panel.innerHTML="";
		com.copacabana.util.cleanNode(panel);		
		
		var errorPanel = dojo.query(".enderecoError", this.domNode)[0];
		com.copacabana.util.cleanNode(errorPanel);	
		if(selectedAddress==null && clientAddress==null){
			errorPanel.appendChild(document.createElement("br"));
			var bold = document.createElement("b");
			dojo.style(bold,'color','red');
			bold.innerHTML=this.i18nStrings.noAddressSelected;
			errorPanel.appendChild(bold);dojo.style(panel, "textDecoration" ,"line-through" );			
			dijit.showTooltip(this.i18nStrings.createAddress, dojo.byId('changeaddressbtn'));
			console.log("ASAAAAAA2")
			return;
		}else{
			console.log("ASAAAAAA3")
			dijit.hideTooltip(dojo.byId('changeaddressbtn'));	
		}
		
		var address=clientAddress;
		if(address==null){
			address=selectedAddress;
		}
		var formatedAddress=address.street+", "+address.number+".";
		if(address.additionalInfo && address.additionalInfo!=""){
			formatedAddress+=" "+address.additionalInfo+".";		
		}
		if(address.phone && address.phone!=""){
			formatedAddress+="Tel:"+address.phone;
		}else{
			
		}
		if(this.isDeliverable==false){
			dojo.create('br',null,errorPanel);
			dojo.create('b',{style:{color:'red'},innerHTML:this.i18nStrings.notInDeliveryRange},errorPanel);
			
			dojo.style(panel, "textDecoration" ,"line-through" );
			dijit.showTooltip(this.i18nStrings.mustSelectAnotherAddress, dojo.byId('changeaddressbtn'));
		}else{
			errorPanel.innerHTML="";
			dojo.style(panel, "textDecoration" ,"none" );
		}
		if(selectedAddress.isRetrieveAtRestaurant==true){
			var labelPlace = dojo.byId('deliveryLabel');
			dojo.empty(labelPlace);
			dojo.create('span',{style:{color:'black'},innerHTML:this.i18nStrings.deliveryLabelToRetrieve},labelPlace);
			
			
		}else{		
			var labelPlace = dojo.byId('deliveryLabel');
			dojo.empty(labelPlace);
			dojo.create('span',{style:{color:'black'},innerHTML:this.i18nStrings.deliveryLabel},labelPlace);
			
		}
		panel.appendChild(document.createTextNode(formatedAddress));
		
				
	},
	onlyForRetrieval:false,
	startup : function() {
		try {
			
			dojo.parser.parse(this.domNode);
			
			dojo.subscribe("onChangeAddressRequest",dojo.hitch(this,this.onChangeAddressRequest));
			dojo.subscribe("onAddressSelected",dojo.hitch(this,this.onAddressSelected));
			dojo.subscribe("onRetrieveInRestaurant",dojo.hitch(this,this.onRetrieveInRestaurant));
			if(this.onlyForRetrieval==true){
				this.onRetrieveInRestaurant([]);				
			} else {
				this.isDeliverable = false;
				
				
				
				if (this.selectedAddress == undefined
						|| this.selectedAddress == null) {
					this.selectedAddress = this.clientAddress;
					if (this.selectedAddress == null
							|| this.selectedAddress == '') {
						try {
							this.selectedAddress = dojo
							.fromJson(dojo
									.cookie("lastDeliveryAddress"));

						} catch (e) {
							console
							.warn(
									'failed to load address cookie;',
									e);
						}
					}
				}
				if(this.deliveryRange==null){
				var url = "/listDeliveryRangeForRestaurant.do?key="	+ this.restId;
				var xhrArgs = {
						url : url,
						handleAs : "text",
						load : dojo.hitch(this, this.loadDeliveryRange),
						error : function(error) {
								console
								.error("Failed to load delivery Range ",error);
							}
				};
				var deferred = dojo.xhrPost(xhrArgs);
				}
			}
			
		} catch (e) {
			console.error("Error to load delivery Range ",error);
		}
	},
	changeAddressWidget:null,
	dialog:null,
	onChangeAddressRequest:function(data){		
		this.changeAddressWidget= new com.copacabana.order.ChangeCreateAddressWidget({clientId:this.clientId,currAddress:this.selectedAddress});
		this.changeAddressWidget.startup();
		var options ={
			closable:true,
			title : this.i18nStrings.changeDeliveryAddress,
			style : 'border:1px solid black;',
			content:this.changeAddressWidget.domNode
		}
		
		this.dialog = new dijit.Dialog(options);		
		dojo.style(this.dialog.containerNode, 'zIndex', '99'); 

		this.dialog.show();
	},
	renderAddresses:function(response,dialog){
		// Limpa o Dialog
		dialog.containerNode.innerHTML = '';		
		dojo.forEach(response.items, function(endereco) {
			if (endereco.id != enderecoEntrega.id) {
				dojo.place("endereco1",	dialog.containerNode);
			}
		});
	},
	checkIfAddressInRange:function(){
		try{
			this.isDeliverable=false;
			if(this.selectedAddress==null){
				this.isDeliverable=false;
				return;
			}
			//this is extremely ugly
			var sN =this.selectedAddress.neighborhood.id;
			if(!sN){
				sN=this.selectedAddress.neighborhood;
			}
			console.log("Selected city",this.selectedAddress.neighborhood.city)
			for ( var i = 0; i < this.deliveryRange.length; i++) {	
				if(this.deliveryRange[i].neighborhood){
					var n = this.deliveryRange[i].neighborhood.id;

					if(!n){
						n=this.deliveryRange[i].neighborhood;
					}
					if(n==sN){
						this.updateDeliverableInfo(this.deliveryRange[i].deliveryRange);
						break;
					}else{
						this.isDeliverable=false;
					}			
				}
			}
			// entire city logic
			if(this.isDeliverable===false){
				for ( var i = 0; i < this.deliveryRange.length; i++) {
					if(this.deliveryRange[i].neighborhood==null){
						console.log(this.deliveryRange[i].city.id);
						console.log("selectedAddress",this.selectedAddress);
						console.log("selectedAddress.neighborhood",this.selectedAddress.neighborhood);
						console.log("deliveryRange[i].city",this.deliveryRange[i].city)
						if(this.selectedAddress.neighborhood.city.id==this.deliveryRange[i].city.id){
							this.updateDeliverableInfo(this.deliveryRange[i].deliveryRange);
							break;
						}						
					}
				}
			}
		}catch(e){
			this.isDeliverable=false;
			console.error("N�o foi possivel determinar endere�o de entrega!");
			console.error(e.message);
			
		}
		try{
			if(this.isDeliverable==false){
				this.registerOutOfRange();
			}
		}catch(e){
			
		}
	},
	registerOutOfRange:function(){
		try{
			var nId="";
			if(this.selectedAddress && this.selectedAddress.neighborhood){
				if(this.selectedAddress.neighborhood.id){
					nId="nid="+this.selectedAddress.neighborhood.id;
				}else{
					nId="nid="+this.selectedAddress.neighborhood;
				}
			}
				
			console.log("selectedAddress",this.selectedAddress.neighborhood);
			console.log("order",order);			
			
			var xhrParams = {
					error :function(error){},					
					load : function(data){},
					preventCache:true,
					failOk:true,
					url : '/notInRange.jsp?restid='+order.restaurant+"&"+nId
			};
			dojo.xhrGet(xhrParams);	
		}catch(e){
			
		}
	},
	onAddressSelected:function(data){
		this.selectedAddress=data;
		this.selectedAddress.isRetrieveAtRestaurant=false;
		this.checkIfAddressInRange(data);
		this.updateAddressPanel(data);		
		try{
			this.dialog.hide();
			this.dialog.destroyRecursive(false);
		}catch(e){
			console.log('dialog',e);	
		}
		this.changeAddressWidget.destroyRecursive();

	},
	onRetrieveInRestaurant:function(data){
		this.isDeliverable=true;
		this.selectedAddress=this.restaurantAddress;
		this.selectedAddress.isRetrieveAtRestaurant=true;
		this.customDeliveryCostFct(this.selectedAddress,true);
		dojo.publish("onDeliveryCostChange",[0,0]);
		dojo.publish("onDeliveryMinimumCostChange",[0,0]);
		
		dojo.cookie("lastDeliveryAddress", '', {
            expires: 100
        });
		
		this.updateAddressPanel(this.selectedAddress);
		if(this.changeAddressWidget){
			try{
			this.changeAddressWidget.destroyRecursive();
			}catch (e) {

			}
		}
		
	},
	customDeliveryCostFct:function(deliveryInfo,takeaway){
		
	},
	updateDeliverableInfo:function(deliveryRange){

		this.isDeliverable=true;
		this.customDeliveryCostFct(deliveryRange);
		var selectedDelRange = deliveryRange;
		if (selectedDelRange.cost) {
			dojo.publish("onDeliveryCostChange",[selectedDelRange.cost,selectedDelRange.costInCents]);
		}
		if (selectedDelRange.minimumOrderValue) {
			dojo.publish("onDeliveryMinimumCostChange",[selectedDelRange.minimumOrderValue,selectedDelRange.minimumOrderValueInCents]);
		}

		dojo.cookie("lastDeliveryAddress", dojo.toJson(this.selectedAddress), {
			expires: 30
		});



	}

});

}

if(!dojo._hasResource["com.copacabana.order.OrderEntryWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.order.OrderEntryWidget"] = true;
dojo.provide("com.copacabana.order.OrderEntryWidget");










//I18N


 


dojo.declare("com.copacabana.order.OrderEntryWidget", [
		dijit._Widget, dijit._Templated ], {
	i18nStrings: null,
	templateString:"<tr class=\"item\">\r\n\t<td class=\"colunaItem\"><span>${orderedPlate.name}</span></td>\r\n\t<td>${orderedPlate.priceFormatted} </td>\r\n\t<td><span dojoAttachEvent=\"onclick:decrease\" style=\"cursor: pointer;\">- </span> <input dojoType=\"dijit.form.TextBox\" style=\"width:15px;\" width=\"25\" value=\"${qty}\" readonly=\"readonly\" type=\"text\" class=\"quantidadeValue\">\r\n\t<span dojoAttachEvent=\"onclick:increase\" style=\"cursor: pointer;\"> +</span></td>\r\n\t<td><span class=\"totalCost\">0,00</span></td>\r\n</tr>\r\n",
	constructor : function(plate,qty) {
		this.plate=plate;
		this.orderedPlate=plate;
		this.orderedPlate.priceFormatted=com.copacabana.util.moneyFormatter(this.orderedPlate.price);
		console.log(this.plate.name);
		console.log("k"+this.plate.k);
		this.qty=qty;
	},
	destroyRecursive: function(){
        dojo.forEach(this.getDescendants(), function(widget){
         
        	widget.destroyRecursive();
        });
        this.inherited(arguments);
    },
    orderedPlate:null,
    plate:null,
    qty:0,
    isReadonly:false,
	postMixInProperties : function() {
		this.inherited(arguments);
	},

	postCreate : function() {
		this.inherited(arguments);
		this.i18nStrings=dojo.i18n.getLocalization("com.copacabana.order", "OrderEntryWidgetStrings");
	},
	
	
	startup : function() {
		try {
			dojo.parser.parse(this.domNode);
			dojo.query(".totalCost", this.domNode)[0].innerHTML=com.copacabana.util.moneyFormatter(this.getTotalCost());			
		} catch (e) {
			console.error(e);
		}
	},
	increase:function(){
		if(this.isReadonly==false){
			var qtyNode = dijit.byNode(dojo.query(".quantidadeValue", this.domNode)[0]);
			qtyNode.attr("value",parseFloat(qtyNode.attr("value"))+1);
			this.qty=qtyNode.attr("value");
			dojo.query(".totalCost", this.domNode)[0].innerHTML=com.copacabana.util.moneyFormatter(this.getTotalCost());;
			dojo.publish("onQuantityChanged");			
		}else{
			this.showReadOnlyMsg();
		}
		
	},
	getTotalCost:function(){
		return parseFloat(this.qty*this.orderedPlate.price);
	},
	decrease:function(){
		if(this.isReadonly==false){
			var qtyNode = dijit.byNode(dojo.query(".quantidadeValue", this.domNode)[0]);
			if(parseFloat(qtyNode.attr("value"))>0){
				qtyNode.attr("value",parseFloat(qtyNode.attr("value"))-1);
				this.qty=parseFloat(qtyNode.attr("value"));
			}		
			dojo.query(".totalCost", this.domNode)[0].innerHTML=com.copacabana.util.moneyFormatter(this.getTotalCost());
			dojo.publish("onQuantityChanged");
		}else{
			this.showReadOnlyMsg();
		}
	},
	readOnlyMsg:"Este item &eacute; obrigat&oacute;rio.",
	showReadOnlyMsg:function(){
	var node = dojo.query(".quantidadeValue", this.domNode)[0];
	com.copacabana.util.showTimedMessage(this.readOnlyMsg,node,5000);
	}
	

});

}

if(!dojo._hasResource["com.copacabana.order.OrderManagerWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.order.OrderManagerWidget"] = true;
dojo.provide("com.copacabana.order.OrderManagerWidget");














// I18N





dojo.declare("com.copacabana.order.OrderManagerWidget", [ dijit._Widget,
		dijit._Templated ], {
	i18nStrings : null,
	templateString:"<div>\r\n\r\n<div class=\"fundoCinza\">\r\n<h2>Pedido: <span class=\"restPlace\"></span></h2>\r\n\r\n</div>\r\n<div class=\"orderRequestList\">\r\n<table id=\"itensPedido\" >\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th class=\"colunaItem\">Item</th>\r\n\t\t\t<th>Pre&ccedil;o Unit&aacute;rio</th>\r\n\t\t\t<th>Quantidade</th>\r\n\t\t\t<th>Valor Total</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody class=\"plateMenuList\">\r\n\t\t\r\n\t</tbody>\r\n</table>\r\n\r\n</div>\r\n<div id=\"finalPedido\"><div id=\"totalizadores\">\r\nSubtotal: <span class=\"subtotal\">0,00</span><br>\r\nTaxa de Entrega: <span class=\"delCost\">0,00</span><br>\r\n<div dojoAttachEvent=\"onclick:showDiscountSection\" dojoAttachPoint=\"discBtn\" class=\"discBtn\">Possui cupom de desconto?</div><div class=\"discBtn discSection\"  dojoAttachPoint=\"discDesc\"></div>\r\n</div>\r\n\r\n<div id=\"totalWrapper\">Total: <span id=\"total\" class=\"totalOrderCost\">0,00</span></div>\r\n\r\n</div>\r\n\r\n\r\n<div class=\"fundoCinza\">\r\n<h2>Forma de Pagamento</h2>\r\n</div>\r\n<div style=\"margin: 5px;\">\r\n<p id=\"formasDePagamento\"></p>\r\n<div class=\"paymentType_PAYPAL\" style=\"display:none;\">\r\n<input type=\"radio\" name=\"payment\" id=\"PayPal\" value=\"PAYPAL\"  class=\"PAYPAL paymentType\" dojoType=\"dijit.form.RadioButton\"/>\r\n <label for=\"PAYPAL\" style=\"font-weight: bold;\">Online Via PayPal</label><img src=\"/scripts/com/copacabana/images/cards.gif\"/><br/>\r\n</div><div dojoAttachPoint=\"clientLevelTxt\" style=\"font-weight: bold;\"></div>\r\n<div class=\"paymentType_CHEQUE\" style=\"display:none;\">\r\n<input type=\"radio\" name=\"payment\" id=\"Cheque\" value=\"CHEQUE\"  class=\"CHEQUE paymentType\" dojoType=\"dijit.form.RadioButton\"/>\r\n <label for=\"Cheque\">Cheque</label><br/>\r\n</div>\r\n<div class=\"paymentType_INCASH\" style=\"display: none;\">\r\n<input type=\"radio\" name=\"payment\" id=\"InCash\"  value=\"INCASH\"   class=\"INCASH paymentType\"  dojoType=\"dijit.form.RadioButton\"/>\r\n<label for=\"InCash\">Dinheiro</label>\r\n<span class=\"formaPagamento\" >Troco para: R$ <input style=\"width: 70px;\" type=\"text\"  name=\"totalPaidAmount\"  class=\"totalPaidAmount\" dojoType=\"dijit.form.CurrencyTextBox\" constraints=\"{fractional:true,required:true}\" invalidMessage=\"Digite o valor com centavos, por exemplo 10,90\" value=\"0,00\" selectOnClick=\"true\" ></input><br />\r\n<span class=\"changeMoneyReturn\"></span>\r\n</span> \r\n</div>\r\n\r\n<div class=\"paymentType_VISAMACHINE\" style=\"display:none;\">\r\n<input type=\"radio\" name=\"payment\" id=\"VISAMACHINE\" value=\"VISAMACHINE\"  class=\"VISAMACHINE paymentType\" dojoType=\"dijit.form.RadioButton\"/>\r\n <label for=\"VISAMACHINE\">Visa Cr&eacute;dito</label><br/>\r\n</div>\r\n<div class=\"paymentType_VISADEBITMACHINE\" style=\"display:none;\">\r\n<input type=\"radio\" name=\"payment\" id=\"VISADEBITMACHINE\" value=\"VISADEBITMACHINE\"  class=\"VISADEBITMACHINE paymentType\" dojoType=\"dijit.form.RadioButton\"/>\r\n <label for=\"VISADEBITMACHINE\">Visa Electron</label><br/>\r\n</div>\r\n<div class=\"paymentType_VISAVOUCHERMACHINE\" style=\"display:none;\">\r\n<input type=\"radio\" name=\"payment\" id=\"VISAVOUCHERMACHINE\" value=\"VISAVOUCHERMACHINE\"  class=\"VISAVOUCHERMACHINE paymentType\" dojoType=\"dijit.form.RadioButton\"/>\r\n <label for=\"VISAVOUCHERMACHINE\">Visa Vale</label><br/>\r\n</div>\r\n\r\n<div class=\"paymentType_MASTERMACHINE\" style=\"display:none;\">\r\n<input type=\"radio\" name=\"payment\" id=\"MASTERMACHINE\" value=\"MASTERMACHINE\"  class=\"MASTERMACHINE paymentType\" dojoType=\"dijit.form.RadioButton\"/>\r\n <label for=\"MASTERMACHINE\">MasterCard Cr&eacute;dito</label><br/>\r\n</div>\r\n<div class=\"paymentType_MASTERDEBITMACHINE\" style=\"display:none;\">\r\n<input type=\"radio\" name=\"payment\" id=\"MASTERDEBITMACHINE\" value=\"MASTERDEBITMACHINE\"  class=\"MASTERDEBITMACHINE paymentType\" dojoType=\"dijit.form.RadioButton\"/>\r\n <label for=\"MASTERDEBITMACHINE\">Redeshop/Maestro</label><br/>\r\n</div>\r\n\r\n<div class=\"paymentType_AMEXMACHINE\" style=\"display:none;\">\r\n<input type=\"radio\" name=\"payment\" id=\"AMEXMACHINE\" value=\"AMEXMACHINE\"  class=\"AMEXMACHINE paymentType\" dojoType=\"dijit.form.RadioButton\"/>\r\n <label for=\"AMEXMACHINE\">M&aacute;quina American Express</label><br/>\r\n</div>\r\n<div class=\"paymentType_TRMACHINE\" style=\"display:none;\">\r\n<input type=\"radio\" name=\"payment\" id=\"TRMACHINE\" value=\"TRMACHINE\"  class=\"TRMACHINE paymentType\" dojoType=\"dijit.form.RadioButton\"/>\r\n <label for=\"TRMACHINE\">M&aacute;quina TR</label><br/>\r\n</div>\r\n<div class=\"paymentType_TRVOUCHER\" style=\"display:none;\">\r\n<input type=\"radio\" name=\"payment\" id=\"TRVOUCHER\" value=\"TRVOUCHER\"  class=\"TRVOUCHER paymentType\" dojoType=\"dijit.form.RadioButton\"/>\r\n <label for=\"TRMACHINE\">Vale TR papel</label><br/>\r\n</div>\r\n<div class=\"paymentType_VRSMART\" style=\"display:none;\">\r\n<input type=\"radio\" name=\"payment\" id=\"VRSMART\" value=\"VRSMART\"  class=\"VRSMART paymentType\" dojoType=\"dijit.form.RadioButton\"/>\r\n <label for=\"VRSMART\">VR Smart</label><br/>\r\n</div>\r\n<div class=\"paymentType_TRSODEXHO\" style=\"display:none;\">\r\n<input type=\"radio\" name=\"payment\" id=\"TRSODEXHO\" value=\"TRSODEXHO\"  class=\"TRSODEXHO paymentType\" dojoType=\"dijit.form.RadioButton\"/>\r\n <label for=\"TRSODEXHO\">Ticket Sodexo</label><br/>\r\n</div>\r\n\r\n\r\n</div>\r\n\r\n<div class=\"fundoCinza\">\r\n<h2>Observa&ccedil;&otilde;es</h2>\r\n</div>\r\n<div style=\"margin: 5px;\">\r\n<input id=\"useCpf\" value=\"YES\" dojoType=\"dijit.form.CheckBox\" dojoAttachEvent=\"onchange:useCPFChanged\" value=\"false\" /><label for=\"useCpf\">Utilizar CPF na nota fiscal?</label> <span class=\"cpfField\" style=\"visibility: hidden;\" > CPF: <input style=\"width: 100px;\" type=\"text\" name=\"cpf\" class=\"cpf\" id=\"cpf\" dojoType=\"dijit.form.TextBox\" selectOnClick=\"true\"></input></span> \r\n<br/><br/>\r\nInforma&ccedil;&otilde;es adicionais sobre o pedido:\r\n<div style=\"margin: 5px;\"><textarea dojoType=\"dijit.form.SimpleTextarea\" cols=\"30\" rows=\"4\" class=\"observationArea\"  name=\"observation\"></textarea></div><br/>\r\n</div>\r\n\r\n<div id=\"barraEmbaixo\" class=\"fundoCinza barraSalvar\" ><a\r\n\t\tid=\"submitButton\"> <img\r\n\t\tsrc=\"/resources/img/btFinalizar.png\" alt=\"Finalizar e enviar pedido\" dojoAttachEvent=\"onclick:submitOrder\" style=\"cursor: pointer;\"/> </a></div>\r\n\r\n</div>\r\n",
	constructor : function(order) {
		this.order = order;
		
	},
	destroyRecursive : function() {		
		dojo.forEach(this.getDescendants(), function(widget) {			
			widget.destroyRecursive();
		});
		this.inherited(arguments);
	},
	order : null,

	postMixInProperties : function() {
		this.inherited(arguments);
	},
	deliveryCostInCents:0,
	customUpdateDeliveryCost:function(cost,costInCents){
		
	},
	updateDeliveryCost:function(cost,costInCents){
		this.customUpdateDeliveryCost(cost,costInCents);
		this.deliveryCost = cost;
		this.deliveryCostInCents = costInCents;
		var deliveryManager = dijit.byId("deliveryManager");
		
		if(deliveryManager.isDeliverable==true){
			if(specificLogic && specificLogic.freeDelivery && specificLogic.freeDelivery=="true"){
				this.deliveryCost=0;
				this.deliveryCostInCents=0;
				this.updateTotals();
				if(specificLogic.msg){
					com.copacabana.util.showTimedMessage(specificLogic.msg,dojo.query('.delCost')[0],5000);					
				}
			}else{
				this.updateTotals();
			}
		}else{
			this.updateTotals();
		}
		
		
	},
	minimumCost:0,
	updateDeliveryMinimumCostChange:function(minimum){
		this.minimumCost=minimum;
		this.checkMinimumValue();
		
	},
	checkMinimumValue:function(){
		if(this.minimumCost>0){
			if(this.minimumCost>this.subTotal){
				var msg = dojo.string.substitute(this.i18nStrings.minimumDeliveryCost,[this.minimumCost]);			
				dijit.showTooltip(msg, dojo.byId('totalWrapper'),['before','above']);
			}else{
				dijit.hideTooltip(dojo.byId('totalWrapper'));
			}
		}else{
			dijit.hideTooltip(dojo.byId('totalWrapper'));
		}
		
	},
	postCreate : function() {
		this.inherited(arguments);
		this.i18nStrings=dojo.i18n.getLocalization("com.copacabana.order",	"OrderManagerWidgetStrings");
		dojo.subscribe("onQuantityChanged",dojo.hitch(this,this.updateTotals));
		dojo.subscribe("onDeliveryCostChange",dojo.hitch(this,this.updateDeliveryCost));
		dojo.subscribe("onDeliveryMinimumCostChange",dojo.hitch(this,this.updateDeliveryMinimumCostChange));
		dojo.query(".observationArea", this.domNode)[0].value=this.order.observation;
		
		dojo.subscribe("onUserLocationCoords",dojo.hitch(this,this.userLocationFound));
		this.loadRestaurantData(this.order.restaurant);		
	},
	restaurant:null,
	restDataLoadFail:function(error){
		console.error("failed to load rest data.",error);
	},
	onlyForRetrieval:false,
	restDataLoaded:function(data){		
		this.restaurant=data;
		dojo.query(".restPlace", this.domNode)[0].innerHTML=this.restaurant.name;
		for ( var i = 0; i < this.restaurant.acceptablePayments.length; i++) {			
			var paymentName = this.restaurant.acceptablePayments[i];
			if(this.payPalDataController.level && this.payPalDataController.level=='PAYPAL'){
				
			}else{
				var payNode=dojo.query('.paymentType_'+paymentName, this.domNode)[0];			
				dojo.style(payNode,'display','block');
			}
		}
		switch (this.payPalDataController.level) {
		case 0:
			this.clientLevelTxt.innerHTML="O seu usu&aacute;rio s&oacute; ainda n&atilde;o permite fazer pedidos online. ";
			dojo.create("a",{target:"_blank",href:"/reputacaoConta.html",innerHTML:"saiba mais.",style:{fontSize:"small"}},this.clientLevelTxt);
			break;
		case 1:
			this.clientLevelTxt.innerHTML="O seu usu&aacute;rio s&oacute; permite fazer pedidos com pagamento online com valores menores que R$ 100,00. ";
			dojo.create("a",{target:"_blank",href:"/reputacaoConta.html",innerHTML:"saiba mais.",style:{fontSize:"small"}},this.clientLevelTxt);
			break;
		default:
			break;
		}
		
		
	},
	loadRestaurantData:function(restId){

		var xhrParams = {
				error : dojo.hitch(this, "restDataLoadFail"),
				handleAs : 'json',
				load : dojo.hitch(this, "restDataLoaded"),
				url : '/getRestaurant.do?id='+restId
		};
		dojo.xhrGet(xhrParams);
	},
	observation:null,
	obsChanged:function(){
		console.log("obs");
		console.log(dojo.query(".observationArea", this.domNode)[0].value);
		this.order.observation=dojo.query(".observationArea", this.domNode)[0].value;
	},
	totalOrderCost:0,
	deliveryCost:0,
	getSubTotalCost:function(){
		var subTotal=0;
		for ( var i = 0; i < this.plateList.length; i++) {
			var p = this.plateList[i];
			subTotal+=p.getTotalCost();
		}
		return subTotal;
	},
	subTotal:0,
	customUpdateTotals:function(){
		console.log('nocustomization');
	},
	updateTotals:function(){
		this.customUpdateTotals();
		var subTotal= this.getSubTotalCost();
		this.subTotal=subTotal;
		dojo.query(".subtotal", this.domNode)[0].innerHTML=com.copacabana.util.moneyFormatter(subTotal);
		//var deliveryCost = parseFloat(dojo.query(".delCost", this.domNode)[0].innerHTML);
		//console.log('updating toatl');
		this.totalOrderCost=this.deliveryCost+subTotal;
		if(this.discount!=null){			
			this.totalOrderCost= this.discount.calculateValue(this.totalOrderCost);
		}
		
		dojo.query(".delCost", this.domNode)[0].innerHTML=com.copacabana.util.moneyFormatter(this.deliveryCost);
		dojo.query(".totalOrderCost", this.domNode)[0].innerHTML=com.copacabana.util.moneyFormatter(this.totalOrderCost);
		this.checkMinimumValue();
		
			
	},
	discNode:null,
	discTextNode:null,
	discount:null,
	discountCostNode:null,
	discCostText:null,
	
	discountIsValid:function(data,code){		
		com.copacabana.util.hideTimedMessage();
		
		dojo.empty(this.discCostText);
		var node =this.discCostText; 
		var discText=this.discCostText;
		this.discount={
			code:code,
			value:data.value,
			node:node,
			isValid:true,
			txtNode:discText,
			type:data.type
		}
		switch (data.type) {
			case "VALUE":{
				this.discount.valueInCents=data.value;
				this.discount.discValue=(parseFloat(data.value)/100);
				this.discount.calculateValue=function(total){
					var totalRet = (total-(parseFloat(this.valueInCents)/100));
					if(totalRet<0){
						totalRet=0;
					}
					dojo.empty(this.node);
					this.txtNode = dojo.create("span",{innerHTML:com.copacabana.util.moneyFormatter(-1*this.discValue),className:"totalCost"},this.node);
					return totalRet;
				}				
				com.copacabana.util.showTimedMessage("Cupom v&aacute;lido. <br>Desconto de "+com.copacabana.util.moneyFormatter(this.discount.discValue),this.discMsgsDom,3000,['after']);
			}
			break;
			case "PERCENTAGE":	
				this.discount.pct=data.value;
				this.discount.discValue=null;
				this.discount.calculateValue=function(total){
					var value=(total-(total*parseFloat(this.pct/100)));
					this.discValue=total-value;					
					dojo.empty(this.node);
					this.txtNode=dojo.create("span",{innerHTML:com.copacabana.util.moneyFormatter(-1*this.discValue),className:"totalCost"},this.node);
					return value;
				};
				
				com.copacabana.util.showTimedMessage("Cupom v&aacute;lido. <br>Desconto de "+data.value+"%",this.discMsgsDom,3000,['after','below']);
			
			break;
		default:
			break;
		}
		this.updateTotals();
		
		
	},
	discountIsNotValid:function(){
		com.copacabana.util.hideTimedMessage();
	//	dojo.empty(this.discountCostNode);
//		this.discCostText= dojo.create("span",{innerHTML:"0,00",className:"totalCost"},this.discountCostNode);
		com.copacabana.util.showTimedMessage("Cupom inv&aacute;lido.",this.discMsgsDom,4000);
		this.discount={
				valueInCents:0,
				isValid:false,
				calculateValue:function(total){
					return total;
				}
			}
		this.updateTotals();
	},
	
	cupomForm:null,
	cupomImgDom:null,
	discMsgsDom:null,
	showDiscountSection:function(){
		
		this.cupomForm =dojo.create("div",{innerHTML:"Insira o c&oacute;digo do cupom: "},this.discDesc);
		this.cupomImgDom = dojo.create('img',{src:"/resources/img/loading.gif",style:{visibility:'hidden'}},this.cupomForm);
		var txtNode = dojo.create("div",{},this.cupomForm);
	     var props = {
	            name: "discCode",
	            style:{
	            		width:"60px",
	            		textAlign:"left"
	            }
	     };
	    this.discTextNode=new dijit.form.TextBox(props, txtNode);
		
	    this.discDesc
	    
	    this.discountSection = dojo.create("div",{style:{display:"none"}},this.discDesc);
	    
	    
	    this.discMsgsDom = dojo.query(".totalOrderCost", this.domNode)[0]; 
	    
	    var removeStyle={padding: "1px 4px",backgroundColor:"#f9f9f9",marginLeft:"110px",'float':"left",width:"10px"};
	    var remove = dojo.create("div",{style:removeStyle,innerHTML:"X"},this.discountSection)
	    dojo.connect(remove,"onmouseover",function(){dojo.style(remove,"backgroundColor",'#a9a9a9')});
	    dojo.connect(remove,"onmouseout",function(){dojo.style(remove,"backgroundColor",'#f9f9f9')});
	    dojo.create("span",{innerHTML:"Desconto: "},this.discountSection);
	    this.discCostText= dojo.create("span",{innerHTML:"R$ 0,00",className:"totalCost"},this.discountSection);
	    
	    
	    
	    var aaa=this.cupomForm ;
	    var discDom=this.discountSection;
	    dojo.connect(remove,"onclick",function(){
	    	//dojo.style(this.discountSection,"display","none");
			dojo.style(aaa,"display","block");			
			dojo.style(discDom,"display","none");
	    });
	    
		var fct = function(val){
	    	var code=this.discTextNode.attr('value');
	    	console.log("code",code)
			console.log("disc",this.discount)
			/*if(this.discount && code==this.discount.code){
				return;
			}*/	    	
	    	dojo.style(this.cupomImgDom,"visibility","visible");	
	    	var fct = function(data){
	    		dojo.style(this.cupomImgDom,"visibility","hidden");
	    		var code2=this.discTextNode.attr('value');
	    		if(data.valid){
	    			if(data.valid && data.valid==true){
	    				dojo.style(this.discountSection,"display","block");
	    				dojo.style(this.cupomForm,"display","none");
	    				this.discountIsValid(data,code2);
	    			}else{
	    				this.discountIsNotValid(data,code2);
	    			}
	    		}else{
	    			console.error(data);	
	    			this.discountIsNotValid(data,code2);
	    		}
	    	}
	    	var restIdToCheck="";
	    	if(this.restaurant){
	    		restIdToCheck=this.restaurant.id;
	    	}
	    	var xhrParams = {
					error : dojo.hitch(this, fct),
					handleAs : 'json',
					load : dojo.hitch(this,fct),
						
					url : '/isCupomValid.do?code='+code+"&restId="+restIdToCheck
			};
			dojo.xhrGet(xhrParams);
	    	
	    	//var disc = {valid:true,value:190,type:"VALUE"};
	    	//this.discountIsValid(disc);
	    	
	    	
	    }
	    dojo.connect(this.discTextNode,"onBlur",dojo.hitch(this,fct));
	    //this.discountCostNode=dojo.create("span",{},this.discDesc);
	    
	    dojo.style(this.discBtn,"display","none");
	},
	showDiscountSectionTable:function(){
		this.resultsNode = dojo.query(".plateMenuList", this.domNode)[0];
		this.discNode=dojo.create("tr",{className:"item"},this.resultsNode);
		var td1 = dojo.create("td",{className:"colunaItem"},this.discNode);
		dojo.create("span",{innerHTML:"Desconto",style:{textAlign:'left'}},td1);
		
		var td = dojo.create("td",{colspan:2},this.discNode);
		dojo.create("span",{innerHTML:"Insira o c&oacute;digo do cupom:",style:{textAlign:'left'}},td);
		var txtNode = dojo.create("div",{},td);
	     var props = {
	            name: "discCode",
	            style:{
	            		width:"60px",
	            		textAlign:"left"
	            }
	     };
	    this.discTextNode=new dijit.form.TextBox(props, txtNode);
	    var fct = function(val){
	    	var code=this.discTextNode.attr('value');
	    	console.log("code",code)
			console.log("disc",this.discount)
			if(this.discount && code==this.discount.code){
				return;
			}
	    	console.log('validating',code);
	    	dojo.empty(this.discCostText);
	    	dojo.create('img',{src:"/resources/img/loading.gif"},this.discCostText);
	    	var fct = function(data){
	    			var code2=this.discTextNode.attr('value');
	    			if(data.valid==true){
	    				this.discountIsValid(data,code2);
	    			}else{
	    				this.discountIsNotValid(data,code2);
	    			}
	    	}
	    	var xhrParams = {
					error : dojo.hitch(this, "discountIsNotValid"),
					handleAs : 'json',
					load : dojo.hitch(this,fct),
						
					url : '/isCupomValid.do?code='+code
			};
			dojo.xhrGet(xhrParams);
	    	
	    	//var disc = {valid:true,value:190,type:"VALUE"};
	    	//this.discountIsValid(disc);
	    	
	    	
	    }
	    dojo.connect(this.discTextNode,"onBlur",dojo.hitch(this,fct));
	    this.discountCostNode=dojo.create("td",{},this.discNode);
	    this.discCostText= dojo.create("span",{innerHTML:"0,00",className:"totalCost"},this.discountCostNode);
	    dojo.style(this.discBtn,"display","none");
	    
	},
	displayOrder:function(){		
		this.resultsNode = dojo.query(".plateMenuList", this.domNode)[0];		
		com.copacabana.util.cleanNode(this.resultsNode);
		var results = this.order.plates;

		var counter=0;
		if(results.length===0){
			this.resultsNode.innerHTML="Nenhum prato.";	
		}else{
			
			for ( var i = 0; i < results.length; i++) {
				var p = results[i];
				var wid = new com.copacabana.order.OrderEntryWidget(p,p.qty);
				if(specificLogic.makisPackageCostId && specificLogic.makisPackageCostId==p.plate){
					wid.isReadonly=true;
					if(specificLogic.makisMsg && specificLogic.makisMsg.length>0){
						wid.readOnlyMsg=specificLogic.makisMsg;
					}
				}
				wid.startup();
				this.plateList.push(wid);
				this.resultsNode.appendChild(wid.domNode);
				
			}			
		}
		
		
		
	},
	resultsNode:null,
	plateList:[],
	geoLocator:null,
	totalCashAmmountDijit:null,
	startup : function() {
		try {			
			dojo.parser.parse(this.domNode);
			this.displayOrder();			
			this.updateTotals();	
			this.totalCashAmmountDijit = dijit.byNode(dojo.query(".totalPaidAmount", this.domNode)[0]);
			this.totalCashAmmountDijit.attr("value","0,00");
			dijit.byId('InCash').onChange=dojo.hitch(this,this.moneyChangeUpdated);
			
			

			
			
			//dojo.connect(totalCashAmmountDijit, "onChange", this.changedMoneyAmount);
			dojo.connect(this.totalCashAmmountDijit, "onBlur",dojo.hitch(this,this.changedMoneyAmount));
			
			
			dijit.byId('useCpf').onChange=dojo.hitch(this,this.useCPFChanged);
			var cpfInitiallyShown = dojo.cookie("useCpf");
			console.log('cpfInitiallyShown',cpfInitiallyShown);
			if(cpfInitiallyShown=='true'){
				dijit.byId('useCpf').attr('value','YES');
				this.useCPFChanged(null);
			}
			
			
			if(this.geoLocator==null){
				this.geoLocator = new com.copacabana.lbs.FindUserLocation();
				this.geoLocator.startup();
				this.geoLocator.avoidAddressConversion();
			}
			this.geoLocator.findLocation();
			
			
		} catch (e) {
			console.error(e);
		}
	},
	changedMoneyAmount:function(arg){
		var val = this.totalCashAmmountDijit.getDisplayedValue();
		if(val && val.indexOf(',')==-1){
			var value =val+",00";
			this.totalCashAmmountDijit.attr('value',value);
		}
	},
	userIsAwareOfRetrivingPlate:false,
	payPalDataController:null,
	payPalConfirmed:false,
	confirmPayPal:function(response){			
		if(response=='yes' ){
			this.payPalConfirmed=true;
			this.submitOrder();			
		}else{
			this.registerRefusal();
		}

		return;
	},
	registerRefusal:function(){
		try{			
			var xhrParams = {
					error :function(error){},					
					load : function(data){},
					preventCache:true,
					failOk:true,
					url : '/userRefusedPayPalPayment.jsp'
			};
			dojo.xhrGet(xhrParams);	
		}catch(e){
			
		}
	},
	confirmRetrievingAtRestaurant:function(response){			
		if(response=='yes' ){
			this.userIsAwareOfRetrivingPlate=true;
			this.submitOrder();			
		}

		return;
	},
	submitOrder:function(){
		com.copacabana.util.showLoading();
		var mealorder={};
		mealorder.plates=[];
		var subTotal=0;
		var restId = this.restaurant.id;
		for ( var i = 0; i < this.plateList.length; i++) {
			var p = this.plateList[i];
			if(p.qty==0){
				continue;
			}
			var orderedPlate={
					name:p.orderedPlate.name,
					qty:p.qty,
					price:p.orderedPlate.price,
					priceInCents:p.orderedPlate.priceInCents,
					plate:p.orderedPlate.plate,
					restInternalCode:p.orderedPlate.restInternalCode,
					isFraction:false
					
			}
			if(p.orderedPlate.isFraction==true){
				orderedPlate.fractionPlates=p.orderedPlate.fractionPlates;
				orderedPlate.isFraction=true;
			}
			mealorder.plates.push(orderedPlate);
		}
		
		mealorder.deliveryCost=this.deliveryCost;
		mealorder.deliveryCostInCents=this.deliveryCostInCents;
		mealorder.restaurant=restId;
		mealorder.observation=dojo.query(".observationArea", this.domNode)[0].value; 

		//mealorder.payment
		
		if(this.coords){
			mealorder.x=this.coords.x;
			mealorder.y=this.coords.y;
		}
		

		var deliveryManager = dijit.byId("deliveryManager");

		if(deliveryManager.isDeliverable==false){
			com.copacabana.util.hideLoading();
			var msg = new com.copacabana.MessageWidget();
			msg.showMsg(this.i18nStrings.addressNotInRange,msg.errorType);			
			return;
		}
		
		mealorder.address=deliveryManager.selectedAddress.id;
		if(deliveryManager.selectedAddress.isRetrieveAtRestaurant==true) {
			if(this.onlyForRetrieval==true && this.userIsAwareOfRetrivingPlate==false){
				com.copacabana.util.hideLoading();
				var msg = new com.copacabana.MessageWidget();
				var options=[
				             {
				            	id:"yes",
				            	label:"Sim"		            	
				             },
				             {
					            	id:"no",
					            	label:"N&atilde;o"		            	
				             }
				         
				];
				
				var confMsg = this.i18nStrings.confirmRetrieveAtRestaurant;
				msg.promptMsg(confMsg,options,dojo.hitch(this,this.confirmRetrievingAtRestaurant),"Retirada no restaurante");
				return;
			}
			mealorder.retrieveAtRestaurant=true;						
		}else{
			mealorder.retrieveAtRestaurant=false;
		}
		
		mealorder.payment={totalValue:this.totalOrderCost,type:""};
		var subtotal = this.getSubTotalCost();
		if(this.minimumCost>subtotal){///mealorder.payment.totalValue){
			com.copacabana.util.hideLoading();			
			var msg = new com.copacabana.MessageWidget();
			msg.showMsg(this.i18nStrings.minimumValueNotSatisfied,msg.errorType);
			return;
		}
		
		var cheque = dojo.byId("Cheque").checked;//dijit.byNode(dojo.query(".CHEQUE", this.domNode)[0]);
		var cash =  dojo.byId("InCash").checked;//dijit.byNode(dojo.query(".INCASH", this.domNode)[0]);
		var paypal =  dojo.byId("PayPal").checked;		
		if(subtotal>0.0 && mealorder.payment.totalValue==0){
			cheque=false;
			cash=true;
			dijit.byNode(dojo.query(".totalPaidAmount", this.domNode)[0]).attr("value","0,00");
		}
		if(cheque){
			mealorder.payment.type="CHEQUE";
		}else if(cash){
			mealorder.payment.type="INCASH";
			if(!dijit.byNode(dojo.query(".totalPaidAmount", this.domNode)[0]).isValid()){
				com.copacabana.util.hideLoading();
				var msg = new com.copacabana.MessageWidget();
				msg.showMsg(this.i18nStrings.ammountInCashNotValid,msg.errorType);

				return;
			}
			var ammountInCash=parseFloat(dijit.byNode(dojo.query(".totalPaidAmount", this.domNode)[0]).attr("value"));
			if(isNaN(ammountInCash)==true){
				com.copacabana.util.hideLoading();
				var msg = new com.copacabana.MessageWidget();
				msg.showMsg(this.i18nStrings.ammountInCashNotValid,msg.errorType)

				return;
			}
			if(ammountInCash<mealorder.payment.totalValue){
				com.copacabana.util.hideLoading();
				var msg = new com.copacabana.MessageWidget();
				msg.showMsg(this.i18nStrings.ammountInCashLesserThanCost,msg.errorType);				
				return;
			}
			mealorder.payment.amountInCash=ammountInCash;
		}else if(paypal){
			mealorder.payment.type="PAYPAL";
			if(this.payPalConfirmed!=true){
				com.copacabana.util.hideLoading();
				var msg = new com.copacabana.MessageWidget();
				var options=[
				             {
				            	id:"yes",
				            	label:"Sim"		            	
				             },
				             {
					            	id:"no",
					            	label:"N&atilde;o"		            	
				             }
				         
				];
				//parseFloat(dojo.query(".subtotal", this.domNode)[0].innerHTML);
				var tax = this.payPalDataController.calculateTax(subtotal,mealorder.deliveryCost,this.discount);
				var confMsg = dojo.string.substitute(this.i18nStrings.payPalConfirmMsg,[tax]);
				msg.promptMsg(confMsg,options,dojo.hitch(this,this.confirmPayPal),"Pagamento com ca&atilde;o");
				return;
			}
			this.payPalConfirmed=false;
			
		}else{
			
			var paymentTypes = dojo.query('.paymentType',this.domNode);
			var checked = false;
			for ( var i = 0; i < paymentTypes.length; i++) {
				var chkDijit = dijit.byNode(dojo.query('.paymentType',this.domNode)[i]);
				checked=chkDijit.attr('checked')
				if(checked){
					mealorder.payment.type=chkDijit.attr('id');
					break;
				}
			}
			if(checked==false){
				com.copacabana.util.hideLoading();
				var msg = new com.copacabana.MessageWidget();
				msg.showMsg(this.i18nStrings.selectAtLeastOnePaymentType,msg.errorType);			
				return;
			}
		}
		
		if(dijit.byId('useCpf').attr('value')=='YES'){
			mealorder.cpf=dijit.byId('cpf').attr('value');
		}
		com.copacabana.util.hideLoading();
		if(this.discount!=null && this.discount.isValid==true){
			mealorder.discountInfo={
				code:this.discount.code,
				value:this.discount.discValue*100,
				type:this.discount.type
			}	
		}
		console.log("mealorder.discountInfo",mealorder.discountInfo)
		
		
		var orderform = dojo.create("form",{action:"/submitOrder.do",method:"post"},this.domNode);
		dojo.create("input",{type:"hidden",name:"mealOrder",value:dojo.toJson(mealorder)},orderform);
		var agreeWithTerms = new com.copacabana.MessageWidget();
		var optionsAgreement=[
		             {
		            	id:"yes",
		            	label:"Concordo"		            	
		             },
		             {
			            	id:"no",
			            	label:"N&atilde;o concordo"		            	
		             }
		         
		];		
		var confMsg1 = this.i18nStrings.termsagreement;
		agreeWithTerms.promptMsg(confMsg1,optionsAgreement,function(response){		
			if(response=='yes' ){
				com.copacabana.util.showLoading();
				orderform.submit();			
			}
			return;
		},"Termos de uso");
		return;
		


	},
	coords:null,
	userLocationFound:function(geolocation){
		this.coords={
			x:	geolocation.coords.longitude,
			y:	geolocation.coords.latitude
		};
	},
	customer:null,
	deliveryAddresss:null,
	setCustomer:function(person){
		this.customer=person;	
	},
	setDeliveryAddress:function(delAddress){
		this.deliveryAddress=delAddress;
	},
	moneyChangeUpdated:function(evt){
		console.log('incash',dojo.byId("InCash").checked);
		var fdom = dojo.query(".formaPagamento",this.domNode)[0]
		if(dojo.byId("InCash").checked==true){
			dojo.style(fdom,'visibility','visible');
		}else{
			dojo.style(fdom,'visibility','hidden');
		}
		
	},
	setClientCPF:function(cpf){
		this.clientCPF=cpf;
		this.currentCPF=this.clientCPF;
	},
	clientCPF:'',
	currentCPF:'',
	useCPFChanged:function(evt){
		var shouldUseCPF=dijit.byId('useCpf').attr('value');
		var fdom = dojo.query(".cpfField",this.domNode)[0];
		var cpfField = dijit.byId('cpf');
		if(shouldUseCPF=='YES'){
			dojo.cookie("useCpf", 'true', { expires: 100 });	
			dojo.style(fdom,'visibility','visible');
			cpfField.attr('value',this.currentCPF);
			cpfField.onBlur=dojo.hitch(this,this.checkCpf);
		}else{
			dojo.cookie("useCpf", 'false', { expires: 100 });
			this.currentCPF=cpfField.attr('value');
			dojo.style(fdom,'visibility','hidden');
			cpfField.attr('value','');
			try{
			dijit.hideTooltip( dijit.byId('cpf').domNode);
			}catch(e){
				
			}
		}
		console.log('useCPFChanged',dijit.byId('useCpf').attr('value'));
	},	
	checkCpf:function(){
		var cpf = dijit.byId('cpf');
		var cpfval =dojo.string.trim(cpf.attr('value'));
		cpfval=cpfval.replace(/\s/g,'');
		cpf.attr('value',cpfval);
		if(com.copacabana.util.isCpfValid(cpfval)==false){
			dijit.showTooltip(this.i18nStrings.cpfInvalid, cpf.domNode);
		}else{
			dijit.hideTooltip( cpf.domNode);
		}
	}
	

});

}

if(!dojo._hasResource["com.copacabana.order.ViewOrderDetailsWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.order.ViewOrderDetailsWidget"] = true;
dojo.provide("com.copacabana.order.ViewOrderDetailsWidget");











// I18N



dojo.requireLocalization("com.copacabana.order",
		"ViewOrderDetailsWidgetStrings", null, "ROOT,pt");

dojo.declare("com.copacabana.order.ViewOrderDetailsWidget", [ dijit._Widget,
		dijit._Templated ], {
	i18nStrings : null,
	templateString:"<div>\r\n<style>\r\n.qtyColumn{\r\nwidth:30px;\r\n}\r\n.nameColumn{\r\n \tfont-size: large;\r\n    text-align: left;\r\n    width: 150px;\r\n}\r\n.codeColumn{\r\nfont-size: x-small;\r\n}\r\n.mytable {\r\n    margin-right: 0px;\r\n    margin-left: 0px;;\r\n    margin-bottom: 5px;\r\n    width:80%;\r\n    padding: 0px;\r\n    border-collapse: collapse;\r\n}\r\n\r\n.mytable th {\r\n    font-weight: normal;\r\n    font-size: 0.8em;\r\n    padding: 4px 5px;\r\n}\r\n\r\n.mytable tbody td {\r\n    text-align: center;\r\n    padding: 0;\r\n    background: inherit;\r\n    border-bottom: 1px solid gray;\r\n}\r\n</style>\r\n<div\r\n\tstyle=\"float: left; width: 180px; margin-right: 10px; border-right: 1px solid black; height: 425px;overflow: auto;\">\r\n<div class=\"errorMsgPlace\" style=\"visibility: hidden;\"></div>\r\n<div style=\"text-align:center;\">Pedido No:<br><img src=\"/resources/img/loader.gif\" class=\"loadingSection\" style=\"width:15px;\"/><b\r\n\tstyle=\"font-size: large; font-weight: bold;\" class=\"orderNum\"></b><br/>\r\n<br/>\r\n<div style=\"text-align: center; width: inherit;\">Tempo decorrido</div>\r\n<div style=\"text-align: center; width: inherit;\"><b\r\n\tstyle=\"font-size: medium;\" class=\"elapsedTimePlace\">??:??</b> H:M</div>\r\n<br/>\r\n<div style=\"text-align: center; width: inherit;\">Status atual: <b\r\n\tstyle=\"font-size: medium;\" class=\"statusPlace\"></b></div>\r\n<br/>\r\n</div>\r\n<hr></hr>\r\n<div style=\"margin: 5px;overflow: auto;\">Cliente:<br/>\r\n<b style=\"font-size: medium;\" class=\"clientNamePlace\"></b><br>\r\nRanking <span class=\"rankingSummary\"></span> <span class=\"toogleRanking expand\" dojoAttachEvent=\"onclick:toogleRankingDetails\">+</span>\r\n<div class=\"rankingDetails\"><span class=\"rankingSite\"></span><br />\r\n<span class=\"rankingRest\"></span><br />\r\n</div>\r\nTelefone:<br/>\r\n<b style=\"font-size: medium;\" class=\"clientTelPlace\"></b><br />\r\n<br />\r\n\r\n<span class=\"addressLabel\">Endere&ccedil;o de entrega:</span><br/>\r\n<span style=\"font-size: small;\" class=\"addressPlace\"></span><br />\r\n<span style=\"font-size: medium;\" class=\"telAddressPlace\"></span><br />\r\n<br />\r\nPagamento:<br/>\r\n<b style=\"font-size: small;\" class=\"paymentPlace\"><br/>\r\n</b><br />\r\n<div class=\"cpfPlace\"></div>\r\n<br />\r\n</div>\r\n</div>\r\n<div\r\n\tstyle=\"margin-left: 5px; height: 375px; overflow: auto; border-bottom: 1px solid black;\">\r\n\t<div style=\"float: right;display:none;\" class=\"printerSection\"><button baseClass=\"orangeButton\" dojoType=\"dijit.form.Button\"\r\n\t\tclass=\"printOrder\"><img\r\n\t\tsrc=\"/resources/img/printer.png\"></img> Imprimir</button></div>\r\n<div class=\"Items\"><span dojoAttachPoint=\"totalItems\"></span> itens: <br/>\r\n\r\n</div>\r\n\r\nCusto Entrega: <span class=\"deliveryCost\"></span><br/>\r\n<div style=\"display:none\" class=\"discountCost\"></div>\r\n<div style=\"display:none\" class=\"convenienceCost\"></div>\r\nCusto total: <span class=\"totalCost\"></span><br/>\r\nObserva&ccedil;&otilde;es:\r\n<div class=\"observations\"\r\n\tstyle=\"border-style: solid; border-width: 1px; border-color:gray; height: 80px; width: 320px; overflow: auto\"></div>\r\n<br/>\r\n\r\n<span dojoAttachPoint=\"prepareForeCast\" style=\"display:none\"></span><br/>\r\n<span class=\"cancellationReason\" style=\"display:none\"></span>\r\n<span dojoAttachPoint=\"askId\" style=\"display:none;font-weight: bold;text-decoration: underline;\">Pe&ccedil;a um documento de identidade e assinatura na comanda no mesmo nome do cliente.</span><br/>\r\n</div>\r\n<div class=\"actionButtons\"\r\n\tstyle=\"position: absolute; right: 6px; bottom: 8px;width:395px\">\r\n<div>\r\n<table border=\"0\" style=\"margin-bottom: 0px;margin-right: inherit;\">\r\n\t<tr>\r\n\t\t<td style=\"background: white;padding-left: 15px;\">\r\n\t\t<button class=\"closeWindow\" dojoType=\"dijit.form.Button\"  baseClass=\"orangeButton\" >\r\n            Fechar\r\n        </button>\r\n\t\t</td>\r\n\t\t<td  style=\"background: white;padding-left: 15px;\">\r\n\t\t<button class=\"changeToNextStatus\" dojoType=\"dijit.form.Button\"  baseClass=\"orangeButton\"></button>\r\n\t\t</td>\r\n\t\t<td style=\"background: white;padding-left: 15px;\">\r\n\t\t<button class=\"cancelOrder\" style=\"display: none;\" dojoType=\"dijit.form.Button\" baseClass=\"orangeButton\">\r\n\t\tCancelar\r\n\t\t</button>\r\n\t\t</td>\t\t\r\n\t</tr>\r\n</table>\r\n<form class=\"updateOrderForm\" style=\"display: none;\" method=\"post\" dojoType=\"dijit.form.Form\"\r\n\taction=\"/changeOrderStatus.do\"></form>\r\n<form class=\"printOrderForm\" style=\"display: none;\" method=\"post\" dojoType=\"dijit.form.Form\"\r\n\taction=\"/printOrder\" target=\"printOrder\">\r\n\t\r\n\t\r\n\t</form>\r\n</div></div>\r\n</div>\r\n",
	constructor : function() {

	},
	
	eachMinuteHandler:null,
	handlers:[],
	destroyRecursive : function() {
		try{
		dojo.unsubscribe(this.eachMinuteHandler);
		for ( var i = 0; i < this.handlers.length; i++) {
			dojo.disconnect(this.handlers[i]);
		}
		
		dojo.forEach(this.getDescendants(), function(widget) {
			widget.destroyRecursive();
		});
		this.dialog.destroyRecursive();
		this.inherited(arguments);
		}catch(e){
			console.error("destroy recursive, view order details.",e);
		}
	},
	order : null,

	postMixInProperties : function() {
		this.inherited(arguments);
	},

	postCreate : function() {		
		this.inherited(arguments);
		this.handlers=[];
		this.i18nStrings=dojo.i18n.getLocalization("com.copacabana.order","ViewOrderDetailsWidgetStrings");
		dojo.parser.parse(this.domNode);
		var dtitle = this.i18nStrings.orderDetailsTitle;
		var options = {
			title : dtitle,
			style : 'width: 600px;height:460px;'
			
		};
		this.dialog = new dijit.Dialog(options);
		this.dialog.containerNode.appendChild(this.domNode);
	},
	onClose:function(evt){
		console.log("onclose ",evt);
	},
	dialog : null,
	userView:false,
	addressDataLoadFail:function(error){
		console.error("failed to load rest data.",error);
		var msg = new com.copacabana.MessageWidget();
		msg.showMsg(this.i18nStrings.loadAddressFailed);
	},
	addressDataLoaded:function(data){
		var address=data.street+" "+data.number +","+data.additionalInfo+", "+data.neighborhood.name; 
		if(!data.additionalInfo||data.additionalInfo==''){
			 address=data.street+" "+data.number +", "+data.neighborhood.name;
		}
		
		var phone = data.phone;
		if(!phone){
			phone=this.orderDetails.clientPhone;
		}
		if(this.userView==true){
			if(this.orderDetails.retrieveAtRestaurant==true){
				console.log(dojo.query('.addressLabel',this.domNode)[0]);
				dojo.query('.addressLabel',this.domNode)[0].innerHTML=this.i18nStrings.retrieveAtRestaurant;	
			}
			this.fillAddress(address,phone);
		}else{
			if(this.orderDetails.retrieveAtRestaurant==true){				
				dojo.query('.addressLabel',this.domNode)[0].innerHTML=this.i18nStrings.restaurantRetrieveAtRestaurant;	
			}else{
				this.fillAddress(address,phone);
			}
		}
		 
		
		this.formattedAddress=address;
		this.addressPhone=phone;
		
	},
	addressPhone:null,
	formattedAddress:null,
	hideloading:function(){
		dojo.style(dojo.query(".loadingSection",this.domNode)[0],'display','none');
	},
	fillAddress:function(address,phone){
		
		dojo.query(".addressPlace",this.dialog.containerNode)[0].innerHTML=address;		
		dojo.query(".telAddressPlace",this.dialog.containerNode)[0].innerHTML='Tel:'+phone;
		
	},
	loadAddress:function(addressId){

		var xhrParams = {
				error : dojo.hitch(this, "addressDataLoadFail"),
				handleAs : 'json',
				load : dojo.hitch(this, "addressDataLoaded"),
				url : '/loadAddress.do?id='+addressId
		};
		dojo.xhrGet(xhrParams);
	},
	
	updateDialog:function(){
		if(this.userView==false && this.order.dailyCounter && this.order.dailyCounter>0){
			dojo.query(".orderNum",this.dialog.containerNode)[0].innerHTML=this.order.dailyCounter+" ("+this.order.idXlated+")";
		}else{
			dojo.query(".orderNum",this.dialog.containerNode)[0].innerHTML=this.order.idXlated;
		}
		dojo.query(".clientNamePlace",this.dialog.containerNode)[0].innerHTML=this.orderDetails.clientName;
		dojo.query(".clientTelPlace",this.dialog.containerNode)[0].innerHTML=this.orderDetails.clientPhone;
		
		if(this.userView==false && this.order.askForId==true){
			dojo.style(this.askId,"display","block");
		}
		this.loadAddress(this.orderDetails.address);
		
		if(this.orderDetails.payment.type=="INCASH"){
			var changeAmtStr = com.copacabana.util.moneyFormatter(this.orderDetails.payment.amountInCash);
			dojo.query(".paymentPlace",this.dialog.containerNode)[0].innerHTML=dojo.string.substitute(this.i18nStrings.paymentType_INCASH, [changeAmtStr]);
		}else{
			dojo.query(".paymentPlace",this.dialog.containerNode)[0].innerHTML=this.i18nStrings["paymentType_"+this.orderDetails.payment.type];
		}
		var clientPrefix="";
		if(this.userView){
			clientPrefix="CLIENT_";
		}
		dojo.query(".statusPlace",this.dialog.containerNode)[0].innerHTML=this.i18nStrings["label_"+clientPrefix+this.order.status];
		var rankingSite;
		if(this.orderDetails.clientRequestsOnSite<3){
			rankingSite=this.i18nStrings['rankingSiteText_'+this.orderDetails.clientRequestsOnSite];
			dojo.style(dojo.query(".rankingSite",this.dialog.containerNode)[0],'color','red');
		}else{
			rankingSite=dojo.string.substitute(this.i18nStrings.rankingSiteText, [(this.orderDetails.clientRequestsOnSite+1)]);
		}
		
		var rankingRest;
		if(this.orderDetails.clientRequestsOnRestaurant<3){
			rankingRest=this.i18nStrings['rankingRestText_'+this.orderDetails.clientRequestsOnRestaurant];
			dojo.style(dojo.query(".rankingRest",this.dialog.containerNode)[0],'color','red');
		}else{
			rankingRest=dojo.string.substitute(this.i18nStrings.rankingRestText, [(this.orderDetails.clientRequestsOnRestaurant+1)]);
		}
		
		dojo.query(".rankingSummary",this.dialog.containerNode)[0].innerHTML="("+this.orderDetails.clientRequestsOnSite+","+this.orderDetails.clientRequestsOnRestaurant+")";		
		dojo.query(".rankingSite",this.dialog.containerNode)[0].innerHTML=rankingSite;
		dojo.query(".rankingRest",this.dialog.containerNode)[0].innerHTML=rankingRest;
		
		if(this.orderDetails.cpf!=null){
			dojo.query(".cpfPlace",this.dialog.containerNode)[0].innerHTML = "CPF: "+this.orderDetails.cpf;
		}
		
		
		var plates = this.orderDetails.plates;
		var platesSection = dojo.query(".Items",this.dialog.containerNode)[0];
		var totalCost=0;
		
		this.totalItems.innerHTML=""+plates.length+"";
		var table = dojo.create("table",{className:'mytable'},platesSection);
		var thead = dojo.create("thead",{},table);
		dojo.create("th",{innerHTML:"Qtd"},thead);
		dojo.create("th",{innerHTML:"Nome"},thead);
		dojo.create("th",{innerHTML:"Pre&ccedil;o"},thead);
		var tbody = dojo.create("tbody",{},table);
		for ( var i = 0; i < plates.length; i++) {
			var plate = plates[i];
			var tr = dojo.create("tr",{},tbody);
  		    dojo.create("td",{innerHTML:plate.qty,className:"qtyColumn"},tr);
  		    var name=plate.name;
  		    var td = dojo.create("td",{innerHTML:name,className:"nameColumn"},tr);
  		    if(plate.restInternalCode && plate.restInternalCode.length>0){
  		    	dojo.create('span',{innerHTML:" c&oacute;digo:"+plate.restInternalCode,className:'codeColumn'},td);				
			}
  		    
  		    dojo.create("td",{innerHTML:com.copacabana.util.moneyFormatter(plate.priceInCents/100),className:"priceColumn"},tr);
  		  
			//var div = document.createElement("div");
			//div.setAttribute("class","item");
			//var spanQty = dojo.create("span",{style:{fontSize:'large'},className:'plateQty',innerHTML:plate.qty+"x "},div); 
			
				
/*				document.createElement("span");
			spanQty.setAttribute("style","font-size: large;");
			spanQty.setAttribute("class","plateQty");
			spanQty.innerHTML=plate.qty;*/
			
			//var spanName = dojo.create("span",{style:{fontSize:'large'},className:'plateTitle',innerHTML:plate.name},div);
			//document.createElement("span");
//			spanName.setAttribute("style","font-size: large;");
//			spanName.setAttribute("class","plateTitle");
//			
//			spanName.innerHTML=plate.name;
			
			//div.appendChild(spanQty);
			//div.appendChild(document.createTextNode(" "));
			//div.appendChild(spanName);
//			if(plate.restInternalCode && plate.restInternalCode.length>0){
//				dojo.create("span",{style:{fontSize:"small"},innerHTML:" c&oacute;digo:"+plate.restInternalCode},div);
//			}
			
			//var hr = document.createElement("hr");
			//var br = document.createElement("br");
			//platesSection.appendChild(div);

			//platesSection.appendChild(hr);
			
			
			totalCost+=plate.price*plate.qty;
			
		}
		
		totalCost+=this.orderDetails.deliveryCost;
		dojo.query(".deliveryCost",this.dialog.containerNode)[0].innerHTML=com.copacabana.util.moneyFormatter(this.orderDetails.deliveryCost);
		
		dojo.query(".deliveryCost",this.dialog.containerNode)[0].innerHTML=com.copacabana.util.moneyFormatter(this.orderDetails.deliveryCost);
		dojo.query(".totalCost",this.dialog.containerNode)[0].innerHTML=com.copacabana.util.moneyFormatter(this.order.totalAmountInCents/100);
		dojo.query(".observations",this.dialog.containerNode)[0].innerHTML=this.orderDetails.observation;
		
		dojo.style(dojo.query(".cancelOrder",this.dialog.containerNode)[0],"display","none");
		if(this.userView==true){
			dojo.style(dojo.query(".changeToNextStatus",this.dialog.containerNode)[0],"display","none");			
			dojo.style(dojo.query(".cancelOrder",this.dialog.containerNode)[0],"display","none");
			if(this.order.status=="NEW" && this.order.status!="VISUALIZEDBYRESTAURANT"){
				//TODO dojo.style(dojo.query(".cancelOrder",this.dialog.containerNode)[0],"display","true");
			}
			
		}else{			
			dojo.style(dojo.query(".printerSection",this.dialog.containerNode)[0],"display","block");
			if(this.order.status=="CANCELLED" || this.order.status=="EXPIRED"){
				dojo.style(dojo.query(".changeToNextStatus",this.dialog.containerNode)[0],"display","none");
			}else{				
				if(this.order.status=="NEW" || this.order.status=="VISUALIZEDBYRESTAURANT"){
					dojo.style(dojo.query(".cancelOrder",this.dialog.containerNode)[0],"display","block");
					dojo.style(dojo.query(".closeWindow",this.dialog.containerNode)[0],"display","none");
					dojo.style(this.dialog.closeButtonNode,"display","none");
				}
				
				if(this.order.status=="DELIVERED"){
					dojo.style(dojo.query(".changeToNextStatus",this.dialog.containerNode)[0],"display","none");
					dojo.style(dojo.query(".cancelOrder",this.dialog.containerNode)[0],"display","none");
				}
			}
			
			var labelBtn="";
			var titleBtn="";
			if(this.order.status=="NEW" || this.order.status=="VISUALIZEDBYRESTAURANT"){				
				labelBtn="Preparando pedido";
				titleBtn="Mudar status do pedido para em preparo";
			}else{			
				if(this.order.status=="PREPARING"){
					if(this.order.retrieveAtRestaurant==true){
						labelBtn="Pedido pronto";
						titleBtn="Pedido pronto, aguardando cliente.";
					}else{
						labelBtn="Pedido enviado";
						titleBtn="Pedido est&aacute; a caminho.";
					}
				}else{
					if(this.order.status=="INTRANSIT"){
						labelBtn="Pedido entregue";
						titleBtn="Pedido foi entregue ao cliente.";
					}else{						
						if(this.order.status=="WAITING_CUSTOMER"){
							labelBtn="Cliente retirou pedido";
							titleBtn="Cliente buscou o pedido.";
						}
					}
				}
			}	
			var buttonStatus = dijit.byNode(dojo.query(".changeToNextStatus",this.dialog.containerNode)[0]);
			
			
			buttonStatus.attr('label' ,labelBtn);
			buttonStatus.attr('title',titleBtn);
			
		}		
		if(this.orderDetails.status=='CANCELLED' || this.orderDetails.status=='EXPIRED'){
			var cancelRegion = dojo.query(".cancellationReason",this.dialog.containerNode)[0];			
			dojo.style(cancelRegion,'display','block');
			dojo.create('h3',{innerHTML:'Motivo cancelamento:'},cancelRegion);
			if(this.orderDetails.status=='EXPIRED'){
				dojo.create('span',{innerHTML:this.i18nStrings.expiredReason,style:{color:'red',fontWeigth:'bold'}},cancelRegion);
			}else{
				dojo.create('span',{innerHTML:this.orderDetails.reason,style:{color:'red',fontWeigth:'bold'}},cancelRegion);
			}
			
		}
		this.updateElapsedTime();
		this.hideloading();
	},
	rankingDetailsShown:false,
	toogleRankingDetails:function(){
		var toogler = dojo.query(".toogleRanking",this.dialog.containerNode)[0];
		if(this.rankingDetailsShown==true){
			dojo.style(dojo.query(".rankingDetails",this.dialog.containerNode)[0],"display","none");
			dojo.query(".toogleRanking",this.dialog.containerNode)[0].innerHTML="+";
			dojo.removeClass(toogler,'collapse');
			dojo.addClass(toogler,'expand');
		}else{
			dojo.style(dojo.query(".rankingDetails",this.dialog.containerNode)[0],"display","block");
			dojo.addClass(toogler,'collapse');
			dojo.removeClass(toogler,'expand');
			dojo.query(".toogleRanking",this.dialog.containerNode)[0].innerHTML="-";
		}
		this.rankingDetailsShown=!this.rankingDetailsShown;
	},
	orderDetails:null,
	
	loadedOrder:function(response){
		this.orderDetails=response;
		
		
		this.updateDialog();
	},
	showErrorMsg:function(msg){
		if(!msg){
			msg=this.i18nStrings.defaultErrorMsg;
		}
		var domMsgNode = dojo.query(".errorMsgPlace",this.domNode)[0];
		dojo.empty(domMsgNode);
		dojo.create('span',{innerHTML:msg},domMsgNode);
		dojo.style(domMsgNode,'visibility','visible');
	},
	detailsEndpoint:"/loadOrderDetails.do",
	startup : function() {
		try {
			
			var xhrArgs = {
				url : this.detailsEndpoint+"?id="+this.order.id,
				handleAs : "json",
				load :dojo.hitch(this,this.loadedOrder),
				error : function(error) {
					console.error(error);
					this.hideloading();
					this.showErrorMsg();
				}
			};
			var deferred = dojo.xhrGet(xhrArgs);	
			
			if(this.order.status=="NEW" || this.order.status=="VISUALIZEDBYRESTAURANT" || this.order.status=="PREPARING"){
				this.eachMinuteHandler=dojo.subscribe("onEachMinute",dojo.hitch(this,this.updateElapsedTime));				
			}
			try{				
				if(this.order.convenienceTaxInCents && this.order.convenienceTaxInCents>0){
					dojo.query(".convenienceCost",this.dialog.containerNode)[0].innerHTML="Taxa site: "+com.copacabana.util.moneyFormatter(this.order.convenienceTaxInCents/100.0);	
				}				
				if(this.order.discountInfo && this.order.discountInfo.value>0){
					var discountCostDom = dojo.query(".discountCost",this.dialog.containerNode)[0];
					dojo.style(discountCostDom,'display','block');
					discountCostDom.innerHTML="Desconto: "+com.copacabana.util.moneyFormatter(this.order.discountInfo.value/100);	
				}
			if(this.order.prepareForeCast && this.order.prepareForeCast.length>0){
				var prepareForeCastDom = dojo.query(".cancellationReason",this.dialog.containerNode)[0];
				dojo.style(prepareForeCastDom,'display','block');
				prepareForeCastDom.innerHTML="Previs&atilde;o: "+this.order.prepareForeCast;
			}
			}catch(e){
				console.error("cannot update details",e)
			}
			
			this.dialog.show();
			this.handlers.push(dojo.connect(dojo.query(".changeToNextStatus",this.dialog.containerNode)[0], "onclick", this, this.changeToNextStatus));
			this.handlers.push(dojo.connect(dojo.query(".cancelOrder",this.dialog.containerNode)[0], "onclick", this, this.cancelOrder));
			this.handlers.push(dojo.connect(dojo.query(".closeWindow",this.dialog.containerNode)[0], "onclick", this, this.closeWindow));
			this.handlers.push(dojo.connect(dojo.query(".printOrder",this.dialog.containerNode)[0], "onclick", this, this.printOrder));
			
		} catch (e) {
			console.error('View details startup failed.',e);
			this.showErrorMsg();
		}
	},
	currentDelay:null,
	updateElapsedTime:function(){
		
		this.order.orderedHour=com.copacabana.util.parseTime(this.orderDetails.orderedTime);
		this.order.orderedDate=com.copacabana.util.parseDate(this.orderDetails.orderedTime);		
		if(this.order.status=="NEW" || this.order.status=="VISUALIZEDBYRESTAURANT" || this.order.status=="PREPARING" || this.order.status=="INTRANSIT"){
			var elapsed = com.copacabana.util.getElapsedTime(this.order.orderedHour,this.order.orderedTime);
			dojo.query(".elapsedTimePlace", this.dialog.containerNode)[0].innerHTML=elapsed;
		}else{
			
			var elapsed = com.copacabana.util.getElapsedTime(this.order.orderedHour,this.order.orderedTime,this.order.lastStatusUpdateTime);
			dojo.query(".elapsedTimePlace", this.dialog.containerNode)[0].innerHTML=elapsed;
		}
	},
	oldNodes:[],
	changeToNextStatus:function(event){
		if (event) {
			// Stop the submit event since we want to control form submission.
			event.preventDefault();
			event.stopPropagation();
			dojo.stopEvent(event);
		}
		
		var newStatus;
		if(this.order.status=="NEW" || this.order.status=="VISUALIZEDBYRESTAURANT"){
			newStatus="PREPARING";
			//if(this.order.retrieveAtRestaurant==true){
				var msg = new com.copacabana.MessageWidget();
				var average = "15 minutos";
				if(this.currentDelay){
					average = this.currentDelay;					
				}
				msg.promptInputMsg("Insira a previs&atilde;o para preparo do pedido: ",dojo.hitch(this,this.finishPrepare),"Tempo para preparo",average);
				return;
			//}
		}else{
			if(this.order.status=="PREPARING"){
				if(this.order.retrieveAtRestaurant==true){
					newStatus="WAITING_CUSTOMER";
				}else{
					newStatus="INTRANSIT";	
				}
			}else{
				if(this.order.status=="INTRANSIT"||this.order.status=="WAITING_CUSTOMER"){
					newStatus="DELIVERED";
				}	
			}
		}
		this.tried=0;
		this.changeOrderStatus(newStatus, "n/a");
		
			
	},
	finishPrepare:function(response){
		this.tried=0;
		this.changeOrderStatus("PREPARING", "n/a",response);
	},
	confirmCancelClientIsAware:function(response){
		console.log(response);
		if(response=='yes'){
			var msg = new com.copacabana.MessageWidget();
			var options=[
			             {
			            	id:"yes",
			            	label:"Sim"		            	
			             },
			             {
				            	id:"no",
				            	label:"N&atilde;o"		            	
			             }
			         
			];
			             
			msg.promptMsg(this.i18nStrings.confirmCancelClientIsAware,options,dojo.hitch(this,this.confirmCancelLastStep),"Cancelar");
		}
	},
	confirmCancelLastStep:function(response){
		if(response=='yes'){
			
			var msg = new com.copacabana.MessageWidget();
			msg.promptInputMsg(this.i18nStrings.confirmCancelRequestReason,dojo.hitch(this,this.finishCancelOrder),"Cancelar");
			
		}else{
			var msg = new com.copacabana.MessageWidget();
			msg.showMsg(this.i18nStrings.confirmCancelMakeClientAware);			
		}
	},
	finishCancelOrder:function(str){
		this.tried=0;
		this.changeOrderStatus("CANCELLED", str);
	},
	cancelOrder : function(event) {
		
			if (event) {
				// Stop the submit event since we want to control form submission.
				event.preventDefault();
				event.stopPropagation();
				dojo.stopEvent(event);
			}
		var msg = new com.copacabana.MessageWidget();
		var options=[
		             {
		            	id:"yes",
		            	label:"Sim"		            	
		             },
		             {
			            	id:"no",
			            	label:"N&atilde;o"		            	
		             }
		         
		];
		var cancelInitialMsg=this.i18nStrings.confirmCancelInitial;
		if(this.orderDetails.payment.type=='PAYPAL'){
			cancelInitialMsg=this.i18nStrings.confirmCancelInitialWithPaypal;
		}
		msg.promptMsg(cancelInitialMsg,options,dojo.hitch(this,this.confirmCancelClientIsAware),"Cancelar");
		/*var r=confirm(this.i18nStrings.confirmCancelInitial);
		if (r==true){
			r=confirm(this.i18nStrings.confirmCancelClientIsAware);
			if (r==true){
				var reason=prompt(this.i18nStrings.confirmCancelRequestReason);
				this.changeOrderStatus("CANCELLED", reason);
			}else{
				alert(this.i18nStrings.confirmCancelMakeClientAware);
			}
		}
		*/	
	},
	
	changeOrderStatus:function(newStatus,reason,timeToRetrieve,loadingText){
		com.copacabana.util.showLoading(loadingText);
		var form = dojo.create("form",{action:"/changeOrderStatus.do",method:"post"});
		dojo.create("input",{type:"text",name:"id",value:this.order.id},form);
		dojo.create("input",{type:"text",name:"key",value:this.order.id},form);
		dojo.create("input",{type:"text",name:"status",value:newStatus},form);
		dojo.create("input",{type:"text",name:"reason",value:reason},form);
		dojo.create("input",{type:"text",name:"delay",value:timeToRetrieve},form);
		
		
		var xhrArgs = {
			form : form,//dojo.query(".updateOrderForm", this.domNode)[0],
			handleAs : "json",
			load : dojo.hitch(this, function(data) {
				var entity = data;
				if(data.status==false){					
					if(data.errorCode=='PAYPALIOERROR' && this.tried<2){
						this.tried++;
						com.copacabana.util.hideLoading();
						console.log(newStatus,timeToRetrieve);
						this.changeOrderStatus(newStatus,reason,timeToRetrieve,this.i18nStrings.retryAuthorization+" "+this.tried);
					}else{
						com.copacabana.util.hideLoading();
						var msg = new com.copacabana.MessageWidget();
						if(data.errorCode=='PAYPALEXPIRED'){
							msg.showMsg(this.i18nStrings.errorPayPalExpired);
							this.order.status='CANCELLED';
							dojo.publish("onChangeOrderStatus",[this.order])
							this.dialog.hide();
							this.dialog.destroyRecursive();	
							this.destroyRecursive();
						}else{
							var msg = new com.copacabana.MessageWidget();
							if(data.errorCode=='PAYPALERROR' || data.errorCode=='PAYPALIOERROR'){
								msg.showMsg(this.i18nStrings.errorPayPalStatusChange);
							}else{
								if(data.errorCode=='INCORRECTSTATUSWORKFLOW'){
									msg.showMsg(this.i18nStrings.statusAlreadyCancelled);	
								}else{
									msg.showMsg(this.i18nStrings.errorDuringOrderStatusChange);
								}
							}
							this.dialog.hide();
							this.dialog.destroyRecursive();	
							this.destroyRecursive();
						}
					}
				}else{
					com.copacabana.util.hideLoading();
					data.idXlated=this.order.idXlated;
					dojo.publish("onChangeOrderStatus",[data])
					
					this.dialog.hide();
					this.dialog.destroyRecursive();	
					this.destroyRecursive();
				}
			}),
			error : function(error) {
				com.copacabana.util.hideLoading();
				console.log('pasosu',error)
				var msg = new com.copacabana.MessageWidget();
				msg.showMsg(this.i18nStrings.errorDuringOrderStatusChange);
				console.log("Form error ", error);
				this.dialog.hide();
				this.dialog.destroyRecursive();
				this.destroyRecursive();
			}		
		};
		// Call the asynchronous xhrPost
		var deferred = dojo.xhrPost(xhrArgs);	
	},
	tried:0,
//	if(this.userView==false && (this.order.status=="NEW" || this.order.status=="VISUALIZEDBYRESTAURANT")){
//		var msg = new com.copacabana.MessageWidget();
//		msg.showMsg(this.i18nStrings.mustAcceptOrCancelOrder);
//		return;
//	}
	closeWindow:function(event){
		if (event) {
			// Stop the submit event since we want to control form submission.
			event.preventDefault();
			event.stopPropagation();
			dojo.stopEvent(event);
		}		
		try{
			this.dialog.hide();
			this.dialog.destroyRecursive();	
			this.destroyRecursive();
		}catch(e){
			console.error("failed to destroy dialog",e);
		}

	},
	printOrder:function(event){
		if (event) {
			// Stop the submit event since we want to control form submission.
			event.preventDefault();
			event.stopPropagation();
			dojo.stopEvent(event);
		}
		
		console.log(this.orderDetails);
		var form =dojo.query(".printOrderForm", this.dialog.containerNode)[0];
		dojo.empty(form);
		
		console.log('b',dojo.toJson(this.order));
		dojo.create("input",{type:"text",name:"orderId",value:this.order.id},form);
		dojo.create("input",{type:"text",name:"orderIdXlated",value:this.order.idXlated},form);
		dojo.create("input",{type:"text",name:"clientName",value:this.orderDetails.clientName},form);
		dojo.create("input",{type:"text",name:"clientPhone",value:this.orderDetails.clientPhone},form);
		dojo.create("input",{type:"text",name:"orderedTime",value:this.order.orderedTime},form);
		
		
		var plates = this.orderDetails.plates;
		
		var totalCost=0;
		for ( var i = 0; i < plates.length; i++) {
			var plate = plates[i];
			
			var pstr= plate.qty+"|"+plate.name+"|"+com.copacabana.util.moneyFormatter(plate.price)+"|"+com.copacabana.util.moneyFormatter(plate.price*plate.qty);
			dojo.create("input",{type:"text",name:"plate",value:pstr},form);
					
			totalCost+=plate.price*plate.qty;
			
		}
		
		totalCost+=this.order.deliveryCost/100;
		dojo.create("input",{type:"text",name:"deliveryCost",value:com.copacabana.util.moneyFormatter(this.order.deliveryCost/100)},form);
		
		dojo.create("input",{type:"text",name:"totalCost",value:com.copacabana.util.moneyFormatter(this.order.totalAmountInCents/100)},form);
		
		if(this.orderDetails.payment.type=="PAYPAL"){
			dojo.create("input",{type:"text",name:"pType",value:"online"},form);
		}else{
			dojo.create("input",{type:"text",name:"pType",value:"t"+this.orderDetails.payment.type},form);			
			if(this.orderDetails.payment.type=="INCASH"){
				dojo.create("input",{type:"text",name:"pTypeName",value:'Em dinheiro'},form);
				var moneyamount =this.orderDetails.payment.amountInCash;		
				console.log(com.copacabana.util.moneyFormatter(moneyamount))
				dojo.create("input",{type:"text",name:"moneyAmount",value:com.copacabana.util.moneyFormatter(moneyamount)},form);
				dojo.create("input",{type:"text",name:"moneyChange",value:com.copacabana.util.moneyFormatter(moneyamount-totalCost)},form);
			}else{
				dojo.create("input",{type:"text",name:"pTypeName",value:this.i18nStrings["paymentType_"+this.orderDetails.payment.type]},form);	
			}
		}
		if(this.orderDetails.retrieveAtRestaurant==true){
			dojo.create("input",{type:"text",name:"retrieveAtRestaurant",value:1},form);
		}else{
			dojo.create("input",{type:"text",name:"address",value:this.formattedAddress},form);
			dojo.create("input",{type:"text",name:"addressPhone",value:this.addressPhone},form);
		}
		
		if(this.orderDetails.cpf!=null){
			dojo.create("input",{type:"text",name:"clientCPF",value:this.orderDetails.cpf},form);
		}
		if(this.orderDetails.observation!=null && this.orderDetails.observation!=''){
			dojo.create("input",{type:"text",name:"observation",value:this.orderDetails.observation},form);
		}
		
		form.submit();
		
	}

});

}

if(!dojo._hasResource["com.copacabana.order.RestaurantOrderEntryWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.order.RestaurantOrderEntryWidget"] = true;
dojo.provide("com.copacabana.order.RestaurantOrderEntryWidget");











// I18N



dojo.requireLocalization("com.copacabana.order",
		"RestaurantOrderEntryWidgetStrings", null, "ROOT,pt");

dojo.declare("com.copacabana.order.RestaurantOrderEntryWidget", [ dijit._Widget,
		dijit._Templated ], {
	i18nStrings : null,
	templateString:"<tr dojoAttachEvent=\"onclick:viewOrderDetails\"> \r\n\t<td style=\"text-align:center\">${order.dailyCounter}</td>\r\n\t<td style=\"text-align:center;padding:4px;\"><a href=\"#\">${order.idXlated}</a></td>\t\r\n\t<td >${order.orderedDate}</td>\r\n\t<td style=\"text-align:center\">${order.orderedHour}</td>\r\n\t<td style=\"text-align:center\" class=\"${order.statusCss}\"><img alt=\"${order.statusImageAlt}\" title=\"${order.statusImageAlt}\" src=\"${order.statusImage}\" /></td>\r\n\t<td style=\"text-align:center\" class=\"elapsedLastStatusChange\"></td>\r\n\t<td style=\"text-align:center\" class=\"elapsedTotal\"></td>\r\n\t\r\n</tr>\r\n",
	constructor : function(order,timeBased) {
		this.order = order;
		if(!this.order.idXlated){
			this.order.idXlated="";
		}
		if(!this.order.dailyCounter ||this.order.dailyCounter==0){
			this.order.dailyCounter="";
		}
		this.i18nStrings=dojo.i18n.getLocalization("com.copacabana.order",	"RestaurantOrderEntryWidgetStrings");
		this.order.statusCss = this.i18nStrings['CSS_'+this.order.status];
		this.order.statusImage = this.i18nStrings['IMAGE_'+this.order.status];
		this.order.statusImageAlt = this.i18nStrings['ALT_IMAGE_'+this.order.status];
		this.timeBased=timeBased;
		if(timeBased==false){
			this.templateString="<tr dojoAttachEvent=\"onclick:viewOrderDetails\"\t>\r\n\t<td style=\"text-align:center\"><a href=\"#\">${order.idXlated}</a></td>\r\n\t<td style=\"text-align:center\">${order.orderedDate}</td>\r\n\t<td style=\"text-align:center\">${order.orderedTime}</td>\r\n\t<td style=\"text-align:center\" class=\"${order.statusCss}\"><img alt=\"${order.statusImageAlt}\" title=\"${order.statusImageAlt}\" src=\"${order.statusImage}\" /></td>\r\n\t<td style=\"text-align:center\" >${order.lastStatusUpdateTime}</td>\r\n</tr>\r\n";
		}		
		this.order.orderedHour=com.copacabana.util.parseTime(order.orderedTime);
		this.order.orderedDate=com.copacabana.util.parseDate(order.orderedTime);
		this.order.lastStatusUpdateHour=com.copacabana.util.parseTime(order.lastStatusUpdateTime);

	},
	timeBased:true,
	destroyRecursive : function() {
		dojo.forEach(this.getDescendants(), function(widget) {
			widget.destroyRecursive();
		});
		this.inherited(arguments);
	},
	order : null,

	postMixInProperties : function() {
		this.inherited(arguments);
	},

	postCreate : function() {
		this.inherited(arguments);
		
	},

	startup : function() {
		try {
			dojo.parser.parse(this.domNode);
			if(this.order.status=='NEW'){
				console.log("startup of a NEW one")
				dojo.publish("onNewOrders",[this.order]);
			}
			if(this.timeBased==true){				
				dojo.subscribe("onEachMinute",dojo.hitch(this,this.updateElapsedTime));
				this.updateElapsedTime();
			}
		} catch (e) {
			console.error(e);
		}
	},
	updateElapsedTime:function(data){	
		if(dojo.query(".elapsedTotal", this.domNode)[0]){
			dojo.query(".elapsedTotal", this.domNode)[0].innerHTML=com.copacabana.util.getElapsedTime(this.order.orderedHour,this.order.orderedTime);
		}
		if(dojo.query(".elapsedTotal", this.domNode)[0]){
			dojo.query(".elapsedLastStatusChange", this.domNode)[0].innerHTML=com.copacabana.util.getElapsedTime(this.order.lastStatusUpdateHour,this.order.lastStatusUpdateTime);
		}
	},
	viewOrderDetails:function(){	
		var v=new com.copacabana.order.ViewOrderDetailsWidget();
		v.currentDelay=loggedRestaurant.currentDelay;
		v.order=this.order;
		v.startup();		
	}

});

}

if(!dojo._hasResource["com.copacabana.order.RestaurantOrdersWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.order.RestaurantOrdersWidget"] = true;
dojo.provide("com.copacabana.order.RestaurantOrdersWidget");












// I18N





dojo.declare("com.copacabana.order.RestaurantOrdersWidget", [ dijit._Widget,
		dijit._Templated ], {
	i18nStrings : null,
	templateString:"<div>\r\n\r\n<p class=\"mensagem\" dojoAttachPoint=\"ordersTitle\"></p>\r\n\r\n<table class=\"andamento\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>&nbsp;</th>\r\n\t\t\t<th>No do Pedido</th>\r\n\t\t\t<th>Data</th>\r\n\t\t\t<th style=\"width: 120px;\">Entrada &agrave;s (H:M)</th>\r\n\t\t\t<th>Status</th>\r\n\t\t\t<th style=\"width: 120px;\">&Uacute;ltima mudan&ccedil;as (H:M)</th>\r\n\t\t\t<th style=\"width: 120px;\">Tempo total decorrido (H:M)</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody class=\"tbody\" >\t\t\r\n\t</tbody>\r\n</table>\r\n</div>\r\n",
	constructor : function() {
		console.log(this.status);
		
	},
	
	destroyRecursive : function() {
		dojo.forEach(this.getDescendants(), function(widget) {

			widget.destroyRecursive();
		});
		this.inherited(arguments);
	},
	orderList : null,
	isNoTime:false,
	postMixInProperties : function() {
		this.inherited(arguments);
		if(this.isNoTime==true){
			this.templateString="<div>\r\n<div class=\"dateRangeSelection\" style=\"display: none;\">\r\nFiltrar de:<input width=\"58\" dojoType=\"dijit.form.DateTextBox\" class=\"startDate\" /> a:<input width=\"58\" dojoType=\"dijit.form.DateTextBox\" class=\"endDate\"/> \r\n<button baseClass=\"orangeButton\" class=\"updateOrdersByDateRange\" dojoType=\"dijit.form.Button\"\tdojoAttachEvent=\"onclick:updateOrdersByDateRange\" >Atualizar</button></div>\r\n<p class=\"mensagem\" dojoAttachPoint=\"ordersTitle\"></p>\r\n\r\n<table class=\"andamento\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th>No do Pedido</th>\r\n\t\t\t<th>Data</th>\r\n\t\t\t<th>Hora de Entrada do Pedido (H:M:S)</th>\r\n\t\t\t<th>Status</th>\r\n\t\t\t<th>&Uacute;ltima mudan&ccedil;a de status</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody class=\"tbody\" >\t\t\r\n\t</tbody>\r\n</table>\r\n</div>\r\n";
		}
		
	},

	postCreate : function() {
		this.inherited(arguments);
		this.i18nStrings=dojo.i18n.getLocalization("com.copacabana.order",
		"RestaurantOrdersWidgetStrings");
		
	},	
	typeOfRequests:"oldRequests",
	displayOrderList:function(){
		
		this.resultsNode = dojo.query(".tbody", this.domNode)[0];
		
		
		com.copacabana.util.cleanNode(this.resultsNode);
		var results = this.orderList;

		var counter=0;
		/*if(this.isNoTime==true){
			
			var msgnode = dojo.query(".mensagem", this.domNode)[0];			
			dojo.empty(msgnode);			
			var confMsg = dojo.string.substitute(this.i18nStrings.totalLabelDateRange,[results.length]);			
			msgnode.innerHTML=confMsg;
			
		}else{
			dojo.query(".totalRequests", this.domNode)[0].innerHTML=results.length;
		}*/
		
		if(results.length===0){
			var msg = dojo.string.substitute(this.i18nStrings.titleNoRequests, [this.i18nStrings[this.typeOfRequests]]);
			this.ordersTitle.innerHTML=msg;
		}else{			
			var msg = dojo.string.substitute(this.i18nStrings.titleNumberOfRequests, [results.length,this.i18nStrings[this.typeOfRequests]]);
			this.ordersTitle.innerHTML=msg;
			
			
			for ( var i = 0; i < results.length; i++) {
				var p = results[i];
				//don't show old expired requests.
				if(p.status=='EXPIRED' && this.typeOfRequests!="inPeriodRequests"){			
					var lastChangeDate = com.copacabana.util.getDate(p.lastStatusUpdateTime);
					var diff = dojo.date.difference(lastChangeDate,new Date(),'day');
					if(diff>1){
						continue;
					}
				}
				if(!this.showElapsed){
					var wid = new com.copacabana.order.RestaurantOrderEntryWidget(p,false);
					wid.startup();
					this.resultsNode.appendChild(wid.domNode);
					this.entryList.push(wid);
				}else{
					var wid = new com.copacabana.order.RestaurantOrderEntryWidget(p,true);
					wid.startup();
					this.resultsNode.appendChild(wid.domNode);
					this.entryList.push(wid);
				}
			}			
		}
		
		com.copacabana.util.blink(dojo.query(".tbody", this.domNode)[0]);
	},
	showElapsed:false,
	entryList:[],
	resultsNode:null,
	getServerList:function(response){
		
		this.deferred=null;
		com.copacabana.util.hideLoading();
		this.orderList=response;
		
		for ( var i = 0; i < this.entryList.length; i++) {
			this.entryList[i].destroyRecursive();
		}
		this.entryList=[];
		
		this.displayOrderList();
	},	
	status:null,
	errorLoading:function(error){
		console.error(error);
		com.copacabana.util.hideLoading();
		
		if(error.status==0){
			var msg = new com.copacabana.MessageWidget();
			msg.showMsg(this.i18nStrings.cannotReachServer,msg.errorType);
		}else{
			if(error.status==403){
				//login session expired
				window.location=window.location;
			}
		}
	},
	deferred:null,
	updateList:function(){		
		if(this.deferred==null){
			try{
				this.deferred.cancel();
			}catch (e) {

			}
		}
		if(!this.status){
			var xhrArgs = {
				url : "/listRestaurantPendingOrderList.do",
				handleAs : "json",
				load : dojo.hitch(this, this.getServerList),
				error : dojo.hitch(this, this.errorLoading)
			}
			this.deferred = dojo.xhrPost(xhrArgs);			
			
		}else{
			if(this.isDateRangeable==true){
				var drange = dojo.query('.dateRangeSelection',this.domNode)[0];				
				dojo.style(drange,'display','block');
				
				
				var startDijit = dijit.byNode(dojo.query('.startDate',this.domNode)[0]);
				var endDijit = dijit.byNode(dojo.query('.endDate',this.domNode)[0]);
				
				var datePattern='dd-MM-yyyy';
				var dateStartStr = "00:00:00 "+dojo.date.locale.format(startDijit.attr('value'),{datePattern:datePattern,selector:'date'});
				var dateEndStr = "23:59:59 "+dojo.date.locale.format(endDijit.attr('value'),{datePattern:datePattern,selector:'date'});
				
				
				var xhrArgs = {
						url : "/restOrdersByDate.do?status=EXPIRED&status=EVALUATED&status=DELIVERED&status=CANCELLED&start="+dateStartStr+"&end="+dateEndStr,
						
						handleAs : "json",
						load : dojo.hitch(this, this.getServerList),
						error : dojo.hitch(this, this.errorLoading)						
					}
				this.deferred = dojo.xhrPost(xhrArgs);
			}else{
				if(this.status=='EXPIRED'){
					var start = new Date();
					//var dateStartStr = "00:00:00 01-"+(d.getMonth()-1)+"-2010";
					var formatOptions ={
							selector:'date',
							datePattern:'00:00:01 dd-MM-yyyy'
					}
					var dateStartStr = dojo.date.locale.format(dojo.date.add(start,"day",-1),formatOptions);
					var dateEndStr = dojo.date.locale.format(start,formatOptions);
					console.log(dateStartStr);
					console.log(dateEndStr);
					var xhrArgs = {
							url : "/restOrdersByDate.do?status=EXPIRED&start="+dateStartStr+"&end="+dateEndStr,
							handleAs : "json",
							load : dojo.hitch(this, this.getServerList),
							error : dojo.hitch(this, this.errorLoading)
					}
					this.deferred = dojo.xhrPost(xhrArgs);
				}else{
					var xhrArgs = {
							url : "/listRestaurantOrderListByStatus.do?status="+this.status,
							handleAs : "json",
							load : dojo.hitch(this, this.getServerList),
							error : dojo.hitch(this, this.errorLoading)
					}
					this.deferred = dojo.xhrPost(xhrArgs);
				}
				
			}
		}
		
	},
	isDateRangeable:false,
	month:null,
	year:null,
	startup : function() {
		try {
			dojo.parser.parse(this.domNode);
			com.copacabana.util.showLoading();
			if(this.isDateRangeable==true){
				var startDijit = dijit.byNode(dojo.query('.startDate',this.domNode)[0]);
				startDijit.attr('value',new Date());
				var endDijit = dijit.byNode(dojo.query('.endDate',this.domNode)[0]);
				endDijit.attr('value',new Date());
				
			}
			
			this.updateList();
			if(this.status=='EXPIRED'){
				
			}else{
				dojo.subscribe("onChangeOrderStatus",dojo.hitch(this,this.orderChangedStatus));
				if(!this.status){
					dojo.subscribe("onEachMinute",dojo.hitch(this,this.updateList));
				}
				if(this.isNoTime==true){
					dijit.byNode(dojo.query('.updateOrdersByDateRange',this.domNode)[0]).onClick=dojo.hitch(this,this.updateOrdersByDateRange);
				}
			}
		} catch (e) {
			console.error(e);
		}
	},
	
	orderChangedStatus:function(data){
		try {
			
			console.log("Updating status of "+this.id);
			
			if (this.status) {
				
				var newList = [];
				for ( var i = 0; i < this.entryList.length; i++) {
					if(this.entryList[i].id!=data.id){
						newList.push(this.entryList[i]);
					}					
				}
				this.entryList=newList;
				dijit.byId(data.id).destroyRecursive();
				if (data.status != 'DELIVERED') {
					var p = data;
					
					if (!this.showElapsed) {
						var wid = new com.copacabana.order.RestaurantOrderEntryWidget(
								p, false);
						wid.startup();
						this.resultsNode
								.appendChild(wid.domNode);
						this.entryList.push(wid);
					} else {
						var wid = new com.copacabana.order.RestaurantOrderEntryWidget(
								p, true);
						wid.startup();
						this.resultsNode.appendChild(wid.domNode);
						this.entryList.push(wid);
					}
					
				}else{					
					if (data.status == 'PREPARING' && this.status) {
						var wid = new com.copacabana.order.RestaurantOrderEntryWidget(data,false);
						this.resultsNode.appendChild(wid.domNode);
						this.entryList.push(wid);
						this.resultsNode.addChild(dijit.byId(data.id).domNode);
					}
					
				}
				var msg = dojo.string.substitute(this.i18nStrings.titleNumberOfRequests, [this.entryList.length,this.i18nStrings[this.typeOfRequests]]);
				this.ordersTitle.innerHTML=msg;
			}else{
				if (data.status == 'PREPARING' && this.status) {
					this.resultsNode.removeChild(dijit.byId(data.id).domNode);
				}
				var newList = [];
				for ( var i = 0; i < this.entryList.length; i++) {
					if(this.entryList[i].id!=data.id){
						newList.push(this.entryList[i]);
					}
					
				}
				this.entryList=newList;
				
				if(this.isNoTime==true){
					var msgnode = dojo.query(".mensagem", this.domNode)[0];
					dojo.empty(msgnode);
					var confMsg = dojo.string.substitute(this.i18nStrings.totalLabelDateRange,[this.entryList.length]);
					msgnode.innerHTML=confMsg;
				}else{
					//dojo.query(".totalRequests", this.domNode)[0].innerHTML=this.entryList.length;
					var msg = dojo.string.substitute(this.i18nStrings.titleNumberOfRequests, [this.entryList.length,this.i18nStrings[this.typeOfRequests]]);
					this.ordersTitle.innerHTML=msg;
				}
			}
			
		} catch (e) {
			console.log('failed to change status',e);
		}
		
	},
	getDate:function(dDijit){
		var smonth = dDijit.getMonth()+1;
		var sday = dDijit.getDate();
		var syear = dDijit.getYear();
		
		if(!dojo.isIE){
			syear+=1900;
		}
		
		var dateStr = "00:00:00 "+sday+"-"+smonth+"-"+syear;
		return dateStr;
		
	},
	updateOrdersByDateRange:function(){
		this.updateList()
	}
});

}

if(!dojo._hasResource["com.copacabana.order.UserViewOrderEntryWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.order.UserViewOrderEntryWidget"] = true;
dojo.provide("com.copacabana.order.UserViewOrderEntryWidget");











//I18N


 


dojo.declare("com.copacabana.order.UserViewOrderEntryWidget", [
		dijit._Widget, dijit._Templated ], {
	i18nStrings: null,
	templateString:"<tr class=\"\" >\r\n\t<td><a href=\"#\" dojoAttachEvent=\"onclick:viewOrderDetails\" >${order.idXlated}</a></td>\t\r\n\t<td>${order.orderedTimeString}</td>\r\n\t<td>${order.lastStatusUpdateTimeString}<span class=\"msgPlace\" style=\"height:20px;\"></span></td>\t\r\n\t<td class=\"helptext\" dojoAttachPoint=\"statusSec\"><span dojoAttachPoint=\"statusXlated\">&nbsp;</span><div dojoAttachPoint=\"timerPlace\">&nbsp;</div></td>\r\n\t<td><a href=\"/?showRestaurant=true&restaurantId=${order.restaurant}&rName=${order.restaurantName}\">${order.restaurantName}</a></td>\t\r\n</tr>\r\n",
	orderStatusClass:'',
	constructor : function(order) {
		this.order=order;
		if(!this.order.restaurant.name){
			this.order.restaurant.name="";
		}
		
		this.order.orderedHour=com.copacabana.util.parseTime(this.order.orderedTime);
		this.order.lastStatusUpdateHour=com.copacabana.util.parseTime(this.order.lastStatusUpdateTime);
		
		
		var lastChangeDate = com.copacabana.util.getDate(this.order.lastStatusUpdateTime);		
		var diff = dojo.date.difference(lastChangeDate,new Date(),'day');
		if(diff>1){
			var formatOptions ={
				datePattern:'dd \'de\' MMMM \'&agrave;s\'',
				timePattern:'kk:mm'
			}
			this.order.orderedTimeString=dojo.date.locale.format(com.copacabana.util.getDate(this.order.orderedTime),formatOptions);
			this.order.lastStatusUpdateTimeString=dojo.date.locale.format(com.copacabana.util.getDate(this.order.lastStatusUpdateTime),formatOptions);			
		}else{
			this.order.orderedTimeString=this.order.orderedHour;
			this.order.lastStatusUpdateTimeString=this.order.lastStatusUpdateHour;
		}
		
		
		
	},
	muteStatusMsgs:false,
	orderStatusAltText:'',
	 destroyRecursive: function(){
		try{
			dijit.hideTooltip(dojo.query(".msgPlace",this.domNode)[0])
			clearTimeout(this.timerHandler);
		}
		catch (e) {

		}
		dojo.forEach(this.getDescendants(), function(widget){
         
        	widget.destroyRecursive();
        });
        this.inherited(arguments);
    },
    order:null,
    
	postMixInProperties : function() {
		this.inherited(arguments);
	},

	postCreate : function() {
		this.inherited(arguments);
		this.i18nStrings=dojo.i18n.getLocalization("com.copacabana.order", "UserViewOrderEntryWidgetStrings");
		this.order.statusTranslated=eval('this.i18nStrings.orderstatus_'+this.order.status);
		console.log('loaded'+'this.i18nStrings.orderstatus_'+this.order.status,this.order.statusTranslated)
		
	},
	
	viewOrderDetails:function(){
		var v=new com.copacabana.order.ViewOrderDetailsWidget();
		v.order=this.order;
		v.userView=true;
		dijit.hideTooltip(dojo.query(".msgPlace",this.domNode)[0]);
		v.startup();
	},
	startup : function() {
		try {
			dojo.parser.parse(this.domNode);	
			
			console.log("this.order.status",this.order.status);
			var altk = "orderstatus_"+this.order.status+"_ALT";
			var title = eval('this.i18nStrings.'+altk);			
			this.orderStatusAltText=title;
			console.log("alt",this.orderStatusAltText);
			this.orderStatusClass='orderstatus_'+this.order.status;
			
			console.log("class",this.orderStatusClass);
			dojo.addClass(this.statusSec,this.orderStatusClass);
			this.statusSec.title=this.orderStatusAltText;
			console.log(this.order.statusTranslated);
			this.statusXlated.innerHTML=this.order.statusTranslated;
			dojo.addClass(this.statusXlated,this.orderStatusClass);
			if(this.timerHandler){
				clearTimeout(this.timerHandler);
			}
			if(this.muteStatusMsgs==false){
				if(this.order.status=='NEW'){
					this.orderedTime=com.copacabana.util.getDate(this.order.orderedTime);
					setTimeout(dojo.hitch(this,this.showTimer), 2000);								
				}else
					if(this.order.status=='EXPIRED'){
						var lastChangeDate = com.copacabana.util.getDate(this.order.lastStatusUpdateTime);
						console.log("lastChangeDate",lastChangeDate);
						console.log("this.order.lastStatusUpdateTime",this.order.lastStatusUpdateTime);
						var diff = dojo.date.difference(lastChangeDate,new Date(),'day');
						console.log("diff",diff);
						if(diff<1){
							setTimeout(dojo.hitch(this,this.showExpiredToolTip), 3000);
						}

					}else
						if(this.order.status=='CANCELLED'){
							var lastChangeDate = com.copacabana.util.getDate(this.order.lastStatusUpdateTime);
							var diff = dojo.date.difference(lastChangeDate,new Date(),'day');
							if(diff<1){
								setTimeout(dojo.hitch(this,this.showCancelledToolTip), 1000);
							}
						}
				if(this.order.retrieveAtRestaurant==true){
					if(this.order.status=='WAITING_CUSTOMER'){
						setTimeout(dojo.hitch(this,this.showToolTip), 1000);					
					}else{
						if(this.order.status=='PREPARING'){
							if(this.order.prepareForeCast!=null && this.order.prepareForeCast!=''){
								this.foreCastText="Tempo estimado para preparo do pedido: "+this.order.prepareForeCast;
								setTimeout(dojo.hitch(this,this.showForeCast), 1000);
								this.publishPreparingState();

							}
						}
					}
				}
			}
			
			
		} catch (e) {
			console.error(e);
		}
	},
	publishPreparingState:function(){
		dojo.publish("onOrderPreparing");
	},
	showToolTip:function(){
		dijit.showTooltip(this.i18nStrings.orderIsReadyToRetrieve, dojo.query(".msgPlace",this.domNode)[0]);	
	},
	foreCastText:'',
	showForeCast:function(){
		dijit.showTooltip(this.foreCastText, dojo.query(".msgPlace",this.domNode)[0],['below','above']);	
	},
	orderedTime:null,
	timerHandler:null,
	maxWaitingTime:60*6,
	warnWaitingTime:60*5,
	notifiedDelay:false,
	showTimer:function(){
		var d = new Date();		
		var ss = dojo.date.difference(this.orderedTime,d,'second');
		if(ss>this.maxWaitingTime && this.notifiedDelay==false){			
			var msg = dojo.string.substitute(this.i18nStrings.maxWaitingTimeReached, [this.order.restaurantName,this.order.restaurantPhone]);			
			dijit.showTooltip(msg, dojo.query(".msgPlace",this.domNode)[0],['below','above']);
			this.notifiedDelay=true;
		}
		var mm = parseInt(ss/60);
		ss=ss%60;
		if(ss<10){
			ss='0'+ss;
		}
		
		if(this.timerPlace){
			this.timerPlace.innerHTML=mm+":"+ss;
			this.timerHandler = setTimeout(dojo.hitch(this,this.showTimer), 1000);
		}
		
	},
	showExpiredToolTip:function(){
		dijit.showTooltip(this.i18nStrings.expiredExplain, dojo.query(".msgPlace",this.domNode)[0],['below','above']);
		var fct = dojo.hitch(this,function(){dijit.hideTooltip(dojo.query(".msgPlace",this.domNode)[0])})
		setTimeout(fct, 15000);
		
	},
	showCancelledToolTip:function(){
		dijit.showTooltip(this.i18nStrings.cancelledExplain, dojo.query(".msgPlace",this.domNode)[0],['below','above']);
		var fct = dojo.hitch(this,function(){dijit.hideTooltip(dojo.query(".msgPlace",this.domNode)[0])})
		setTimeout(fct, 15000);
		
	}

});

}

if(!dojo._hasResource["com.copacabana.order.UserViewOrderWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.order.UserViewOrderWidget"] = true;
dojo.provide("com.copacabana.order.UserViewOrderWidget");












// I18N





dojo.declare("com.copacabana.order.UserViewOrderWidget", [ dijit._Widget,
		dijit._Templated ], {
	i18nStrings : null,
	templateString:"<div>\r\n\r\n<table id=\"andamento\">\r\n\t<thead>\r\n\t\t<tr>\t\t\t\r\n\t\t\t<th>No do Pedido</th>\r\n\t\t\t<th>Hora de Entrada do Pedido (H:M)</th>\r\n\t\t\t<th>&Uacute;ltima altera&ccedil;&atilde;o (H:M)</th>\r\n\t\t\t<th>Status</th>\r\n\t\t\t<th>Restaurante</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody class=\"tbody\">\r\n\t\t\r\n\t</tbody>\r\n</table>\r\n<span class=\"msgNode\"></span><br/>\r\n<div class=\"latestDiv\" style=\"display: none;\">\r\n<h3>Pedidos recentes:</h3>\r\n<table id=\"ultimosPedidos\">\r\n\t<thead>\r\n\t\t<tr>\t\t\t\r\n\t\t\t<th>No do Pedido</th>\r\n\t\t\t<th>Hora de Entrada do Pedido (H:M)</th>\r\n\t\t\t<th>&Uacute;ltima altera&ccedil;&atilde;o (H:M)</th>\r\n\t\t\t<th>Status</th>\r\n\t\t\t<th>Restaurante</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody class=\"tbodyultimos\">\t\t\r\n\t</tbody>\r\n</table>\r\n</div>\r\n\r\n</div>\r\n",
	constructor : function() {
		
		
	},
	
	destroyRecursive : function() {
		dojo.forEach(this.getDescendants(), function(widget) {

			widget.destroyRecursive();
		});
		this.inherited(arguments);
	},
	orderList : null,

	postMixInProperties : function() {
		this.inherited(arguments);
	},

	postCreate : function() {
		this.inherited(arguments);
		this.i18nStrings=dojo.i18n.getLocalization("com.copacabana.order",
		"UserViewOrderWidgetStrings");
	},	
	msgNode:null,
	muteStatusMsgs:false,
	displayOrderList:function(){
		this.resultsNode = dojo.query(".tbody", this.domNode)[0];
		this.msgNode = dojo.query(".msgNode", this.domNode)[0];
		
		com.copacabana.util.cleanNode(this.resultsNode);
		com.copacabana.util.cleanNode(this.msgNode);
		var results = this.orderList;
		var counter=0;
		if(results.length===0){
			if(this.statusList){
				this.msgNode.appendChild(document.createTextNode("Nenhuma ordem."));
			}else{				
				this.msgNode.appendChild(document.createTextNode("Nenhuma ordem em andamento."));				
			}
		
		}else{
			for ( var i = 0; i < results.length; i++) {
				var p = results[i];
				var wid = new com.copacabana.order.UserViewOrderEntryWidget(p);
				wid.muteStatusMsgs=this.muteStatusMsgs;
				
				wid.startup();
				this.resultsNode.appendChild(wid.domNode);
				this.entryList.push(wid);
			}
			
		}
		
		if(this.recentOrderList.length>0){
			
			for ( var i = 0; i < this.recentEntryList.length; i++) {
				this.recentEntryList[i].destroyRecursive();
			}
			this.recentEntryList=[];
			var recentResultsNode = dojo.query(".tbodyultimos", this.domNode)[0];
			
			for ( var i = 0; i < this.recentOrderList.length; i++) {
				var p = this.recentOrderList[i];
				var wid = new com.copacabana.order.UserViewOrderEntryWidget(p);
				
				wid.startup();
				recentResultsNode.appendChild(wid.domNode);
				this.recentEntryList.push(wid);
			}
			dojo.style(dojo.query(".latestDiv", this.domNode)[0],'display','block');
		
		
		}else{
			dojo.style(dojo.query(".latestDiv", this.domNode)[0],'display','none');
			
		}
	},
	resultsNode:null,
	entryList:[],
	clientOrderBean:null,
	recentOrderList:null,
	recentEntryList:[],
	getServerList:function(response){
		this.clientOrderBean=response;
		this.orderList=this.clientOrderBean.orders;	
		this.recentOrderList=this.clientOrderBean.recentOrders;
		for ( var i = 0; i < this.entryList.length; i++) {
			this.entryList[i].destroyRecursive();
		}
		this.entryList=[];
		this.displayOrderList();
	},
	retrieveServerList:function(){
		var xhrArgs;
		if(this.statusList){
			xhrArgs = {
				url : "/listClientOrders.do?status="+this.statusList,
				handleAs : "json",
				load : dojo.hitch(this, this.getServerList),
				error : function(error,ioArgs) {
					console.error(error.message,ioArgs);
					
					if(ioArgs.xhr.status==403){
						window.location=window.location;
					}
				}
			}
		}else{
			xhrArgs = {
					url : "/getMyPendingOrderList.do?addLatestOnes=true",
					handleAs : "json",
					load : dojo.hitch(this, this.getServerList),
					error : function(error,ioArgs) {
						console.error(error.message,ioArgs);
						console.error(ioArgs.xhr.status);
						if(ioArgs.xhr.status==403){
							window.location=window.location;
						}
					}
				}
		}		
		
		var deferred = dojo.xhrPost(xhrArgs);
	},
	statusList:null,
	startup : function() {
		try {
			dojo.parser.parse(this.domNode);
			this.retrieveServerList();
		} catch (e) {
			console.error(e);
		}
	},
	startRefreshing:function(){
		dojo.subscribe("onEachMinute",dojo.hitch(this,this.retrieveServerList));
	}
});


}

if(!dojo._hasResource["com.copacabana.search.SearchRestaurantsWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.search.SearchRestaurantsWidget"] = true;
dojo.provide("com.copacabana.search.SearchRestaurantsWidget");











dojo.declare("com.copacabana.search.SearchRestaurantsWidget", [ dijit._Widget,
		dijit._Templated ],
		{

			templateString:"<div ><img id=\"filtrosBuscaImg\"\r\n\tsrc=\"/resources/img/opt/filtrosDeBusca.png\" alt=\"Filtros de Busca\" /> <img\r\n\tid=\"cantoFormularioImg\" src=\"/resources/img/opt/bordaFormulario.png\" />\r\n\r\n\r\n<div dojoType=\"dijit.form.Form\" class=\"buscaForm\" jsId=\"busca\"\r\n\tid=\"searchForm\" action=\"\" method=\"\"\r\n\tstyle=\"position: absolute; margin-left: 45px; margin-top: 10px; top: 50px;\">\r\n\t\r\n <label for=\"city\" \r\n\tstyle=\"color: #605D5D; font-family: verdana, arial, sans-serif; font-size: small; padding: 5px 2px;\">Cidade</label><br><img alt=\"Sua localiza��o atual\" src=\"/resources/img/locPin.png\" id=\"autoLocImg\" style=\"display: none\"><span style=\"margin-left:5px;font-weight:bold; width: 175px;margin-bottom:5px;margin-top: 5px;\" id=\"cityName\">${selectedCity.name}</span><span style=\"cursor: pointer;\" id=\"changeCity\" dojoAttachEvent=\"onclick:changeCity\"> trocar...<br/></span>\r\n\t <select dojoType=\"dijit.form.FilteringSelect\" id=\"citySelection\" dojoAttachPoint=\"citySelection\"\r\n\t\t name=\"criteria.city\"  autoComplete=\"true\" style=\"background-color: white;width: 175px;margin-bottom:5px;margin-top: 5px; display:none;\"\r\n\t\tinvalidMessage=\"Cidade inv&aacute;lida\"></select>\r\n<label for=\"neighbor\"\r\n\tstyle=\"color: #605D5D; font-family: verdana, arial, sans-serif; font-size: small; padding: 5px 2px;\">Bairro</label><br>\r\n\t <select dojoType=\"dijit.form.FilteringSelect\" id=\"neighSelection\" \r\n\t\tname=\"criteria.neighbor\" autoComplete=\"false\" selectOnClick=\"true\" hasDownArrow=\"false\"\r\n\t\tinvalidMessage=\"Bairro inv&aacute;lido\" promptMessage=\"Digite o nome de seu bairro\" style=\"background-color: white;width: 175px;margin-bottom:5px;margin-top: 5px;\"></select>\r\n\t\t<div style=\"text-align: right;\"><a style=\"font-size: xx-small; font-family: verdana,arial,sans-serif; text-decoration: underline;\" href=\"/sugerirBairro.do\">Outro bairro?</a></div>\r\n\r\n\t<br/>\r\n<input id=\"openStatus\" name=\"criteria.openStatus\" dojoType=\"dijit.form.CheckBox\" type=\"checkbox\" checked=\"false\"  style=\"filter:none\"><label\r\n\tfor=\"onlyOpen\"> S&oacute; abertos </label>\r\n<button dojoType=\"dijit.form.Button\" baseClass=\"orangeButton\" id=\"searchBtn\">\r\n            Buscar\r\n</button>\r\n\r\n</div>\r\n</div>\r\n",
			constructor : function() {
				
			},
			selectedCity:null,
			postMixInProperties : function() {
				this.inherited(arguments);
			},

			postCreate : function() {
				this.inherited(arguments);
				dojo.parser.parse(this.domNode);
				try{
					this.selectedCity=identifiedCity;
					dojo.byId('cityName').innerHTML=this.selectedCity.name;
				}catch (e) {
					console.log(e);
					this.selectedCity="";
				}
				dojo.subscribe("onUserLocation",dojo.hitch(this,this.updateDefaultComboValues));
				dojo.connect(dijit.byId('searchBtn'), "onClick", this,	"executeSearch");
				dojo.connect(dojo.query('changeCity',this.domNode)[0], "onClick", this,	"changeCity");
				
				// IE does not render the dijit checkbox properly. Rip out the
				// dojoType
				// before it's parsed
				if (dojo.isIE) {
					
					dojo
							.query('[dojoType="dijit.form.CheckBox"]',
									this.domNode).forEach(function(x) {
								x.removeAttribute("dojoType");
							});
				}
				
				
				if(defaultCityKey!=null){
					this.neighborCache[defaultCityKey]=new dojo.data.ItemFileReadStore({data:defaultNeighborList});
				}
			},
			searchDeferred:null,
			executeSearch : function(event) {
				if(this.searchDeferred!=null){
					this.searchDeferred.cancel();
				}
				if (event) {
					// Stop the submit event since we want to control form submission.
					event.preventDefault();
					event.stopPropagation();
					dojo.stopEvent(event);
				}
				this.searchCriteria.value = '';
				if(dijit.byId('openStatus').attr("value")=="on"){
					this.searchCriteria.openStatus = true;
				}else{
					this.searchCriteria.openStatus = false;
				}
				
				this.saveLastSearchSelection();
				
				this.searchCriteria.neighbor = dijit.byId('neighSelection').value;
				this.searchCriteria.neighborName= dijit.byId('neighSelection').attr("displayedValue");
				this.searchCriteria.city=dijit.byId("citySelection").attr("value");
				var xhrParams = {
						error : dojo.hitch(this, "searchFailed"),
						form : dijit.byId('searchForm').domNode,
						handleAs : 'json',
						load : dojo.hitch(this, "searchResults"),
						url : '/searchRestaurants.do'
				};
				this.searchDeferred = dojo.xhrGet(xhrParams);
				dojo.publish("onSearchBeingExecuted");
				return false;
			},
			getCitySelection:function(){
				
				return dijit.byId("citySelection").attr("value");
			},
		saveLastSearchSelection:function(){
				var cityKey = dijit.byId("citySelection").attr("value");
				var cityName = dijit.byId("citySelection").attr('displayedValue');
				var neighKey = dijit.byId("neighSelection").attr("value");
				var searchSelectionCookie = {
						cityKey:cityKey,
						neighKey:neighKey,
						cityName:cityName
				};
				dojo.cookie("lastSelectedNeighborhood", dojo.toJson(searchSelectionCookie), {
		            expires: 30
		        });
		},
		loadCities:function (){
			var stateStore = null;
			if(cachedCityList!=null){				
				stateStore=new dojo.data.ItemFileReadStore({
					data:cachedCityList
				});
				
			}else{
				stateStore=new dojo.data.ItemFileReadStore({
	                url: "/listCitiesItemFileReadStore.do"
	            });	
			}
			
			if(dijit.byId("citySelection") && dijit.byId("citySelection")!=null){
				dijit.byId("citySelection").store = stateStore;
            	dijit.byId("citySelection").attr("value",this.initialCity);
			}
            
            
        },
        changeCity:function(){
        	dojo.style(dojo.byId('autoLocImg'),'display','none');
        	dojo.style(dojo.byId("changeCity"),"display","none");
        	dojo.style(dojo.byId("cityName"),"display","none");
        	dojo.style(dijit.byId("citySelection").domNode,"display","block");        	
        	this.loadCities();
        	
        },
        autolocationData:null,
        updateDefaultComboValues:function(data){
        	try{
        		
        		this.selectedCity=data.city;
        		this.autolocationData=data;        	
        		console.log("autolocData",this.autolocationData);
        		console.log("cityname",data.city);
        		dojo.byId('cityName').innerHTML=data.city;
        		dijit.byId("citySelection").store.fetch({
        			query: {
        			name: data.city
        		},
        		onBegin: dojo.hitch(this,this.clearOldCList),
        		onComplete: dojo.hitch(this,this.gotCity),
        		onError: dojo.hitch(this,this.fetchFailed), 
        		queryOptions: {
        			deep: true
        		}
        		});
        	}catch(e){
        		console.error("failed to updateDefaultComboValues",e);
        	}

        },
        clearOldCList:function(size, request){
        	console.log('onbegin',size);
        },
        hideToolTip:function(){
        	dijit.hideTooltip( dojo.byId("cityName"));
        },
              
        gotCity:function(items, request){        	
        	dojo.style(dojo.byId('autoLocImg'),'display','inline');

        	dijit.showTooltip("Localiza&ccedil;&atilde;o autom&aacute;tica", dojo.byId("cityName"),['before','above']);
        	setTimeout(dojo.hitch(this, this.hideToolTip), 2000);
        	if(items.length==0){
        		this.autoLocating=true;
        		this.saveXYCoordsForFutureAnalysis();
        		
        	}
        	var i;
        	for (i = 0; i < items.length; i++) {
        		var item = items[i];
        		dijit.byId("citySelection").attr('value',item.id);                    
        	}
        	this.autoLocating=true;
        	        	
        	this.autoLocating=false;
        	if(this.autolocationData.neighborhood){
        		this.changeNeighborhood(this.autolocationData);
        	}
        },
        autoLocating:false,
        fetchFailed:function(error, request){
        	console.error("fetchFailed",error);
        	
        },
        savedXY:function(data){
        	console.log("XY saved");
        },
        saveXYCoordsForFutureAnalysisOld:function(){
        	try{
        		var x=this.autolocationData.x;
        		var y=this.autolocationData.y;
        		var formattedAddress = this.autolocationData.formatted_address;
        		var form = dojo.create('form', { action:"/addXYCoords.do", method: "post"});        	
        		var xInput = dojo.create('input',{ type:"text", value: x, name:"x"},form);
        		var yInput = dojo.create('input',{ type:"text", value: y, name:"y"},form);
        		var formattedAddressInput = dojo.create('input',{ type:"text", value: formattedAddress, name:"formattedAddress"},form);
		        var xhrParams = {
		        		error : function(error){
		        			console.log('failed to save coords ',error);
		        			},
		        		form : form,
		        		handleAs : 'text',
		        		load : dojo.hitch(this, "savedXY")        			
		        		};
        		dojo.xhrPost(xhrParams);
        	}catch(e){}
        },
        
        fetchNeigFailed:function(error, request){
        	console.error("fetchFailed to find neighborhood",error);
        },
        saveXYCoordsForFutureAnalysis:function(){
        	console.warn("handling unknwon location to find neighborhood");
        	if(this.getCookieVal("candidateLoaded")!=null){
    			this.loadedCandidates(this.getCookieVal("candidateLoaded"));
        	}else{
        		try{
        			var x=this.autolocationData.x;
        			var y=this.autolocationData.y;
        			var formattedAddress = this.autolocationData.formatted_address;
        			var form = dojo.create('form', { action:"/autolocate.do", method: "post"});        	
        			var xInput = dojo.create('input',{ type:"text", value: x, name:"x"},form);
        			var yInput = dojo.create('input',{ type:"text", value: y, name:"y"},form);
        			var formattedAddressInput = dojo.create('input',{ type:"text", value: formattedAddress, name:"formattedAddress"},form);
        			var xhrParams = {
        					error : dojo.hitch(this,function(error){
        						console.log('failed to save coords ',error);	
        						this.fetchNeigFailed(error, null);
        					}),
        					form : form,
        					handleAs : 'json',
        					load :dojo.hitch(this,this.loadedCandidates)

        			};
        			dojo.xhrPost(xhrParams);
        		}catch(e){}
        	}
        	//this.saveXYCoordsForFutureAnalysis();

        },        
        neighborCache:{},
        onCityUpdate:function(){
	        try {
	        	
				var cityKey = dijit.byId("citySelection").attr("value");
				if(cityKey==null||cityKey==''){
					cityKey=this.initialCity;
				}
				
				var stateStore;
				
				if(this.neighborCache[cityKey]!=null){
					stateStore=this.neighborCache[cityKey];
				}else{
					stateStore=new dojo.data.ItemFileReadStore( {
						url : "/listNeighborsByCity.do?key=" + cityKey
					});
				}
					
				dijit.byId("neighSelection").reset();
				dijit.byId("neighSelection").queryExpr="*${0}*";
				dijit.byId("neighSelection").store = stateStore;
				this.neighborCache[cityKey]=stateStore;
				console.log('isautolocation? ',this.autoLocating);
				if(this.autoLocating==true){
					console.log("should set neighborhood:",this.autolocationData );
					this.autoLocating=false;
					if(this.autolocationData.neighborhood){
						this.changeNeighborhood(this.autolocationData);
					}
				}else{
					try{
						dijit.byId("neighSelection").attr("value",this.initialNeighborhood);
					}catch(e){
						console.log('cannot set initial neighborhood');
					}
				}
				dojo.publish('onCityChanged');
			} catch (e) {
				console.error("Getting city key", e);
			}
        },        
        changeNeighborhood:function(locationData){
        	dijit.byId("neighSelection").store.fetch({
                query: {
                    name: locationData.neighborhood
                },
                onBegin: dojo.hitch(this,this.clearOldCList),
                onComplete: dojo.hitch(this,this.gotAutoNeighbor),
                onError: dojo.hitch(this,this.fetchNeigFailed), 
                queryOptions: {
                    deep: true
                }
            });
        },
        loadedCandidates:function(data){
        	console.log(data);
        	if(data.length==0){        		
        		this.fetchNeigFailed(null, null);
        	}else{
        		console.log("found a neighborhood based on X/Y");
        		dijit.byId("neighSelection").attr('value',data[0].id);
        		this.tempSaveCookie("candidateLoaded", data);
        		
        	}
        },
        tempSaveCookie:function(key,val){						
			dojo.cookie("SearchRestaurantsWidget_"+key, dojo.toJson(val), { expires: 1 });
		},
		getCookieVal:function(key){
			var a = dojo.cookie("SearchRestaurantsWidget_"+key);
			if(a){
				return dojo.fromJson(a);
			}else{
				return null;
			}
		},
        gotAutoNeighbor:function(items, request){
        	console.log(items)            
            var i;
        	if(items.length==0){
        		this.saveXYCoordsForFutureAnalysis();
        		
        	}else{
	            for (i = 0; i < items.length; i++) {
	                var item = items[i];
	                dijit.byId("neighSelection").attr('value',item.id);
	                
	            }
        	}
        },
		searchCriteria : {
			value : null,
			neighbor:null,
			city:null,
			neighborName:null,
			openStatus:false
		},
		searchFailed : function(response) {
			this.searchDeferred=null;
			if(response.message!='xhr cancelled'){
				var errorData = dojo.fromJson(response.responseText);
				
			}
		},
		searchResults : function(response) {
			this.searchDeferred=null;
			var searchManager = dijit.byId("searchResultsManager");
			searchManager.updateResults(response, this.searchCriteria);
		},
		startup : function() {
			dojo.parser.parse(this.domNode);
			this.initialCity=this.selectedCity.id;
			dijit.byId("neighSelection").queryExpr="*${0}*";
			dojo.connect(dijit.byId("citySelection"), "onChange", dojo.hitch(this,this.onCityUpdate));
			if(this.hasLastSelection()==true){	
				this.initialCity=this.lastSelection.cityKey;
				this.initialNeighborhood=this.lastSelection.neighKey;
				this.updateCityFromCookie(this.lastSelection.cityKey,this.lastSelection.cityName);				
			}else{
				
				this.onCityUpdate();
				this.geolocateUserLocation();
			}
			
			
			console.log('loadingCities');
			
			this.loadCities();
			
		},		
		updateCityFromCookie:function(cityKey,cityName){
			console.log("city from cookie",cityKey);
			this.selectedCity={	
					id:cityKey,
					name:cityName
			};
			
						
			dojo.byId('cityName').innerHTML=cityName;
			
		},
		getSelectedNeighborhood:function(){
			var n=null;
			try{
				n={id:dijit.byId("neighSelection").attr("value"),name:dijit.byId("neighSelection").attr("displayedValue")}
			}catch(e){
				console.error(e);
			}
			return n;
		},
		initialCity:null,
		initialNeighborhood:null,
		lastSelection:null,
		hasLastSelection:function(){
			this.lastSelection = dojo.cookie("lastSelectedNeighborhood");
			if(this.lastSelection!=null){
				this.lastSelection=dojo.fromJson(this.lastSelection);
				return true;	
			}
			console.log("has already selected.",this.lastSelection);
			return false;
		},	
		geoLocator:null,
		geolocateUserLocation:function(){
			if(this.geoLocator==null){
				this.geoLocator = new com.copacabana.lbs.FindUserLocation();
				this.geoLocator.startup();
			}
			this.geoLocator.findLocation();
		}

});

}

if(!dojo._hasResource["com.copacabana.search.SearchResultsItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.search.SearchResultsItem"] = true;
dojo.provide("com.copacabana.search.SearchResultsItem");







//I18N


 
 
//

dojo.declare("com.copacabana.search.SearchResultsItem", [
		dijit._Widget, dijit._Templated,com.copacabana.DeclarativeTemplate  ], {
	//i18nStrings: dojo.i18n.getLocalization("com.copacabana.search", "SearchResultsManagerWidgetStrings"),
	templateString:"<div class=\"widgetContent\">\r\n<style>\r\n.item:HOVER{\r\nbackground-color:silver;\r\n}\r\n</style>\r\n<div class=\"item\" style=\"cursor: pointer;\"\r\n\tdojoAttachEvent=\"onclick:onClick\"><span\r\n\tclass=\"status\">.</span> <span class=\"titulo\">.</span> <br />\r\n<span class=\"quantidade\">.</span></div>\r\n</div>\r\n",
	constructor : function() {
		console.log('created',this.id);
	},
	postMixInProperties : function() {
		console.log('postMixInProperties',this.id);
		this.inherited(arguments);
		console.log('postMixInProperties',this.id);
	},

	postCreate : function() {
		console.log('postCreate',this.id);
		this.inherited(arguments);	
		console.log('postCreate',this.id);
	},
	
	headerNode:null,
	initialized:false,
	startup : function() {
		try {
			console.log('going to start?',this.id)
			dojo.parser.parse(this.domNode);
			
			if(dojo.query('[dojoAttachPoint=sectionItem]',this.domNode).length>0){
				var dom = dojo.query('[dojoattachpoint=sectionItem]',this.domNode)[0]
				this.sectionItem=dom;
				
				this.sectionItem.onclick=this.onClick;
			}
			
			console.log('sectionItem',this.sectionItem);
		} catch (e) {
			console.error(e)
		}
	},
	rest:null,
	setRestaurant:function(rest){
		this.rest=rest;
		var restNameNode = dojo.query(".titulo",this.domNode)[0];
		restNameNode.innerHTML=rest.name;
		var restStatusNode = dojo.query(".status",this.domNode)[0];
		
		console.log(rest.isOpen,rest.siteStatus);
		if(rest.siteStatus!='ACTIVE'){
			restStatusNode.title="Brevemente disponivel no ComendoBem."
			dojo.addClass(restStatusNode,'restaurantSoon');
			dojo.removeClass(restStatusNode,'restaurantClosed');
			restStatusNode.innerHTML='Breve';
		}else{
			
			
			if(rest.isOpen === true){
				restStatusNode.title="Restaurante aberto."				
				
				restStatusNode.innerHTML="Aberto";
			}else{
				restStatusNode.title="Restaurante fechado, verique o horario de abetura e fechamento."
				restStatusNode.innerHTML="Fechado";
			}
		}
		var restDetailsNode = dojo.query(".quantidade",this.domNode)[0];
		restDetailsNode.innerHTML=rest.description;
		dojo.parser.parse(this.domNode);
	},	
	onClick:function(evt){
		if(this.rest){
			dojo.publish("onOpenRestaurant",[this.rest]);	
		}else{
			
		}
		
	},
	onMouseEnter:function(evt){		
		/*var panel = dojo.query(".item",this.domNode)[0];
		dojo.style(panel,"backgroundColor","silver");		
		dojo.parser.parse(this.domNode);	*/		
	},
	onMouseOut:function(evt){
		/*
		var panel = dojo.query(".item",this.domNode)[0];
		dojo.style(panel,"backgroundColor","white");
		dojo.parser.parse(this.domNode);*/		
	}

});

}

if(!dojo._hasResource["com.copacabana.search.SearchResultsManagerWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.search.SearchResultsManagerWidget"] = true;
dojo.provide("com.copacabana.search.SearchResultsManagerWidget");











//I18N


 


dojo.declare("com.copacabana.search.SearchResultsManagerWidget", [
		dijit._Widget, dijit._Templated,com.copacabana.DeclarativeTemplate ], {
	i18nStrings: null,
	templateString:"<div class=\"widgetContent\">\r\n\r\n<div id=\"topoResultado\">\r\n<div class=\"canto cantoSupDir\"></div>\r\n\r\n\r\n<h2>${i18nStrings.resultsTitleLabel}</h2>\r\n\r\n<p id=\"resultadoMensagem\" class=\"resultadoMensagem\"></p>\r\n<div class=\"canto cantoInfDir\"></div>\r\n</div>\r\n\r\n<div id=\"itensBusca\" class=\"resultsList\">\r\n\r\n</div>\r\n\r\n<!-- <div id=\"paginacao\"><span class=\"voltar\">Primeira |\r\nAnterior</span> <span class=\"paginas\">1, <span class=\"selecionado\">2</span>,\r\n3, 4</span> <span class=\"avancar\">Pr&oacute;xima | &Uacute;ltima</span></div>-->\r\n</div>\r\n",
	constructor : function() {
		console.log('manager created');
	},
	
	domValues : {
		totalRestaurants : 0,
		totalItems : 0,
		showingStart : 0,
		showingEnd : 0,
		searchedValue : ''
	},

	postMixInProperties : function() {
		this.inherited(arguments);
		console.log('manager postMixInProperties')
	},

	postCreate : function() {
		this.inherited(arguments);
		console.log('manager postCreate')
		dojo.subscribe("onSearchBeingExecuted",this,"cleanResultsNWait");
		this.i18nStrings=dojo.i18n.getLocalization("com.copacabana.search", "SearchResultsManagerWidgetStrings");
        

	},
	headerNode:null,
	resultsNode:null,
	startup : function() {
		try {
			console.log('starting manager')
			
			
			this.headerNode = dojo.query(".resultadoMensagem",this.domNode)[0];
			this.resultsNode = dojo.query(".resultsList",this.domNode)[0];
			console.log("this.resultsNode",this.resultsNode);
			//this.imageNode =  dojo.create('img',{src:dojo.moduleUrl("com.copacabana", "images/loader.gif"),title:'buscando...',alt:'buscando...'});
			
			//dojo.parser.parse(this.domNode);
			
		} catch (e) {
			console.error(e);
		}
	},
	
	cleanResultsNWait:function(){
		console.log('cleanResultsNWait',this.resultsNode);
		com.copacabana.util.cleanNode(this.resultsNode);
		//this.resultsNode.appendChild(this.imageNode);
		dojo.create('img',{src:dojo.moduleUrl("com.copacabana", "images/loader.gif"),title:'buscando...',alt:'buscando...',width:32,height:32},this.resultsNode)
	},
	updateResults:function(results,searchCriteria){
		com.copacabana.util.cleanNode(this.resultsNode);
		if(searchCriteria.openStatus==true){
			var auxList=[];
			for ( var i = 0; i < results.length; i++) {					
				if(results[i].isOpen==true){
					auxList.push(results[i]);
				}					
			}
			results=auxList;
		}
		var criteria;
		if(searchCriteria.value && searchCriteria.value!=''){
			if(searchCriteria.openStatus==true){
				criteria= dojo.string.substitute(this.i18nStrings.searchCriteriaOpenNeigFreeform, [searchCriteria.neighborName,searchCriteria.value ]);
			}else{
				criteria= dojo.string.substitute(this.i18nStrings.searchCriteriaNeigFreeform, [searchCriteria.neighborName,searchCriteria.value ]);
			}
		}else{
			if(searchCriteria.openStatus==true){
				criteria= dojo.string.substitute(this.i18nStrings.searchCriteriaNeigOpen, [searchCriteria.neighborName ]);
			}else{
				criteria= dojo.string.substitute(this.i18nStrings.searchCriteriaNeig, [searchCriteria.neighborName ]);
			}
		}
		if(results.length===0){
			criteria+= this.i18nStrings.suggestLink;
			this.headerNode.innerHTML = dojo.string.substitute(this.i18nStrings.noResultsFoundLable, [criteria]);
		} else {
			var str = dojo.string.substitute(this.i18nStrings.foundResultsLabel, [results.length, 0,criteria]);			
			var start = 1;
			str += dojo.string.substitute(this.i18nStrings.showingLabel, [ start, results.length]);
			this.headerNode.innerHTML = str;
			for ( var j = 0; j < results.length; j++) {
				var item = new com.copacabana.search.SearchResultsItem();
				item.setRestaurant(results[j]);				
				item.startup();
				this.resultsNode.appendChild(item.domNode);
			}

			dojo.parser.parse(this.domNode);
		}
		
	}

});

}

if(!dojo._hasResource["com.copacabana.pages.ProfileMenu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["com.copacabana.pages.ProfileMenu"] = true;
dojo.provide("com.copacabana.pages.ProfileMenu");








 










com.copacabana.pages.ProfileMenu.foodCategories = null;
com.copacabana.pages.ProfileMenu.filterCategories=function(filter){
	com.copacabana.pages.ProfileMenu.foodCategories=com.copacabana.util.loadFoodCats();
	var sortAttributes = [{attribute: "name", descending: false}];
	var completed =function (items, findResult){
		try{
			var newFilteredList = [];
			for ( var i = 0; i < items.length; i++) {
				var id =com.copacabana.pages.ProfileMenu.foodCategories.getValue(items[i],"id");;
				if(filter[id]==true){
					var name =com.copacabana.pages.ProfileMenu.foodCategories.getValue(items[i],"name");;
					newFilteredList.push({id:id,name:name});
				}
			}
			var store = new dojo.data.ItemFileReadStore({data: { identifier: "id",
				items:newFilteredList
			}});
			dijit.byId("foodCategoriesSelection").store = store;
			if(com.copacabana.pages.ProfileMenu.currCat!=null){
				dijit.byId("foodCategoriesSelection").attr('value',com.copacabana.pages.ProfileMenu.currCat);	
			}
		}catch (e) {
			console.error('failed to update cat list ',e);
		}

	}
	var error = function (errData, request){
		console.log("Failed filtering data.",errData);
	}
	com.copacabana.pages.ProfileMenu.foodCategories.fetch({onComplete: completed, onError: error, sort: sortAttributes});
};
com.copacabana.pages.ProfileMenu.loadFoodCat=function(){
	dojo.subscribe('categoriesAvailable',com.copacabana.pages.ProfileMenu.filterCategories);
	
	
	if(!com.copacabana.pages.ProfileMenu.foodCategories && com.copacabana.pages.ProfileMenu.foodCategories==null){
		com.copacabana.pages.ProfileMenu.foodCategories=com.copacabana.util.loadFoodCats();
	}

	var sortAttributes = [{attribute: "name", descending: false}];

	var completed =function (items, findResult){
		var store = new dojo.data.ItemFileReadStore({data: { identifier: "id",
			items:items
		}});

		dijit.byId("foodCategoriesSelectionForPlates").store = store;
		dijit.byId("foodCategoriesSelection").store = store;
		dojo.connect(dijit.byId("foodCategoriesSelection"),"onChange",com.copacabana.pages.ProfileMenu.categoryChanged);

	}
	var error = function (errData, request){
		console.log("Failed in sorting data.",errData);
		dijit.byId("foodCategoriesSelectionForPlates").store = com.copacabana.pages.ProfileMenu.foodCategories;
		dijit.byId("foodCategoriesSelection").store = com.copacabana.pages.ProfileMenu.foodCategories;
	}
	//com.copacabana.pages.ProfileMenu.foodCategories.fetch({onComplete: completed, onError: error, sort: sortAttributes});
	com.copacabana.pages.ProfileMenu.foodCategories.fetch({onComplete: completed, onError: error, sort: sortAttributes});


}

com.copacabana.pages.ProfileMenu.categoryChanged = function(){
	var cat = dijit.byId("foodCategoriesSelection").attr("value");
	com.copacabana.util.showLoading();
	var args = { 
        identity: cat,  
        onItem : function(item, request) {	
			com.copacabana.util.hideLoading();	        
			if(!item){
				dojo.publish("onCategoryChanged",[{"catId":'all',"catName":'Todas categorias'}]);
			}	else{	
				dojo.publish("onCategoryChanged",[{"catId":cat,"catName":item.name[0]}]);
			}
		},
	    onError : function(item, request) {
    		console.error(item);
    		com.copacabana.util.hideLoading();
    		var msg = new com.copacabana.MessageWidget();
			msg.showMsg("Erro ao carregar categoria. Por favor tente novamente.",msg.errorType);
    		
    	    
    	}
	}
	dijit.byId("foodCategoriesSelection").store.fetchItemByIdentity(args);
};

com.copacabana.pages.ProfileMenu.editPlateOption =function(mainPlateId,mainPlateName,plateOption){
	dijit.byId("plateOptionForm").reset();
	var d={
		plate:{
			extendsPlate:mainPlateId,
			id:plateOption.id,
			title:plateOption.title,
			description:plateOption.description,
			price:plateOption.price,			
			foodCategory:plateOption.foodCategory,
			imageUrl:plateOption.imageUrl,
			status:plateOption.status,
			
			plateSize:plateOption.plateSize
		},
		restaurant:loggedRestaurant.id
	
		
	};
	if(plateOption.id==null || plateOption.id==''){
		d.plate.status='AVAILABLE';
		d.plate.price='0,00';
		d.plate.plateSize='NONE';
	}
	dijit.byId('plateOptionDialog').attr('value', d);
	dijit.byId('plateOptionDialog').show();
	
	
	
}

com.copacabana.pages.ProfileMenu.editPlate =function(data){
	
	var d={
		plate:{
			id:data.id,
			title:data.title,
			description:data.description,
			price:data.price,
			foodCategory:data.foodCategory,
			imageUrl:data.imageUrl,
			status:data.status
		},
		restaurant:data.restaurant
	
		
	};
	
	
	dijit.byId('plateForm').attr('value', d);
	com.copacabana.pages.ProfileMenu.showDialog(null,d.plate.title);
	dojo.byId('restaurant').value=loggedRestaurant.id;
	
	
}

com.copacabana.pages.ProfileMenu.showDialog =function(evt,title){
	if(title){
		dijit.byId('dialog1').attr("title",title);
		dojo.style(dijit.byId('deletebutton').domNode,'visibility','visible');
	}else{
		dijit.byId('dialog1').attr("title","Novo prato");
		dojo.style(dijit.byId('deletebutton').domNode,'visibility','hidden');
	}
	dijit.byId('dialog1').show();
	dojo.byId('restaurant').value=loggedRestaurant.id;	
}
com.copacabana.pages.ProfileMenu.deletePlate = function(){
	var idToDelete = dijit.byId("id").attr('value');
	var msg = new com.copacabana.MessageWidget();
	var options=[
	             {
	            	id:"yes",
	            	label:"Sim"		            	
	             },
	             {
		            	id:"no",
		            	label:"N&atilde;o"		            	
	             }				         
	];
	var completeFct = function(response){
		com.copacabana.pages.ProfileMenu.confirmDelete(response,idToDelete);
	};				             
	msg.promptMsg("Voc&ecirc; tem certeza que deseja apagar este produto? <br/><span style='font-size:x-small'>* qualquer op&ccedil;&atilde;o deste produto tamb&eacute;m ser&aacute; apagada.</span>",options,completeFct,"Confirmar");
	
};

com.copacabana.pages.ProfileMenu.deleteOptionPlate=function(idToDelete){	
	var msg = new com.copacabana.MessageWidget();
	var options=[
	             {
	            	id:"yes",
	            	label:"Sim"		            	
	             },
	             {
		            	id:"no",
		            	label:"N&atilde;o"		            	
	             }				         
	];
	var completeFct = function(response){
		if(response=='yes'){			
			var form = dojo.create('form',{action:'/deletePlate.do',method:'post'},dojo.body());
			dojo.create('input',{type:'hidden',name:'id',value:idToDelete},form);
			
			var xhrArgs = {
	                form:form,//dojo.byId("plateForm"),
	                handleAs: "json",
	                load: function(data) {	                    	
						dijit.byId("plateListWidget").refreshPlateList();
	                },
	                error: function(error) {
	                    //We'll 404 in the demo, but that's okay.  We don't have a 'postIt' service on the
	                    //docs server.	                    
	                    var msg = new com.copacabana.MessageWidget();
	    				msg.showMsg("Erro ao apagar registro. Por favor tente novamente.",msg.errorType);
	                                 
	                }
	            }
	            //Call the asynchronous xhrPost	                
	            var deferred = dojo.xhrPost(xhrArgs);
		  		
		}
	};				             
	msg.promptMsg("Voc&ecirc; tem certeza que deseja apagar esta op&ccedil;&atilde;o de produto?",options,completeFct,"Confirmar");
}

com.copacabana.pages.ProfileMenu.confirmDelete=function(response,id){
	if(response=='yes'){
		dijit.byId("dialog1").hide();
		dijit.byId("plateForm").reset();
		
		var form = dojo.create('form',{action:'/deletePlate.do',method:'post'},dojo.body());
		dojo.create('input',{type:'hidden',name:'id',value:id},form);
		
		var xhrArgs = {
                form:form,//dojo.byId("plateForm"),
                handleAs: "json",
                load: function(data) {	                    	
					dijit.byId("plateListWidget").refreshPlateList();
                },
                error: function(error) {
                    //We'll 404 in the demo, but that's okay.  We don't have a 'postIt' service on the
                    //docs server.
                    console.log("Form error ",error);
                    var msg = new com.copacabana.MessageWidget();
    				msg.showMsg("Erro ao apagar registro. Por favor tente novamente.",msg.errorType);
                                 
                }
            }
            //Call the asynchronous xhrPost	                
            var deferred = dojo.xhrPost(xhrArgs);
	  		
	}
};
com.copacabana.pages.ProfileMenu.currCat=null;

com.copacabana.pages.ProfileMenu.savePlate = function(){
	if(!com.copacabana.util.checkValidForm(null,dijit.byId("plateForm").domNode)){				
		return;
	}else{
		
		
		com.copacabana.util.showLoading();
		var xhrArgs = {
				form:dijit.byId("plateForm").domNode,
				handleAs: "json",
				load: function(data) {	                    	
					var entity= data;
					com.copacabana.util.hideLoading();
					dijit.byId("dialog1").hide();
					dijit.byId("plateForm").reset();
					dijit.byId("plateListWidget").addPlate(data);
					com.copacabana.pages.ProfileMenu.currCat=data.foodCategory;
					
				},
				error: function(error) {
					//We'll 404 in the demo, but that's okay.  We don't have a 'postIt' service on the
					//docs server.
					com.copacabana.util.hideLoading();
					console.log("Form error ",error);	
					var msg = new com.copacabana.MessageWidget();
					msg.showMsg("Erro ao salvar prato. Por favor tente novamente.",msg.errorType);


				}
		}
		//Call the asynchronous xhrPost	                
		var deferred = dojo.xhrPost(xhrArgs);
	}	
};

com.copacabana.pages.ProfileMenu.createNewPlate=function(){
	dijit.byId("plateForm").reset();
	
	var cat = dijit.byId("foodCategoriesSelection").attr("value");
	
	if(cat){
		dijit.byId("foodCategoriesSelectionForPlates").attr("value",cat);
	}
	dijit.byId("price").attr("value",'0,00');
	dijit.byId('plateStatus').attr('value','AVAILABLE');	
	
	com.copacabana.pages.ProfileMenu.showDialog();
};

com.copacabana.pages.ProfileMenu.savePlateOption = function(){
	if(!com.copacabana.util.checkValidForm(null,dijit.byId("plateOptionForm").domNode)){				
		return;
	}else{
		com.copacabana.util.showLoading();
		var xhrArgs = {
				form:dijit.byId("plateOptionForm").domNode,
				handleAs: "json",
				load: function(data) {	                    	
					var entity= data;
					com.copacabana.util.hideLoading();
					dijit.byId("plateOptionDialog").hide();
					dijit.byId("plateOptionForm").reset();
					//dijit.byId("plateListWidget").addPlate(data);
					com.copacabana.pages.ProfileMenu.currCat=data.foodCategory;
					dijit.byId("plateListWidget").refreshPlateList();
					
				},
				error: function(error) {
					//We'll 404 in the demo, but that's okay.  We don't have a 'postIt' service on the
					//docs server.
					com.copacabana.util.hideLoading();
					console.log("Form error ",error);	
					var msg = new com.copacabana.MessageWidget();
					msg.showMsg("Erro ao salvar prato. Por favor tente novamente.",msg.errorType);


				}
		}
		//Call the asynchronous xhrPost	                
		var deferred = dojo.xhrPost(xhrArgs);
	}	
};


}


dojo.i18n._preloadLocalizations("com.nls.cb", ["ROOT","pt","xx"]);
